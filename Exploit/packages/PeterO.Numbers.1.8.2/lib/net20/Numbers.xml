<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Numbers</name>
    </assembly>
    <members>
        <member name="T:PeterO.Numbers.EDecimal">
            <summary>
             Represents an arbitrary-precision decimal
            floating-point number. (The "E" stands for "extended",
            meaning that instances of this class can be values
            other than numbers proper, such as infinity and
            not-a-number.)
            <para><b>About decimal arithmetic</b>
            </para>
            <para>Decimal (base-10) arithmetic, such as that provided by this
            class, is appropriate for calculations involving such real-world
            data as prices and other sums of money, tax rates, and
            measurements. These calculations often involve multiplying or
            dividing one decimal with another decimal, or performing other
            operations on decimal numbers. Many of these calculations also rely
            on rounding behavior in which the result after rounding is an
            arbitrary-precision decimal number (for example, multiplying a
            price by a premium rate, then rounding, should result in a decimal
            amount of money).</para>
            <para>On the other hand, most implementations of <c>float</c>
             and
            <c>double</c>
             , including in C# and Java, store numbers in a binary
            (base-2) floating-point format and use binary floating-point
            arithmetic. Many decimal numbers can't be represented exactly in
            binary floating-point format (regardless of its length). Applying
            binary arithmetic to numbers intended to be decimals can sometimes
            lead to unintuitive results, as is shown in the description for the
            FromDouble() method of this class.</para>
            <para><b>About EDecimal instances</b>
            </para>
            <para>Each instance of this class consists of an integer
            significand and an integer exponent, both arbitrary-precision. The
            value of the number equals significand * 10^exponent.</para>
            <para>The significand is the value of the digits that make up a
            number, ignoring the decimal point and exponent. For example, in
            the number 2356.78, the significand is 235678. The exponent is
            where the "floating" decimal point of the number is located. A
            positive exponent means "move it to the right", and a negative
            exponent means "move it to the left." In the example 2, 356.78, the
            exponent is -2, since it has 2 decimal places and the decimal point
            is "moved to the left by 2." Therefore, in the arbitrary-precision
            decimal representation, this number would be stored as 235678 *
            10^-2.</para>
            <para>The significand and exponent format preserves trailing zeros
            in the number's value. This may give rise to multiple ways to store
            the same value. For example, 1.00 and 1 would be stored
            differently, even though they have the same value. In the first
            case, 100 * 10^-2 (100 with decimal point moved left by 2), and in
            the second case, 1 * 10^0 (1 with decimal point moved 0).</para>
            <para>This class also supports values for negative zero,
            not-a-number (NaN) values, and infinity. <b>Negative zero</b>
             is
            generally used when a negative number is rounded to 0; it has the
            same mathematical value as positive zero. <b>Infinity</b>
             is
            generally used when a non-zero number is divided by zero, or when a
            very high or very low number can't be represented in a given
            exponent range. <b>Not-a-number</b>
             is generally used to signal
            errors.</para>
            <para>This class implements the General Decimal Arithmetic
            Specification version 1.70 except part of chapter 6(
            <c>http://speleotrove.com/decimal/decarith.html</c>
             ).</para>
            <para><b>Errors and Exceptions</b>
            </para>
            <para>Passing a signaling NaN to any arithmetic operation shown
            here will signal the flag FlagInvalid and return a quiet NaN, even
            if another operand to that operation is a quiet NaN, unless the
            operation's documentation expressly states that another result
            happens when a signaling NaN is passed to that operation.</para>
            <para>Passing a quiet NaN to any arithmetic operation shown here
            will return a quiet NaN, unless the operation's documentation
            expressly states that another result happens when a quiet NaN is
            passed to that operation. Invalid operations will also return a
            quiet NaN, as stated in the individual methods.</para>
            <para>Unless noted otherwise, passing a null arbitrary-precision
            decimal argument to any method here will throw an exception.</para>
            <para>When an arithmetic operation signals the flag FlagInvalid,
            FlagOverflow, or FlagDivideByZero, it will not throw an exception
            too, unless the flag's trap is enabled in the arithmetic context
            (see EContext's Traps property).</para>
            <para>If an operation requires creating an intermediate value that
            might be too big to fit in memory (or might require more than 2
            gigabytes of memory to store -- due to the current use of a 32-bit
            integer internally as a length), the operation may signal an
            invalid-operation flag and return not-a-number (NaN). In certain
            rare cases, the CompareTo method may throw OutOfMemoryException
            (called OutOfMemoryError in Java) in the same circumstances.</para>
            <para><b>Serialization</b>
            </para>
            <para>An arbitrary-precision decimal value can be serialized
            (converted to a stable format) in one of the following ways:</para>
            <list><item>By calling the toString() method, which will always
            return distinct strings for distinct arbitrary-precision decimal
            values.</item>
             <item>By calling the UnsignedMantissa, Exponent, and
            IsNegative properties, and calling the IsInfinity, IsQuietNaN, and
            IsSignalingNaN methods. The return values combined will uniquely
            identify a particular arbitrary-precision decimal value.</item>
            </list>
            <para><b>Thread safety</b>
            </para>
            <para>Instances of this class are immutable, so they are inherently
            safe for use by multiple threads. Multiple instances of this object
            with the same properties are interchangeable, so they should not be
            compared using the "==" operator (which might only check if each
            side of the operator is the same instance).</para>
            <para><b>Comparison considerations</b>
            </para>
            <para>This class's natural ordering (under the CompareTo method) is
            not consistent with the Equals method. This means that two values
            that compare as equal under the CompareTo method might not be equal
            under the Equals method. The CompareTo method compares the
            mathematical values of the two instances passed to it (and
            considers two different NaN values as equal), while two instances
            with the same mathematical value, but different exponents, will be
            considered unequal under the Equals method.</para>
            <para><b>Security note</b>
            </para>
            <para>It is not recommended to implement security-sensitive
            algorithms using the methods in this class, for several
            reasons:</para>
            <list><item><c>EDecimal</c>
             objects are immutable, so they can't be
            modified, and the memory they occupy is not guaranteed to be
            cleared in a timely fashion due to garbage collection. This is
            relevant for applications that use many-digit-long numbers as
            secret parameters.</item>
             <item>The methods in this class
            (especially those that involve arithmetic) are not guaranteed to be
            "constant-time" (non-data-dependent) for all relevant inputs.
            Certain attacks that involve encrypted communications have
            exploited the timing and other aspects of such communications to
            derive keying material or cleartext indirectly.</item>
             </list>
            <para>Applications should instead use dedicated security libraries
            to handle big numbers in security-sensitive algorithms.</para>
            <para><b>Reproducibility note</b>
            </para>
            <para>Some applications, such as simulations, care about results
            that are reproducible, bit for bit, across computers and across
            runs of the application. Bruce Dawson, in "Floating-Point
            Determinism" ( <c>https://randomascii.wordpress.com/</c>
            <c>2013/07/16/floating-point-determinism/</c>
             ), identified many
            reproducibility issues with floating-point numbers, and here is how
            they relate to the EDecimal and EFloat classes of this
            library:</para>
            <list><item>Runtime floating-point settings: All the settings that
            change how EDecimal and EFloat behave are given as parameters to
            the appropriate methods, especially via EContext objects, which
            specify the precision, rounding, and exponent range of numbers,
            among other things. The EDecimal and EFloat classes avoid the use
            of "native" floating-point data types (except for methods that
            convert to or from <c>float</c>
             , <c>double</c>
             , or
            <c>System.Decimal</c>
             ). Such "native" types are often subject to
            runtime settings that change how floating-point math behaves with
            them, and these settings are often not accessible to .NET or Java
            code.</item>
             <item>Non-associativity and intermediate precisions:
            In general, EDecimal and EFloat use "unlimited" precision in their
            calculations unless specified otherwise by an EContext object.
            However, by limiting the precision of EDecimal, EFloat, and other
            floating-point numbers in this way, operations such as addition and
            multiplication on three or more numbers can be
            <i>non-associative</i>
             , meaning the result can change depending on
            the order in which those numbers are added or multiplied. This
            property means that if an algorithm does not ensure such numbers
            are added or multiplied in the same order every time, its results
            may not be reproducible across computers or across runs of the
            application. This non-associativity problem can happen, for
            example, if an application splits a calculation across several
            threads and combines their results in the end. The problems with an
            unspecified order of operations (in the same line of code) and
            intermediate precisions (problems present in C and C++, for
            example) don't exist with method calls to EDecimal and EFloat
            methods, especially since they require limited-precision support to
            be declared explicitly via EContext.</item>
             <item>fmadd
            instruction: EDecimal and EFloat include a MultiplyAndAdd method
            with the same semantics as in the General Decimal Arithmetic
            Specification, which requires delivering correctly rounded results
            for this method.</item>
             <item>Square root estimate: Not applicable
            since EDecimal and EFloat don't include any estimates to square
            root.</item>
             <item>Transcendental functions: This includes
            logarithms, exponentials, and the Pi method. For these functions,
            results are not guaranteed to always be correctly rounded. When
            using transcendentals, an application that cares about
            reproducibility should choose one version of this library and stick
            to it; this at least has the advantage that the implementation will
            be the same across computers, unlike with "native" floating-point
            types where the choice of implementation is often not within the
            application's control.</item>
             <item>Conversions: Conversions
            between EDecimal or EFloat and text strings have the same
            implementation across computers for the same version of this
            library (see also the advice for transcendentals above). But as for
            the ToDouble, ToSingle, FromDouble, and FromSingle methods, note
            that some implementations of Java and.NET may or may not support
            preserving the value of subnormal numbers (numbers other than zero
            with the lowest possible exponent) or the payloads held in a
            not-a-number (NaN) value of float or double; thus these methods
            should not be considered reproducible across computers.</item>
            <item>Compiler differences: Not applicable where these classes
            don't use "native" floating-point types.</item>
             <item>Uninitialized
            data; per-processor code: Not applicable.</item>
             </list>
            <para><b>Forms of numbers</b>
            </para>
            <para>There are several other types of numbers that are mentioned
            in this class and elsewhere in this documentation. For reference,
            they are specified here.</para>
            <para><b>Unsigned integer</b>
             : An integer that's always 0 or
            greater, with the following maximum values:</para>
            <list><item>8-bit unsigned integer, or <i>byte</i>
             : 255.</item>
            <item>16-bit unsigned integer: 65535.</item>
             <item>32-bit unsigned
            integer: (2 <sup>32</sup>
             -1).</item>
             <item>64-bit unsigned
            integer: (2 <sup>64</sup>
             -1).</item>
             </list>
            <para><b>Signed integer</b>
             : An integer in <i>two's-complement
            form</i>
             , with the following ranges:</para>
            <list><item>8-bit signed integer: -128 to 127.</item>
             <item>16-bit
            signed integer: -32768 to 32767.</item>
             <item>32-bit signed
            integer: -2 <sup>31</sup>
             to (2 <sup>31</sup>
             - 1).</item>
            <item>64-bit signed integer: -2 <sup>63</sup>
             to (2 <sup>63</sup>
             -
            1).</item>
             </list>
            <para><b>Two's complement form</b>
             : In <i>two's-complement
            form</i>
             , nonnegative numbers have the highest (most significant)
            bit set to zero, and negative numbers have that bit (and all bits
            beyond) set to one, and a negative number is stored in such form by
            decreasing its absolute value by 1 and swapping the bits of the
            resulting number.</para>
            <para><b>64-bit floating-point number</b>
             : A 64-bit binary
            floating-point number, in the form <i>significand</i>
             * 2
            <sup><i>exponent</i>
             </sup>
            . The significand is 53 bits long
            (Precision) and the exponent ranges from -1074 (EMin) to 971
            (EMax). The number is stored in the following format (commonly
            called the IEEE 754 format):</para>
            <code>|C|BBB...BBB|AAAAAA...AAAAAA|</code>
            <list><item>A. Low 52 bits (Precision minus 1 bits): Lowest bits of
            the significand.</item>
             <item>B. Next 11 bits: Exponent area:
            <list><item>If all bits are ones, the final stored value is
            infinity (positive or negative depending on the C bit) if all bits
            in area A are zeros, or not-a-number (NaN) otherwise.</item>
            <item>If all bits are zeros, the final stored value is a subnormal
            number, the exponent is EMin, and the highest bit of the
            significand is zero.</item>
             <item>If any other number, the exponent
            is this value reduced by 1, then raised by EMin, and the highest
            bit of the significand is one.</item>
             </list>
             </item>
             <item>C.
            Highest bit: If one, this is a negative number.</item>
             </list>
            <para>The elements described above are in the same order as the
            order of each bit of each element, that is, either most significant
            first or least significant first.</para>
            <para><b>32-bit binary floating-point number</b>
             : A 32-bit binary
            number which is stored similarly to a <i>64-bit floating-point
            number</i>
             , except that:</para>
            <list><item>Precision is 24 bits.</item>
             <item>EMin is -149.</item>
            <item>EMax is 104.</item>
             <item>A. The low 23 bits (Precision minus
            1 bits) are the lowest bits of the significand.</item>
             <item>B. The
            next 8 bits are the exponent area.</item>
             <item>C. If the highest
            bit is one, this is a negative number.</item>
             </list>
            <para><b>.NET Framework decimal</b>
             : A 128-bit decimal
            floating-point number, in the form <i>significand</i>
             * 10 <sup>-
            <i>scale</i>
             </sup>
             , where the scale ranges from 0 to 28. The
            number is stored in the following format:</para>
            <list><item>Low 96 bits are the significand, as a 96-bit unsigned
            integer (all 96-bit values are allowed, up to (2 <sup>96</sup>
            -1)).</item>
             <item>Next 16 bits are unused.</item>
             <item>Next 8
            bits are the scale, stored as an 8-bit unsigned integer.</item>
            <item>Next 7 bits are unused.</item>
             <item>If the highest bit is
            one, it's a negative number.</item>
             </list>
            <para>The elements described above are in the same order as the
            order of each bit of each element, that is, either most significant
            first or least significant first.</para>
            </summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.NaN">
            <summary>A not-a-number value.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.NegativeInfinity">
            <summary>Negative infinity, less than any other number.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.NegativeZero">
            <summary>Represents the number negative zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.One">
            <summary>Represents the number 1.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.PositiveInfinity">
            <summary>Positive infinity, greater than any other
            number.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.SignalingNaN">
            <summary>A not-a-number value that signals an invalid operation
            flag when it's passed as an argument to any arithmetic operation in
            arbitrary-precision decimal.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.Ten">
            <summary>Represents the number 10.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.Zero">
            <summary>Represents the number 0.</summary>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Copy">
            <summary>Creates a copy of this arbitrary-precision binary
            number.</summary>
            <returns>An arbitrary-precision decimal floating-point
            number.</returns>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.Exponent">
            <summary>Gets this object's exponent. This object's value will be
            an integer if the exponent is positive or zero.</summary>
            <value>This object's exponent. This object's value will be an
            integer if the exponent is positive or zero.</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.IsFinite">
            <summary>Gets a value indicating whether this object is finite (not
            infinity or NaN).</summary>
            <value><c>true</c> if this object is finite (not infinity or NaN);
            otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.IsNegative">
            <summary>Gets a value indicating whether this object is negative,
            including negative zero.</summary>
            <value><c>true</c> if this object is negative, including negative
            zero; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.IsZero">
            <summary>Gets a value indicating whether this object's value equals
            0.</summary>
            <value><c>true</c> if this object's value equals 0; otherwise,
            <c>false</c>. <c>true</c> if this object's value equals 0;
            otherwise, <c>false</c>.</value>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsInteger">
            <summary>Returns whether this object's value is an
            integer.</summary>
            <returns><c>true</c> if this object's value is an integer;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.Mantissa">
            <summary>Gets this object's unscaled value, or significand, and
            makes it negative if this object is negative. If this value is
            not-a-number (NaN), that value's absolute value is the NaN's
            "payload" (diagnostic information).</summary>
            <value>This object's unscaled value. Will be negative if this
            object's value is negative (including a negative NaN).</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.Sign">
            <summary>Gets this value's sign: -1 if negative; 1 if positive; 0
            if zero.</summary>
            <value>This value's sign: -1 if negative; 1 if positive; 0 if
            zero.</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.UnsignedMantissa">
            <summary>Gets the absolute value of this object's unscaled value,
            or significand. If this value is not-a-number (NaN), that value is
            the NaN's "payload" (diagnostic information).</summary>
            <value>The absolute value of this object's unscaled value.</value>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Create(System.Int32,System.Int32)">
            <summary>Returns a number with the value
            <c>exponent*10^significand</c>.</summary>
            <param name='mantissaSmall'>Desired value for the
            significand.</param>
            <param name='exponentSmall'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Create(PeterO.Numbers.EInteger,System.Int32)">
            <summary>Creates a number with the value
            <c>exponent*10^significand</c>.</summary>
            <param name='mantissa'>Desired value for the significand.</param>
            <param name='exponentSmall'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='mantissa'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Create(PeterO.Numbers.EInteger,System.Int64)">
            <summary>Creates a number with the value
            <c>exponent*10^significand</c>.</summary>
            <param name='mantissa'>Desired value for the significand.</param>
            <param name='exponentLong'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='mantissa'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Creates a number with the value
            <c>exponent*10^significand</c>.</summary>
            <param name='mantissa'>Desired value for the significand.</param>
            <param name='exponent'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='mantissa'/> or <paramref name='exponent'/> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Create(System.Int64,System.Int32)">
            <summary>Creates a number with the value
            <c>exponent*10^significand</c>.</summary>
            <param name='mantissaLong'>Desired value for the
            significand.</param>
            <param name='exponentSmall'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Create(System.Int64,System.Int64)">
            <summary>Creates a number with the value
            <c>exponent*10^significand</c>.</summary>
            <param name='mantissaLong'>Desired value for the
            significand.</param>
            <param name='exponentLong'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CreateNaN(PeterO.Numbers.EInteger)">
            <summary>Creates a not-a-number arbitrary-precision decimal
            number.</summary>
            <param name='diag'>An integer, 0 or greater, to use as diagnostic
            information associated with this object. If none is needed, should
            be zero. To get the diagnostic information from another
            arbitrary-precision decimal floating-point number, use that
            object's <c>UnsignedMantissa</c> property.</param>
            <returns>A quiet not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean,PeterO.Numbers.EContext)">
            <summary>Creates a not-a-number arbitrary-precision decimal
            number.</summary>
            <param name='diag'>An integer, 0 or greater, to use as diagnostic
            information associated with this object. If none is needed, should
            be zero. To get the diagnostic information from another
            arbitrary-precision decimal floating-point number, use that
            object's <c>UnsignedMantissa</c> property.</param>
            <param name='signaling'>Whether the return value will be signaling
            (true) or quiet (false).</param>
            <param name='negative'>Whether the return value is
            negative.</param>
            <param name='ctx'>An arithmetic context to control the precision
            (in decimal digits) of the diagnostic information. The rounding and
            exponent range of this context will be ignored. Can be null. The
            only flag that can be signaled in this context is FlagInvalid,
            which happens if diagnostic information needs to be truncated and
            too much memory is required to do so.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='diag'/> is null or is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromDouble(System.Double)">
            <summary>Creates an arbitrary-precision decimal number from a
            64-bit binary floating-point number. This method computes the exact
            value of the floating point number, not an approximation, as is
            often the case by converting the floating point number to a string
            first. Remember, though, that the exact value of a 64-bit binary
            floating-point number is not always the value that results when
            passing a literal decimal number (for example, calling
            <c>EDecimal.FromDouble(0.1)</c> ), since not all decimal numbers
            can be converted to exact binary numbers (in the example given, the
            resulting arbitrary-precision decimal will be the value of the
            closest "double" to 0.1, not 0.1 exactly). To create an
            arbitrary-precision decimal number from a decimal value, use
            FromString instead in most cases (for example:
            <c>EDecimal.FromString("0.1")</c> ).</summary>
            <param name='dbl'>The parameter <paramref name='dbl'/> is a 64-bit
            floating-point number.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as <paramref name='dbl'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromDoubleBits(System.Int64)">
            <summary>Creates an arbitrary-precision decimal number from a
            64-bit binary floating-point number, encoded in the IEEE 754
            binary64 format. This method computes the exact value of the
            floating point number, not an approximation, as is often the case
            by converting the floating point number to a string first.
            Remember, though, that the exact value of a 64-bit binary
            floating-point number is not always the value that results when
            passing a literal decimal number, since not all decimal numbers can
            be converted to exact binary numbers (in the example given, the
            resulting arbitrary-precision decimal will be the value of the
            closest "double" to 0.1, not 0.1 exactly). To create an
            arbitrary-precision decimal number from a decimal value, use
            FromString instead in most cases.</summary>
            <param name='dblBits'>The parameter <paramref name='dblBits'/> is a
            64-bit signed integer.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as <paramref name='dblBits'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromEInteger(PeterO.Numbers.EInteger)">
            <summary>Converts an arbitrary-precision integer to an arbitrary
            precision decimal.</summary>
            <param name='bigint'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision decimal number with the exponent
            set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromExtendedFloat(PeterO.Numbers.EFloat)">
            <summary>Converts an arbitrary-precision binary floating-point
            number to an arbitrary precision decimal.</summary>
            <param name='ef'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromEFloat(PeterO.Numbers.EFloat)">
            <summary>Creates an arbitrary-precision decimal number from an
            arbitrary-precision binary floating-point number.</summary>
            <param name='bigfloat'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigfloat'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromBoolean(System.Boolean)">
            <summary>Converts a boolean value (true or false) to an
            arbitrary-precision decimal number.</summary>
            <param name='boolValue'>Either true or false.</param>
            <returns>The number 1 if <paramref name='boolValue'/> is true;
            otherwise, 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromInt32(System.Int32)">
            <summary>Creates an arbitrary-precision decimal number from a
            32-bit signed integer.</summary>
            <param name='valueSmaller'>The parameter <paramref
            name='valueSmaller'/> is a 32-bit signed integer.</param>
            <returns>An arbitrary-precision decimal number with the exponent
            set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromInt64AsUnsigned(System.Int64)">
            <summary>Converts an unsigned integer expressed as a 64-bit signed
            integer to an arbitrary-precision decimal number.</summary>
            <param name='longerValue'>A 64-bit signed integer. If this value is
            0 or greater, the return value will represent it. If this value is
            less than 0, the return value will store 2^64 plus this value
            instead.</param>
            <returns>An arbitrary-precision decimal number with the exponent
            set to 0. If <paramref name='longerValue'/> is 0 or greater, the
            return value will represent it. If <paramref name='longerValue'/>
            is less than 0, the return value will store 2^64 plus this value
            instead.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromInt64(System.Int64)">
            <summary>Creates an arbitrary-precision decimal number from a
            64-bit signed integer.</summary>
            <param name='valueSmall'>The parameter <paramref
            name='valueSmall'/> is a 64-bit signed integer.</param>
            <returns>This number's value as an arbitrary-precision decimal
            number with the exponent set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromSingle(System.Single)">
            <summary>Creates an arbitrary-precision decimal number from a
            32-bit binary floating-point number. This method computes the exact
            value of the floating point number, not an approximation, as is
            often the case by converting the floating point number to a string
            first. Remember, though, that the exact value of a 32-bit binary
            floating-point number is not always the value that results when
            passing a literal decimal number (for example, calling
            <c>EDecimal.FromSingle(0.1f)</c> ), since not all decimal numbers
            can be converted to exact binary numbers (in the example given, the
            resulting arbitrary-precision decimal will be the the value of the
            closest "float" to 0.1, not 0.1 exactly). To create an
            arbitrary-precision decimal number from a decimal value, use
            FromString instead in most cases (for example:
            <c>EDecimal.FromString("0.1")</c> ).</summary>
            <param name='flt'>The parameter <paramref name='flt'/> is a 32-bit
            binary floating-point number.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as <paramref name='flt'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromSingleBits(System.Int32)">
            <summary>Creates an arbitrary-precision decimal number from a
            32-bit binary floating-point number encoded in the IEEE 754
            binary32 format. This method computes the exact value of the
            floating point number, not an approximation, as is often the case
            by converting the floating point number to a string first.
            Remember, though, that the exact value of a 32-bit binary
            floating-point number is not always the value that results when
            passing a literal decimal number, since not all decimal numbers can
            be converted to exact binary numbers (in the example given, the
            resulting arbitrary-precision decimal will be the the value of the
            closest "float" to 0.1, not 0.1 exactly). To create an
            arbitrary-precision decimal number from a decimal value, use
            FromString instead in most cases.</summary>
            <param name='value'>A 32-bit binary floating-point number encoded
            in the IEEE 754 binary32 format.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as <paramref name='value'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.Char[])">
            <summary>Creates an arbitrary-precision decimal number from a
            sequence of <c>char</c> s that represents a number. See
            <c>FromString(String, int, int, EContext)</c> for more information.
            Note that calling the overload that takes an EContext is often much
            faster than creating the EDecimal then calling
            <c>RoundToPrecision</c> on that EDecimal, especially if the context
            specifies a precision limit and exponent range.</summary>
            <param name='chars'>A sequence that represents a number.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given sequence of <c>char</c> s.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='chars'/> is not a correctly formatted number
            sequence.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.Char[],PeterO.Numbers.EContext)">
            <summary>Creates an arbitrary-precision decimal number from a
            sequence of <c>char</c> s that represents a number. See
            <c>FromString(String, int, int, EContext)</c> for more
            information.</summary>
            <param name='chars'>A sequence of <c>char</c> s that represents a
            number.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. Note that providing a context is often much faster
            than creating the EDecimal without a context then calling
            <c>RoundToPrecision</c> on that EDecimal, especially if the context
            specifies a precision limit and exponent range.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given sequence of <c>char</c> s.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='chars'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.Char[],System.Int32,System.Int32)">
            <summary>Creates an arbitrary-precision decimal number from a
            sequence of <c>char</c> s that represents a number. See
            <c>FromString(String, int, int, EContext)</c> for more information.
            Note that calling the overload that takes an EContext is often much
            faster than creating the EDecimal then calling
            <c>RoundToPrecision</c> on that EDecimal, especially if the context
            specifies a precision limit and exponent range.</summary>
            <param name='chars'>A sequence that represents a number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='chars'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='chars'/> (but not more than <paramref
            name='chars'/> 's length).</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given sequence of <c>char</c> s.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='chars'/> is not a correctly formatted number
            sequence.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='chars'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='chars'/> 's length, or <paramref
            name='chars'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.Char[],System.Int32,System.Int32,PeterO.Numbers.EContext)">
            <summary>
            <para>Creates an arbitrary-precision decimal number from a sequence
            of <c>char</c> s that represents a number.</para>
            <para>The format of the sequence generally consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if the minus sign, the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            (".", U+002E) before or after those digits or between two of them.
            These digits may begin with any number of zeros.</item>
            <item>Optionally, "E"/"e" followed by an optional (positive
            exponent) or "-" (negative exponent) and followed by one or more
            digits specifying the exponent (these digits may begin with any
            number of zeros).</item></list>
            <para>The sequence can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN" /"-NaN") followed by any number of digits
            (these digits may begin with any number of zeros), or signaling NaN
            ("sNaN" /"-sNaN") followed by any number of digits (these digits
            may begin with any number of zeros), all where the letters can be
            any combination of basic upper-case and/or basic lower-case
            letters.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The sequence is not
            allowed to contain white space characters, including
            spaces.</para></summary>
            <param name='chars'>A sequence of <c>char</c> s, a portion of which
            represents a number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='chars'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='chars'/> (but not more than <paramref
            name='chars'/> 's length).</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. Note that providing a context is often much faster
            than creating the EDecimal without a context then calling
            <c>RoundToPrecision</c> on that EDecimal, especially if the context
            specifies a precision limit and exponent range.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given sequence of <c>char</c> s.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='chars'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='chars'/> 's length, or <paramref
            name='chars'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.Byte[])">
            <summary>Creates an arbitrary-precision decimal number from a
            sequence of bytes (interpreted as text) that represents a number.
            See <c>FromString(String, int, int, EContext)</c> for more
            information. Note that calling the overload that takes an EContext
            is often much faster than creating the EDecimal then calling
            <c>RoundToPrecision</c> on that EDecimal, especially if the context
            specifies a precision limit and exponent range.</summary>
            <param name='bytes'>A sequence that represents a number.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given sequence of bytes (interpreted as text).</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='bytes'/> is not a correctly formatted number
            sequence.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.Byte[],PeterO.Numbers.EContext)">
            <summary>Creates an arbitrary-precision decimal number from a
            sequence of bytes (interpreted as text) that represents a number.
            See <c>FromString(String, int, int, EContext)</c> for more
            information.</summary>
            <param name='bytes'>A sequence of bytes (interpreted as text) that
            represents a number.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. Note that providing a context is often much faster
            than creating the EDecimal without a context then calling
            <c>RoundToPrecision</c> on that EDecimal, especially if the context
            specifies a precision limit and exponent range.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given sequence of bytes (interpreted as text).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.Byte[],System.Int32,System.Int32)">
            <summary>Creates an arbitrary-precision decimal number from a
            sequence of bytes (interpreted as text) that represents a number.
            See <c>FromString(String, int, int, EContext)</c> for more
            information. Note that calling the overload that takes an EContext
            is often much faster than creating the EDecimal then calling
            <c>RoundToPrecision</c> on that EDecimal, especially if the context
            specifies a precision limit and exponent range.</summary>
            <param name='bytes'>A sequence that represents a number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='bytes'/> begins.</param>
            <param name='length'>The length, in bytes, of the desired portion
            of <paramref name='bytes'/> (but not more than <paramref
            name='bytes'/> 's length).</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given sequence of bytes (interpreted as text).</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='bytes'/> is not a correctly formatted number
            sequence.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='bytes'/> 's length, or <paramref
            name='bytes'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.Byte[],System.Int32,System.Int32,PeterO.Numbers.EContext)">
            <summary>
            <para>Creates an arbitrary-precision decimal number from a sequence
            of bytes (interpreted as text) that represents a number. Each byte
            in the sequence has to be a code point in the Basic Latin range
            (0x00 to 0x7f or U+0000 to U+007F) of the Unicode Standard.</para>
            <para>The format of the sequence generally consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if the minus sign, the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            (".", U+002E) before or after those digits or between two of them.
            These digits may begin with any number of zeros.</item>
            <item>Optionally, "E"/"e" followed by an optional (positive
            exponent) or "-" (negative exponent) and followed by one or more
            digits specifying the exponent (these digits may begin with any
            number of zeros).</item></list>
            <para>The sequence can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN" /"-NaN") followed by any number of digits
            (these digits may begin with any number of zeros), or signaling NaN
            ("sNaN" /"-sNaN") followed by any number of digits (these digits
            may begin with any number of zeros), all where the letters can be
            any combination of basic upper-case and/or basic lower-case
            letters.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The sequence is not
            allowed to contain white space characters, including
            spaces.</para></summary>
            <param name='bytes'>A sequence of bytes (interpreted as text), a
            portion of which represents a number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='bytes'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='bytes'/> (but not more than <paramref
            name='bytes'/> 's length).</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. Note that providing a context is often much faster
            than creating the EDecimal without a context then calling
            <c>RoundToPrecision</c> on that EDecimal, especially if the context
            specifies a precision limit and exponent range.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given sequence of bytes (interpreted as text).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='bytes'/> 's length, or <paramref
            name='bytes'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.String)">
            <summary>Creates an arbitrary-precision decimal number from a text
            string that represents a number. See <c>FromString(String, int,
            int, EContext)</c> for more information. Note that calling the
            overload that takes an EContext is often much faster than creating
            the EDecimal then calling <c>RoundToPrecision</c> on that EDecimal,
            especially if the context specifies a precision limit and exponent
            range.</summary>
            <param name='str'>A string that represents a number.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='str'/> is not a correctly formatted number
            string.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.String,PeterO.Numbers.EContext)">
            <summary>Creates an arbitrary-precision decimal number from a text
            string that represents a number. See <c>FromString(String, int,
            int, EContext)</c> for more information.</summary>
            <param name='str'>A string that represents a number.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. Note that providing a context is often much faster
            than creating the EDecimal without a context then calling
            <c>RoundToPrecision</c> on that EDecimal, especially if the context
            specifies a precision limit and exponent range.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.String,System.Int32,System.Int32)">
            <summary>Creates an arbitrary-precision decimal number from a text
            string that represents a number. See <c>FromString(String, int,
            int, EContext)</c> for more information. Note that calling the
            overload that takes an EContext is often much faster than creating
            the EDecimal then calling <c>RoundToPrecision</c> on that EDecimal,
            especially if the context specifies a precision limit and exponent
            range.</summary>
            <param name='str'>A string that represents a number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref
            name='str'/> 's length).</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='str'/> is not a correctly formatted number
            string.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref
            name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.String,System.Int32,System.Int32,PeterO.Numbers.EContext)">
            <summary>
            <para>Creates an arbitrary-precision decimal number from a text
            string that represents a number.</para>
            <para>The format of the string generally consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if the minus sign, the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            (".", U+002E) before or after those digits or between two of them.
            These digits may begin with any number of zeros.</item>
            <item>Optionally, "E"/"e" followed by an optional (positive
            exponent) or "-" (negative exponent) and followed by one or more
            digits specifying the exponent (these digits may begin with any
            number of zeros).</item></list>
            <para>The string can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN" /"-NaN") followed by any number of digits
            (these digits may begin with any number of zeros), or signaling NaN
            ("sNaN" /"-sNaN") followed by any number of digits (these digits
            may begin with any number of zeros), all where the letters can be
            any combination of basic upper-case and/or basic lower-case
            letters.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The string is not
            allowed to contain white space characters, including
            spaces.</para></summary>
            <param name='str'>A text string, a portion of which represents a
            number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref
            name='str'/> 's length).</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. Note that providing a context is often much faster
            than creating the EDecimal without a context then calling
            <c>RoundToPrecision</c> on that EDecimal, especially if the context
            specifies a precision limit and exponent range.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref
            name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Max(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Gets the greater value between two decimal
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>The larger value of the two numbers. If one is positive
            zero and the other is negative zero, returns the positive zero. If
            the two numbers are positive and have the same value, returns the
            one with the larger exponent. If the two numbers are negative and
            have the same value, returns the one with the smaller
            exponent.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Max(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Gets the greater value between two decimal
            numbers.</summary>
            <param name='first'>An arbitrary-precision decimal number.</param>
            <param name='second'>Another arbitrary-precision decimal
            number.</param>
            <returns>The larger value of the two numbers. If one is positive
            zero and the other is negative zero, returns the positive zero. If
            the two numbers are positive and have the same value, returns the
            one with the larger exponent. If the two numbers are negative and
            have the same value, returns the one with the smaller
            exponent.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MaxMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>The larger value of the two numbers, ignoring their
            signs.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MaxMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The larger value of the two numbers, ignoring their
            signs.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Min(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Gets the lesser value between two decimal
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>The smaller value of the two numbers. If one is positive
            zero and the other is negative zero, returns the negative zero. If
            the two numbers are positive and have the same value, returns the
            one with the smaller exponent. If the two numbers are negative and
            have the same value, returns the one with the larger
            exponent.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Min(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Gets the lesser value between two decimal
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The smaller value of the two numbers. If one is positive
            zero and the other is negative zero, returns the negative zero. If
            the two numbers are positive and have the same value, returns the
            one with the smaller exponent. If the two numbers are negative and
            have the same value, returns the one with the larger
            exponent.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MinMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>The smaller value of the two numbers, ignoring their
            signs.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MinMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The smaller value of the two numbers, ignoring their
            signs.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.PI(PeterO.Numbers.EContext)">
            <summary>Finds the constant , the circumference of a circle
            divided by its diameter.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as  can never be represented
            exactly.</i>.</param>
            <returns>The constant  rounded to the given precision. Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Abs">
            <summary>Finds the absolute value of this object (if it's negative,
            it becomes positive).</summary>
            <returns>An arbitrary-precision decimal number. Returns signaling
            NaN if this value is signaling NaN. (In this sense, this method is
            similar to the "copy-abs" operation in the General Decimal
            Arithmetic Specification, except this method does not necessarily
            return a copy of this object.).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CopySign(PeterO.Numbers.EDecimal)">
            <summary>Returns a number with the same value as this one, but
            copying the sign (positive or negative) of another number. (This
            method is similar to the "copy-sign" operation in the General
            Decimal Arithmetic Specification, except this method does not
            necessarily return a copy of this object.).</summary>
            <param name='other'>A number whose sign will be copied.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='other'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Abs(PeterO.Numbers.EContext)">
            <summary>Finds the absolute value of this object (if it's negative,
            it becomes positive).</summary>
            <param name='context'>An arithmetic context to control the
            precision, rounding, and exponent range of the result. If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the precision is
            unlimited and no rounding is needed.</param>
            <returns>The absolute value of this object. Signals FlagInvalid and
            returns quiet NaN if this value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Add(PeterO.Numbers.EDecimal)">
            <summary>Adds this arbitrary-precision decimal floating-point
            number and another arbitrary-precision decimal floating-point
            number and returns the result. The exponent for the result is the
            lower of this arbitrary-precision decimal floating-point number's
            exponent and the other arbitrary-precision decimal floating-point
            number's exponent.</summary>
            <param name='otherValue'>An arbitrary-precision decimal
            number.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision decimal floating-point number plus another
            arbitrary-precision decimal floating-point number. If this
            arbitrary-precision decimal floating-point number is not-a-number
            (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Add(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Adds this arbitrary-precision decimal floating-point
            number and another arbitrary-precision decimal floating-point
            number and returns the result.</summary>
            <param name='otherValue'>The number to add to.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision decimal floating-point number plus another
            arbitrary-precision decimal floating-point number. If this
            arbitrary-precision decimal floating-point number is not-a-number
            (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareTo(PeterO.Numbers.EDecimal)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values. This method currently uses
            the rules given in the CompareToValue method, so that it it is not
            consistent with the Equals method, but it may change in a future
            version to use the rules for the CompareToTotal method
            instead.</summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value or if <paramref name='other'/> is null, or 0 if both
            values are equal.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareTo(System.Int32)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values. This method currently uses
            the rules given in the CompareToValue method, so that it it is not
            consistent with the Equals method, but it may change in a future
            version to use the rules for the CompareToTotal method
            instead.</summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 32-bit signed integer.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value, or 0 if both values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToValue(System.Int32)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object is a quiet NaN or signaling NaN, this method
            will not trigger an error. Instead, NaN will compare greater than
            any other number, including infinity.</para></summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 32-bit signed integer.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value, or 0 if both values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareTo(System.Int64)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values. This method currently uses
            the rules given in the CompareToValue method, so that it it is not
            consistent with the Equals method, but it may change in a future
            version to use the rules for the CompareToTotal method
            instead.</summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 64-bit signed integer.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value, or 0 if both values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToValue(System.Int64)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object is a quiet NaN or signaling NaN, this method
            will not trigger an error. Instead, NaN will compare greater than
            any other number, including infinity.</para></summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 64-bit signed integer.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value, or 0 if both values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToValue(PeterO.Numbers.EDecimal)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will not trigger an error. Instead, NaN
            will compare greater than any other number, including infinity. Two
            different NaN values will be considered equal.</para></summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value or if <paramref name='other'/> is null, or 0 if both
            values are equal.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToBinary(PeterO.Numbers.EFloat)">
            <summary>Compares an arbitrary-precision binary floating-point
            number with this instance.</summary>
            <param name='other'>The other object to compare. Can be
            null.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less; or a positive number if this instance is greater.
            Returns 0 if both values are NaN (even signaling NaN) and 1 if this
            value is NaN (even signaling NaN) and the other isn't, or if the
            other value is null.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToSignal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Compares the mathematical values of this object and
            another object, treating quiet NaN as signaling.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will return a quiet NaN and will signal
            a FlagInvalid flag.</para></summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <param name='ctx'>An arithmetic context. The precision, rounding,
            and exponent range are ignored. If <c>HasFlags</c> of the context
            is true, will store the flags resulting from the operation (the
            flags are in addition to the pre-existing flags). Can be
            null.</param>
            <returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or a 1 if this object is greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToTotalMagnitude(PeterO.Numbers.EDecimal)">
            <summary>Compares the absolute values of this object and another
            object, imposing a total ordering on all possible values (ignoring
            their signs). In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero and positive zero are considered equal.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item></list></summary>
            <param name='other'>An arbitrary-precision decimal number to
            compare with this one.</param>
            <returns>The number 0 if both objects have the same value (ignoring
            their signs), or -1 if this object is less than the other value
            (ignoring their signs), or 1 if this object is greater (ignoring
            their signs).
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToTotal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary>
            <param name='other'>An arbitrary-precision decimal number to
            compare with this one.</param>
            <param name='ctx'>An arithmetic context. Flags will be set in this
            context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
            context are true and only if an operand needed to be rounded before
            carrying out the operation. Can be null.</param>
            <returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater. Does not signal flags if either value is signaling NaN.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToTotalMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values (ignoring their
            signs). In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary>
            <param name='other'>An arbitrary-precision decimal number to
            compare with this one.</param>
            <param name='ctx'>An arithmetic context. Flags will be set in this
            context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
            context are true and only if an operand needed to be rounded before
            carrying out the operation. Can be null.</param>
            <returns>The number 0 if both objects have the same value (ignoring
            their signs), or -1 if this object is less than the other value
            (ignoring their signs), or 1 if this object is greater (ignoring
            their signs). Does not signal flags if either value is signaling
            NaN.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToTotal(PeterO.Numbers.EDecimal)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary>
            <param name='other'>An arbitrary-precision decimal number to
            compare with this one.</param>
            <returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToWithContext(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Compares the mathematical values of this object and
            another object.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method returns a quiet NaN, and will signal a
            FlagInvalid flag if either is a signaling NaN.</para></summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <param name='ctx'>An arithmetic context. The precision, rounding,
            and exponent range are ignored. If <c>HasFlags</c> of the context
            is true, will store the flags resulting from the operation (the
            flags are in addition to the pre-existing flags). Can be
            null.</param>
            <returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Divide(PeterO.Numbers.EDecimal)">
            <summary>Divides this arbitrary-precision decimal floating-point
            number by another arbitrary-precision decimal floating-point number
            and returns the result; returns NaN instead if the result would
            have a nonterminating decimal expansion (including 1/3, 1/12, 1/7,
            2/3, and so on); if this is not desired, use DivideToExponent, or
            use the Divide overload that takes an EContext.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>The result of dividing this arbitrary-precision decimal
            floating-point number by another arbitrary-precision decimal
            floating-point number. Returns infinity if the divisor (this
            arbitrary-precision decimal floating-point number) is 0 and the
            dividend (the other arbitrary-precision decimal floating-point
            number) is nonzero. Returns not-a-number (NaN) if the divisor and
            the dividend are 0. Returns NaN if the result can't be exact
            because it would have a nonterminating binary expansion (examples
            include 1 divided by any multiple of 3, such as 1/3 or 1/12). If
            this is not desired, use DivideToExponent instead, or use the
            Divide overload that takes an <c>EContext</c> (such as
            <c>EContext.Decimal128</c> ) instead.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Divide(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Divides this arbitrary-precision decimal floating-point
            number by another arbitrary-precision decimal floating-point number
            and returns the result.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param>
            <returns>The result of dividing this arbitrary-precision decimal
            floating-point number by another arbitrary-precision decimal
            floating-point number. Signals FlagDivideByZero and returns
            infinity if the divisor (this arbitrary-precision decimal
            floating-point number) is 0 and the dividend (the other
            arbitrary-precision decimal floating-point number) is nonzero.
            Signals FlagInvalid and returns not-a-number (NaN) if the divisor
            and the dividend are 0; or, either <paramref name='ctx'/> is null
            or <paramref name='ctx'/> 's precision is 0, and the result would
            have a nonterminating decimal expansion (examples include 1 divided
            by any multiple of 3, such as 1/3 or 1/12); or, the rounding mode
            is ERounding.None and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideAndRemainderNaturalScale(PeterO.Numbers.EDecimal)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideAndRemainderNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the remainder to have a
            higher precision than given in this context. Flags will be set on
            the given context only if the context's <c>HasFlags</c> is true and
            the integer part of the division result doesn't fit the precision
            and exponent range without rounding. Can be null, in which the
            precision is unlimited and no additional rounding, other than the
            rounding down to an integer after division, is needed.</param>
            <returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivRemNaturalScale(PeterO.Numbers.EDecimal)">
            <summary>Divides this arbitrary-precision decimal floating-point
            number by another arbitrary-precision decimal floating-point number
            and returns a two-item array containing the result of the division
            and the remainder, in that order. The result of division is
            calculated as though by <c>DivideToIntegerNaturalScale</c>, and
            the remainder is calculated as though by
            <c>RemainderNaturalScale</c>.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>An array of two items: the first is the result of the
            division as an arbitrary-precision decimal floating-point number,
            and the second is the remainder as an arbitrary-precision decimal
            floating-point number. The result of division is the result of the
            method on the two operands, and the remainder is the result of the
            Remainder method on the two operands.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivRemNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Divides this arbitrary-precision decimal floating-point
            number by another arbitrary-precision decimal floating-point number
            and returns a two-item array containing the result of the division
            and the remainder, in that order. The result of division is
            calculated as though by <c>DivideToIntegerNaturalScale</c>, and
            the remainder is calculated as though by
            <c>RemainderNaturalScale</c>.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the remainder to have a
            higher precision than given in this context. Flags will be set on
            the given context only if the context's <c>HasFlags</c> is true and
            the integer part of the division result doesn't fit the precision
            and exponent range without rounding. Can be null, in which the
            precision is unlimited and no additional rounding, other than the
            rounding down to an integer after division, is needed.</param>
            <returns>An array of two items: the first is the result of the
            division as an arbitrary-precision decimal floating-point number,
            and the second is the remainder as an arbitrary-precision decimal
            floating-point number. The result of division is the result of the
            method on the two operands, and the remainder is the result of the
            Remainder method on the two operands.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64,PeterO.Numbers.EContext)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='desiredExponentSmall'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param>
            <param name='ctx'>An arithmetic context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is ERounding.None
            and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32,PeterO.Numbers.EContext)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent (expressed as a 32-bit signed integer) to the
            result, using the half-even rounding mode.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='desiredExponentInt'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param>
            <param name='ctx'>An arithmetic context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is ERounding.None
            and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64,PeterO.Numbers.ERounding)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='desiredExponentSmall'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32,PeterO.Numbers.ERounding)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent (expressed as a 32-bit signed integer) to the
            result, using the half-even rounding mode.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='desiredExponentInt'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='exponent'>The desired exponent. A negative number
            places the cutoff point to the right of the usual decimal point (so
            a negative number means the number of decimal places to round to).
            A positive number places the cutoff point to the left of the usual
            decimal point.</param>
            <param name='ctx'>An arithmetic context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is ERounding.None
            and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result, using the half-even rounding
            mode.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='exponent'>The desired exponent. A negative number
            places the cutoff point to the right of the usual decimal point (so
            a negative number means the number of decimal places to round to).
            A positive number places the cutoff point to the left of the usual
            decimal point.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent (expressed as a 64-bit signed integer) to the
            result, using the half-even rounding mode.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='desiredExponentSmall'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent (expressed as a 32-bit signed integer) to the
            result, using the half-even rounding mode.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='desiredExponentInt'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='desiredExponent'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Returns not-a-number (NaN) if the divisor and the dividend
            are 0. Returns NaN if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToIntegerNaturalScale(PeterO.Numbers.EDecimal)">
            <summary>Divides two arbitrary-precision decimal numbers, and
            returns the integer part of the result, rounded down, with the
            preferred exponent set to this value's exponent minus the divisor's
            exponent.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>The integer part of the quotient of the two objects.
            Signals FlagDivideByZero and returns infinity if the divisor is 0
            and the dividend is nonzero. Signals FlagInvalid and returns
            not-a-number (NaN) if the divisor and the dividend are 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToIntegerNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Divides this object by another object, and returns the
            integer part of the result (which is initially rounded down), with
            the preferred exponent set to this value's exponent minus the
            divisor's exponent.</summary>
            <param name='divisor'>The parameter <paramref name='divisor'/> is
            an arbitrary-precision decimal floating-point number.</param>
            <param name='ctx'>The parameter <paramref name='ctx'/> is an
            EContext object.</param>
            <returns>The integer part of the quotient of the two objects.
            Signals FlagInvalid and returns not-a-number (NaN) if the return
            value would overflow the exponent range. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToIntegerZeroScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Divides this object by another object, and returns the
            integer part of the result, with the exponent set to 0.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored. If <c>HasFlags</c> of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited.</param>
            <returns>The integer part of the quotient of the two objects. The
            exponent will be set to 0. Signals FlagDivideByZero and returns
            infinity if the divisor is 0 and the dividend is nonzero. Signals
            FlagInvalid and returns not-a-number (NaN) if the divisor and the
            dividend are 0, or if the result doesn't fit the given
            precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToSameExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.ERounding)">
            <summary>Divides this object by another decimal number and returns
            a result with the same exponent as this object (the
            dividend).</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two numbers. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Equals(PeterO.Numbers.EDecimal)">
            <summary>Determines whether this object's significand, exponent,
            and properties are equal to those of another object. Not-a-number
            values are considered equal if the rest of their properties are
            equal.</summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <returns><c>true</c> if this object's significand and exponent are
            equal to those of another object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Equals(System.Object)">
            <summary>Determines whether this object's significand, exponent,
            and properties are equal to those of another object and that other
            object is an arbitrary-precision decimal number. Not-a-number
            values are considered equal if the rest of their properties are
            equal.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if the objects are equal; otherwise,
            <c>false</c>. In this method, two objects are not equal if they
            don't have the same type or if one is null and the other
            isn't.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Exp(PeterO.Numbers.EContext)">
            <summary>Finds e (the base of natural logarithms) raised to the
            power of this object's value.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the exponential function's
            results are generally not exact.</i> (Unlike in the General Decimal
            Arithmetic Specification, any rounding mode is allowed.).</param>
            <returns>Exponential of this object. If this object's value is 1,
            returns an approximation to " e" within the given precision.
            Signals FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ExpM1(PeterO.Numbers.EContext)">
            <summary>Finds e (the base of natural logarithms) raised to the
            power of this object's value, and subtracts the result by 1 and
            returns the final result, in a way that avoids loss of precision if
            the true result is very close to 0.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the exponential function's
            results are generally not exact.</i> (Unlike in the General Binary
            Arithmetic Specification, any rounding mode is allowed.).</param>
            <returns>Exponential of this object, minus 1. Signals FlagInvalid
            and returns not-a-number (NaN) if the parameter <paramref
            name='ctx'/> is null or the precision is unlimited (the context's
            Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.GetHashCode">
            <summary>Calculates this object's hash code. No application or
            process IDs are used in the hash code calculation.</summary>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsInfinity">
            <summary>Gets a value indicating whether this object is positive or
            negative infinity.</summary>
            <returns><c>true</c> if this object is positive or negative
            infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsNaN">
            <summary>Gets a value indicating whether this object is not a
            number (NaN).</summary>
            <returns><c>true</c> if this object is not a number (NaN);
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsNegativeInfinity">
            <summary>Returns whether this object is negative
            infinity.</summary>
            <returns><c>true</c> if this object is negative infinity;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsPositiveInfinity">
            <summary>Returns whether this object is positive
            infinity.</summary>
            <returns><c>true</c> if this object is positive infinity;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsQuietNaN">
            <summary>Gets a value indicating whether this object is a quiet
            not-a-number value.</summary>
            <returns><c>true</c> if this object is a quiet not-a-number value;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsSignalingNaN">
            <summary>Gets a value indicating whether this object is a signaling
            not-a-number value.</summary>
            <returns><c>true</c> if this object is a signaling not-a-number
            value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Log(PeterO.Numbers.EContext)">
            <summary>Finds the natural logarithm of this object, that is, the
            power (exponent) that e (the base of natural logarithms) must be
            raised to in order to equal this object's value.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the ln function's results are
            generally not exact.</i> (Unlike in the General Decimal Arithmetic
            Specification, any rounding mode is allowed.).</param>
            <returns>Ln(this object). Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the result would be a complex
            number with a real part equal to Ln of this object's absolute value
            and an imaginary part equal to pi, but the return value is still
            NaN.). Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null or the precision is
            unlimited (the context's Precision property is 0). Signals no flags
            and returns negative infinity if this object's value is
            0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Log10(PeterO.Numbers.EContext)">
            <summary>Finds the base-10 logarithm of this object, that is, the
            power (exponent) that the number 10 must be raised to in order to
            equal this object's value.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the ln function's results are
            generally not exact.</i> (Unlike in the General Decimal Arithmetic
            Specification, any rounding mode is allowed.).</param>
            <returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and
            returns not-a-number (NaN) if this object is less than 0. Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Log1P(PeterO.Numbers.EContext)">
            <summary>Adds 1 to this object's value and finds the natural
            logarithm of the result, in a way that avoids loss of precision
            when this object's value is between 0 and 1.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the ln function's results are
            generally not exact.</i> (Unlike in the General Binary Arithmetic
            Specification, any rounding mode is allowed.).</param>
            <returns>Ln(1+(this object)). Signals the flag FlagInvalid and
            returns NaN if this object is less than -1 (the result would be a
            complex number with a real part equal to Ln of 1 plus this object's
            absolute value and an imaginary part equal to pi, but the return
            value is still NaN.). Signals FlagInvalid and returns not-a-number
            (NaN) if the parameter <paramref name='ctx'/> is null or the
            precision is unlimited (the context's Precision property is 0).
            Signals no flags and returns negative infinity if this object's
            value is 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.LogN(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Finds the base-N logarithm of this object, that is, the
            power (exponent) that the number N must be raised to in order to
            equal this object's value.</summary>
            <param name='baseValue'>The parameter <paramref name='baseValue'/>
            is a Numbers.EDecimal object.</param>
            <param name='ctx'>The parameter <paramref name='ctx'/> is a
            Numbers.EContext object.</param>
            <returns>Ln(this object)/Ln(baseValue). Signals the flag
            FlagInvalid and returns not-a-number (NaN) if this object is less
            than 0. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null or the precision is
            unlimited (the context's Precision property is 0).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='baseValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointLeft(System.Int32)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary>
            <param name='places'>The number of decimal places to move the
            decimal point to the left. If this number is negative, instead
            moves the decimal point to the right by this number's absolute
            value.</param>
            <returns>A number whose exponent is decreased by <paramref
            name='places'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointLeft(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary>
            <param name='places'>The number of decimal places to move the
            decimal point to the left. If this number is negative, instead
            moves the decimal point to the right by this number's absolute
            value.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>A number whose exponent is decreased by <paramref
            name='places'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointLeft(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary>
            <param name='bigPlaces'>The number of decimal places to move the
            decimal point to the left. If this number is negative, instead
            moves the decimal point to the right by this number's absolute
            value.</param>
            <returns>A number whose exponent is decreased by <paramref
            name='bigPlaces'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointLeft(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary>
            <param name='bigPlaces'>The number of decimal places to move the
            decimal point to the left. If this number is negative, instead
            moves the decimal point to the right by this number's absolute
            value.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>A number whose exponent is decreased by <paramref
            name='bigPlaces'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointRight(System.Int32)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary>
            <param name='places'>The number of decimal places to move the
            decimal point to the right. If this number is negative, instead
            moves the decimal point to the left by this number's absolute
            value.</param>
            <returns>A number whose exponent is increased by <paramref
            name='places'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointRight(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary>
            <param name='places'>The number of decimal places to move the
            decimal point to the right. If this number is negative, instead
            moves the decimal point to the left by this number's absolute
            value.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>A number whose exponent is increased by <paramref
            name='places'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointRight(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary>
            <param name='bigPlaces'>The number of decimal places to move the
            decimal point to the right. If this number is negative, instead
            moves the decimal point to the left by this number's absolute
            value.</param>
            <returns>A number whose exponent is increased by <paramref
            name='bigPlaces'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointRight(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary>
            <param name='bigPlaces'>The number of decimal places to move the
            decimal point to the right. If this number is negative, instead
            moves the decimal point to the left by this number's absolute
            value.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>A number whose exponent is increased by <paramref
            name='bigPlaces'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Multiply(PeterO.Numbers.EDecimal)">
            <summary>Multiplies this arbitrary-precision decimal floating-point
            number by another arbitrary-precision decimal floating-point number
            and returns the result. The exponent for the result is this
            arbitrary-precision decimal floating-point number's exponent plus
            the other arbitrary-precision decimal floating-point number's
            exponent.</summary>
            <param name='otherValue'>Another decimal number.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision decimal floating-point number times another
            arbitrary-precision decimal floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='otherValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Multiply(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Multiplies this arbitrary-precision decimal floating-point
            number by another arbitrary-precision decimal floating-point number
            and returns the result.</summary>
            <param name='op'>Another decimal number.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision decimal floating-point number times another
            arbitrary-precision decimal floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Add(System.Int64)">
            <summary>Adds this arbitrary-precision decimal floating-point
            number and a 64-bit signed integer and returns the result. The
            exponent for the result is the lower of this arbitrary-precision
            decimal floating-point number's exponent and the other 64-bit
            signed integer's exponent.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision decimal floating-point number plus a 64-bit
            signed integer. If this arbitrary-precision decimal floating-point
            number is not-a-number (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Subtract(System.Int64)">
            <summary>Subtracts a 64-bit signed integer from this
            arbitrary-precision decimal floating-point number and returns the
            result. The exponent for the result is the lower of this
            arbitrary-precision decimal floating-point number's exponent and
            the other 64-bit signed integer's exponent.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision decimal floating-point number minus a 64-bit
            signed integer. If this arbitrary-precision decimal floating-point
            number is not-a-number (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Multiply(System.Int64)">
            <summary>Multiplies this arbitrary-precision decimal floating-point
            number by a 64-bit signed integer and returns the result. The
            exponent for the result is this arbitrary-precision decimal
            floating-point number's exponent plus the other 64-bit signed
            integer's exponent.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision decimal floating-point number times a 64-bit
            signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Divide(System.Int64)">
            <summary>Divides this arbitrary-precision decimal floating-point
            number by a 64-bit signed integer and returns the result; returns
            NaN instead if the result would have a nonterminating decimal
            expansion (including 1/3, 1/12, 1/7, 2/3, and so on); if this is
            not desired, use DivideToExponent, or use the Divide overload that
            takes an EContext.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The result of dividing this arbitrary-precision decimal
            floating-point number by a 64-bit signed integer. Returns infinity
            if the divisor (this arbitrary-precision decimal floating-point
            number) is 0 and the dividend (the other 64-bit signed integer) is
            nonzero. Returns not-a-number (NaN) if the divisor and the dividend
            are 0. Returns NaN if the result can't be exact because it would
            have a nonterminating binary expansion (examples include 1 divided
            by any multiple of 3, such as 1/3 or 1/12). If this is not desired,
            use DivideToExponent instead, or use the Divide overload that takes
            an <c>EContext</c> (such as <c>EContext.Decimal128</c> )
            instead.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Add(System.Int32)">
            <summary>Adds this arbitrary-precision decimal floating-point
            number and a 32-bit signed integer and returns the result. The
            exponent for the result is the lower of this arbitrary-precision
            decimal floating-point number's exponent and the other 32-bit
            signed integer's exponent.</summary>
            <param name='intValue'>A 32-bit signed integer to add to this
            object.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision decimal floating-point number plus a 32-bit
            signed integer. If this arbitrary-precision decimal floating-point
            number is not-a-number (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Subtract(System.Int32)">
            <summary>Subtracts a 32-bit signed integer from this
            arbitrary-precision decimal floating-point number and returns the
            result. The exponent for the result is the lower of this
            arbitrary-precision decimal floating-point number's exponent and
            the other 32-bit signed integer's exponent.</summary>
            <param name='intValue'>A 32-bit signed integer to subtract from
            this object.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision decimal floating-point number minus a 32-bit
            signed integer. If this arbitrary-precision decimal floating-point
            number is not-a-number (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Multiply(System.Int32)">
            <summary>Multiplies this arbitrary-precision decimal floating-point
            number by a 32-bit signed integer and returns the result. The
            exponent for the result is this arbitrary-precision decimal
            floating-point number's exponent plus the other 32-bit signed
            integer's exponent.</summary>
            <param name='intValue'>A 32-bit signed integer to multiply this
            object by.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision decimal floating-point number times a 32-bit
            signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Divide(System.Int32)">
            <summary>Divides this arbitrary-precision decimal floating-point
            number by a 32-bit signed integer and returns the result; returns
            NaN instead if the result would have a nonterminating decimal
            expansion (including 1/3, 1/12, 1/7, 2/3, and so on); if this is
            not desired, use DivideToExponent, or use the Divide overload that
            takes an EContext.</summary>
            <param name='intValue'>A 32-bit signed integer, the divisor, to
            divide this object by.</param>
            <returns>The result of dividing this arbitrary-precision decimal
            floating-point number by a 32-bit signed integer. Returns infinity
            if the divisor (this arbitrary-precision decimal floating-point
            number) is 0 and the dividend (the other 32-bit signed integer) is
            nonzero. Returns not-a-number (NaN) if the divisor and the dividend
            are 0. Returns NaN if the result can't be exact because it would
            have a nonterminating binary expansion (examples include 1 divided
            by any multiple of 3, such as 1/3 or 1/12). If this is not desired,
            use DivideToExponent instead, or use the Divide overload that takes
            an <c>EContext</c> (such as <c>EContext.Decimal128</c> )
            instead.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MultiplyAndAdd(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Multiplies by one decimal number, and then adds another
            decimal number.</summary>
            <param name='multiplicand'>The value to multiply.</param>
            <param name='augend'>The value to add.</param>
            <returns>An arbitrary-precision decimal floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MultiplyAndAdd(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Multiplies by one value, and then adds another
            value.</summary>
            <param name='op'>The value to multiply.</param>
            <param name='augend'>The value to add.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. If the precision doesn't indicate a simplified
            arithmetic, rounding and precision/exponent adjustment is done only
            once, namely, after multiplying and adding.</param>
            <returns>The result thisValue * multiplicand + augend.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MultiplyAndSubtract(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Multiplies by one value, and then subtracts another
            value.</summary>
            <param name='op'>The value to multiply.</param>
            <param name='subtrahend'>The value to subtract.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. If the precision doesn't indicate a simplified
            arithmetic, rounding and precision/exponent adjustment is done only
            once, namely, after multiplying and subtracting.</param>
            <returns>The result thisValue * multiplicand -
            subtrahend.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='op'/> or <paramref name='subtrahend'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Negate">
            <summary>Gets an object with the same value as this one, but with
            the sign reversed.</summary>
            <returns>An arbitrary-precision decimal number. If this value is
            positive zero, returns negative zero. Returns signaling NaN if this
            value is signaling NaN. (In this sense, this method is similar to
            the "copy-negate" operation in the General Decimal Arithmetic
            Specification, except this method does not necessarily return a
            copy of this object.).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Negate(PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but with the sign reversed.</summary>
            <param name='context'>An arithmetic context to control the
            precision, rounding, and exponent range of the result. If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the precision is
            unlimited and rounding isn't needed.</param>
            <returns>An arbitrary-precision decimal number. If this value is
            positive zero, returns positive zero. Signals FlagInvalid and
            returns quiet NaN if this value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.NextMinus(PeterO.Numbers.EContext)">
            <summary>Finds the largest value that's smaller than the given
            value.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param>
            <returns>Returns the largest value that's less than the given
            value. Returns negative infinity if the result is negative
            infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null, the precision is 0, or
            <paramref name='ctx'/> has an unlimited exponent range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.NextPlus(PeterO.Numbers.EContext)">
            <summary>Finds the smallest value that's greater than the given
            value.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param>
            <returns>Returns the smallest value that's greater than the given
            value.Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null, the precision is 0, or
            <paramref name='ctx'/> has an unlimited exponent range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.NextToward(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Finds the next value that is closer to the other object's
            value than this object's value. Returns a copy of this value with
            the same sign as the other value if both values are
            equal.</summary>
            <param name='otherValue'>An arbitrary-precision decimal number that
            the return value will approach.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param>
            <returns>Returns the next value that is closer to the other object'
            s value than this object's value. Signals FlagInvalid and returns
            NaN if the parameter <paramref name='ctx'/> is null, the precision
            is 0, or <paramref name='ctx'/> has an unlimited exponent
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Plus(PeterO.Numbers.EContext)">
            <summary>Rounds this object's value to a given precision, using the
            given rounding mode and range of exponent, and also converts
            negative zero to positive zero. The idiom
            <c>EDecimal.SignalingNaN.Plus(ctx)</c> is useful for triggering an
            invalid operation and returning not-a-number (NaN) for custom
            arithmetic operations.</summary>
            <param name='ctx'>A context for controlling the precision, rounding
            mode, and exponent range. Can be null, in which case the precision
            is unlimited and rounding isn't needed.</param>
            <returns>The closest value to this object's value, rounded to the
            specified precision. If <paramref name='ctx'/> is null or the
            precision and exponent range are unlimited, returns the same value
            as this object (or a quiet NaN if this object is a signaling
            NaN).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Pow(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Raises this object's value to the given
            exponent.</summary>
            <param name='exponent'>An arbitrary-precision decimal number
            expressing the exponent to raise this object's value to.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0; or if this value is
            less than 0 and the exponent either has a fractional part or is
            infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null or the precision is
            unlimited (the context's Precision property is 0), and the exponent
            has a fractional part.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Pow(PeterO.Numbers.EDecimal)">
            <summary>Raises this object's value to the given exponent, using
            unlimited precision.</summary>
            <param name='exponent'>An arbitrary-precision decimal number
            expressing the exponent to raise this object's value to.</param>
            <returns>This^exponent. Returns not-a-number (NaN) if the exponent
            has a fractional part.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Pow(System.Int32,PeterO.Numbers.EContext)">
            <summary>Raises this object's value to the given
            exponent.</summary>
            <param name='exponentSmall'>The exponent to raise this object's
            value to.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Pow(System.Int32)">
            <summary>Raises this object's value to the given
            exponent.</summary>
            <param name='exponentSmall'>The exponent to raise this object's
            value to.</param>
            <returns>This^exponent. Returns not-a-number (NaN) if this object
            and exponent are both 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Precision">
            <summary>Finds the number of digits in this number's significand.
            Returns 1 if this value is 0, and 0 if this value is infinity or
            not-a-number (NaN).</summary>
            <returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Quantize(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>
             Returns an arbitrary-precision decimal number with the
            same value but a new exponent.
            <para>Note that this is not always the same as rounding to a given
            number of decimal places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            decimal places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b>
             This method can be used to implement
            fixed-point decimal arithmetic, in which each decimal number has a
            fixed number of digits after the decimal point. The following code
            example returns a fixed-point number with up to 20 digits before
            and exactly 5 digits after the decimal point:</para>
            <code> &#x2f;&#x2a; After performing arithmetic operations, adjust
            &#x2f;&#x2a; the number to 5&#x2a;&#x2f;&#x2a;&#x2f;
            &#x2f;&#x2a;&#x2a;&#x2f;
            digits after the decimal point number = number.Quantize(
            EInteger.FromInt32(-5), &#x2f;&#x2a; five digits after the decimal
            point&#x2a;&#x2f;
            EContext.ForPrecision(25) &#x2f;&#x2a; 25-digit
            precision);&#x2a;&#x2f;</code>
            <para>A fixed-point decimal arithmetic in which no digits come
            after the decimal point (a desired exponent of 0) is considered an
            "integer arithmetic".</para>
            </summary>
            <param name='desiredExponent'>The desired exponent for the result.
            The exponent is the number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c>
             of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as this object but with the exponent changed. Signals FlagInvalid
            and returns not-a-number (NaN) if this object is infinity, if the
            rounded result can't fit the given precision, or if the context
            defines an exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Quantize(System.Int32,PeterO.Numbers.ERounding)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this one but a new exponent.
            <para><b>Remark:</b> This method can be used to implement
            fixed-point decimal arithmetic, in which a fixed number of digits
            come after the decimal point. A fixed-point decimal arithmetic in
            which no digits come after the decimal point (a desired exponent of
            0) is considered an "integer arithmetic" .</para></summary>
            <param name='desiredExponentInt'>The desired exponent for the
            result. The exponent is the number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='rounding'>A rounding mode to use in case the result
            needs to be rounded to fit the given exponent.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as this object but with the exponent changed. Returns not-a-number
            (NaN) if this object is infinity, or if the rounding mode is
            ERounding.None and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Quantize(System.Int32,PeterO.Numbers.EContext)">
            <summary>
             Returns an arbitrary-precision decimal number with the
            same value but a new exponent.
            <para>Note that this is not always the same as rounding to a given
            number of decimal places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            decimal places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b>
             This method can be used to implement
            fixed-point decimal arithmetic, in which each decimal number has a
            fixed number of digits after the decimal point. The following code
            example returns a fixed-point number with up to 20 digits before
            and exactly 5 digits after the decimal point:</para>
            <code>/* After performing arithmetic operations, adjust the number to 5
            digits
            after the decimal point */ number = number.Quantize(-5, /* five digits
            after the decimal point */EContext.ForPrecision(25) /* 25-digit
            precision*/);</code>
            <para>A fixed-point decimal arithmetic in which no digits come
            after the decimal point (a desired exponent of 0) is considered an
            "integer arithmetic".</para>
            </summary>
            <param name='desiredExponentInt'>The desired exponent for the
            result. The exponent is the number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c>
             of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as this object but with the exponent changed. Signals FlagInvalid
            and returns not-a-number (NaN) if this object is infinity, if the
            rounded result can't fit the given precision, or if the context
            defines an exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Quantize(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but with the same exponent as another
            decimal number.
            <para>Note that this is not always the same as rounding to a given
            number of decimal places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            decimal places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b> This method can be used to implement
            fixed-point decimal arithmetic, in which a fixed number of digits
            come after the decimal point. A fixed-point decimal arithmetic in
            which no digits come after the decimal point (a desired exponent of
            0) is considered an "integer arithmetic" .</para></summary>
            <param name='otherValue'>An arbitrary-precision decimal number
            containing the desired exponent of the result. The significand is
            ignored. The exponent is the number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousands-place (10^3, 1000). A value of 0 rounds the number to
            an integer. The following examples for this parameter express a
            desired exponent of 3: <c>10e3</c>, <c>8888e3</c>, <c>4.56e5</c>.</param>
            <param name='ctx'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as this object but with the exponent changed. Signals FlagInvalid
            and returns not-a-number (NaN) if the result can't fit the given
            precision without rounding, or if the arithmetic context defines an
            exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Reduce(PeterO.Numbers.EContext)">
            <summary>Returns an object with the same numerical value as this
            one but with trailing zeros removed from its significand. For
            example, 1.00 becomes 1.
            <para>If this object's value is 0, changes the exponent to
            0.</para></summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>This value with trailing zeros removed. Note that if the
            result has a very high exponent and the context says to clamp high
            exponents, there may still be some trailing zeros in the
            significand.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Remainder(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Returns the remainder that would result when this
            arbitrary-precision decimal floating-point number is divided by
            another arbitrary-precision decimal floating-point number. The
            remainder is the number that remains when the absolute value of
            this arbitrary-precision decimal floating-point number is divided
            (as though by DivideToIntegerZeroScale) by the absolute value of
            the other arbitrary-precision decimal floating-point number; the
            remainder has the same sign (positive or negative) as this
            arbitrary-precision decimal floating-point number.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result, and of the
            intermediate integer division. If <c>HasFlags</c> of the context is
            true, will also store the flags resulting from the operation (the
            flags are in addition to the pre-existing flags). Can be null, in
            which the precision is unlimited.</param>
            <returns>The remainder that would result when this
            arbitrary-precision decimal floating-point number is divided by
            another arbitrary-precision decimal floating-point number. Signals
            FlagDivideByZero and returns infinity if the divisor (this
            arbitrary-precision decimal floating-point number) is 0 and the
            dividend (the other arbitrary-precision decimal floating-point
            number) is nonzero. Signals FlagInvalid and returns not-a-number
            (NaN) if the divisor and the dividend are 0, or if the result of
            the division doesn't fit the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RemainderNoRoundAfterDivide(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Finds the remainder that results when dividing two
            arbitrary-precision decimal numbers, except the intermediate
            division is not adjusted to fit the precision of the given
            arithmetic context. The value of this object is divided by the
            absolute value of the other object; the remainder has the same sign
            (positive or negative) as this object's value.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result, but not also
            of the intermediate integer division. If <c>HasFlags</c> of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which the precision is unlimited.</param>
            <returns>The remainder of the two numbers. Signals FlagInvalid and
            returns not-a-number (NaN) if the divisor is 0, or if the result
            doesn't fit the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RemainderNaturalScale(PeterO.Numbers.EDecimal)">
            <summary>Calculates the remainder of a number by the formula
            <c>"this" - (("this" / "divisor") * "divisor")</c>.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RemainderNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Calculates the remainder of a number by the formula "this"
            - (("this" / "divisor") * "divisor").</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the return value to
            have a higher precision than given in this context. Flags will be
            set on the given context only if the context's <c>HasFlags</c> is
            true and the integer part of the division result doesn't fit the
            precision and exponent range without rounding. Can be null, in
            which the precision is unlimited and no additional rounding, other
            than the rounding down to an integer after division, is
            needed.</param>
            <returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RemainderNear(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Finds the distance to the closest multiple of the given
            divisor, based on the result of dividing this object's value by
            another object's value.
            <list type=''>
            <item>If this and the other object divide evenly, the result is
            0.</item>
            <item>If the remainder's absolute value is less than half of the
            divisor's absolute value, the result has the same sign as this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is more than half of the
            divisor's absolute value, the result has the opposite sign of this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is exactly half of the
            divisor's absolute value, the result has the opposite sign of this
            object if the quotient, rounded down, is odd, and has the same sign
            as this object if the quotient, rounded down, is even, and the
            result's absolute value is half of the divisor's absolute
            value.</item></list> This function is also known as the "IEEE
            Remainder" function.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored (the rounding mode is always treated as HalfEven). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which the precision is
            unlimited.</param>
            <returns>The distance of the closest multiple. Signals FlagInvalid
            and returns not-a-number (NaN) if the divisor is 0, or either the
            result of integer division (the quotient) or the remainder wouldn't
            fit the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to a new exponent if
            necessary. The resulting number's Exponent property will not
            necessarily be the given exponent; use the Quantize method instead
            to give the result a particular exponent.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest value representable in the given precision. If the result
            can't fit the precision, additional digits are discarded to make it
            fit. Signals FlagInvalid and returns not-a-number (NaN) if the
            arithmetic context defines an exponent range, the new exponent must
            be changed to the given exponent when rounding, and the given
            exponent is outside of the valid range of the arithmetic
            context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to a new exponent if
            necessary, using the HalfEven rounding mode. The resulting number's
            Exponent property will not necessarily be the given exponent; use
            the Quantize method instead to give the result a particular
            exponent.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest value representable for the given exponent.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to a new exponent if
            necessary, using the given rounding mode. The resulting number's
            Exponent property will not necessarily be the given exponent; use
            the Quantize method instead to give the result a particular
            exponent.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='rounding'>Desired mode for rounding this number's
            value.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest value representable for the given exponent.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to a new exponent if
            necessary, using the HalfEven rounding mode. The resulting number's
            Exponent property will not necessarily be the given exponent; use
            the Quantize method instead to give the result a particular
            exponent.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest value representable for the given exponent.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to a new exponent if
            necessary. The resulting number's Exponent property will not
            necessarily be the given exponent; use the Quantize method instead
            to give the result a particular exponent.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest value representable in the given precision. If the result
            can't fit the precision, additional digits are discarded to make it
            fit. Signals FlagInvalid and returns not-a-number (NaN) if the
            arithmetic context defines an exponent range, the new exponent must
            be changed to the given exponent when rounding, and the given
            exponent is outside of the valid range of the arithmetic
            context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32,PeterO.Numbers.ERounding)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to a new exponent if
            necessary. The resulting number's Exponent property will not
            necessarily be the given exponent; use the Quantize method instead
            to give the result a particular exponent.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='rounding'>The desired mode to use to round the given
            number to the given exponent.</param>
            <returns>An arbitrary-precision decimal number rounded to the given
            negative number of decimal places.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to the given exponent
            represented as an arbitrary-precision integer, and signals an
            inexact flag if the result would be inexact. The resulting number's
            Exponent property will not necessarily be the given exponent; use
            the Quantize method instead to give the result a particular
            exponent.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest value representable in the given precision. Signals
            FlagInvalid and returns not-a-number (NaN) if the result can't fit
            the given precision without rounding. Signals FlagInvalid and
            returns not-a-number (NaN) if the arithmetic context defines an
            exponent range, the new exponent must be changed to the given
            exponent when rounding, and the given exponent is outside of the
            valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to the given exponent
            represented as a 32-bit signed integer, and signals an inexact flag
            if the result would be inexact. The resulting number's Exponent
            property will not necessarily be the given exponent; use the
            Quantize method instead to give the result a particular
            exponent.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest value representable in the given precision. Signals
            FlagInvalid and returns not-a-number (NaN) if the result can't fit
            the given precision without rounding. Signals FlagInvalid and
            returns not-a-number (NaN) if the arithmetic context defines an
            exponent range, the new exponent must be changed to the given
            exponent when rounding, and the given exponent is outside of the
            valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(System.Int32,PeterO.Numbers.ERounding)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to the given exponent
            represented as a 32-bit signed integer, and signals an inexact flag
            if the result would be inexact. The resulting number's Exponent
            property will not necessarily be the given exponent; use the
            Quantize method instead to give the result a particular
            exponent.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='rounding'>Desired mode for rounding this object's
            value.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest value representable using the given exponent.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToIntegerExact(PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to an integer, and signals an
            inexact flag if the result would be inexact. The resulting number's
            Exponent property will not necessarily be 0; use the Quantize
            method instead to give the result an exponent of 0.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest integer representable in the given precision. Signals
            FlagInvalid and returns not-a-number (NaN) if the result can't fit
            the given precision without rounding. Signals FlagInvalid and
            returns not-a-number (NaN) if the arithmetic context defines an
            exponent range, the new exponent must be changed to 0 when
            rounding, and 0 is outside of the valid range of the arithmetic
            context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to an integer, without adding
            the <c>FlagInexact</c> or <c>FlagRounded</c> flags. The resulting
            number's Exponent property will not necessarily be 0; use the
            Quantize method instead to give the result an exponent of
            0.</summary>
            <param name='ctx'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags), except that this
            function will never add the <c>FlagRounded</c> and
            <c>FlagInexact</c> flags (the only difference between this and
            RoundToExponentExact). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest integer representable in the given precision. If the result
            can't fit the precision, additional digits are discarded to make it
            fit. Signals FlagInvalid and returns not-a-number (NaN) if the
            arithmetic context defines an exponent range, the new exponent must
            be changed to 0 when rounding, and 0 is outside of the valid range
            of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToIntegralExact(PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to an integer, and signals an
            inexact flag if the result would be inexact.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest integer representable in the given precision. Signals
            FlagInvalid and returns not-a-number (NaN) if the result can't fit
            the given precision without rounding. Signals FlagInvalid and
            returns not-a-number (NaN) if the arithmetic context defines an
            exponent range, the new exponent must be changed to 0 when
            rounding, and 0 is outside of the valid range of the arithmetic
            context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but rounded to an integer, without adding
            the <c>FlagInexact</c> or <c>FlagRounded</c> flags.</summary>
            <param name='ctx'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags), except that this
            function will never add the <c>FlagRounded</c> and
            <c>FlagInexact</c> flags (the only difference between this and
            RoundToExponentExact). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>An arbitrary-precision decimal number rounded to the
            closest integer representable in the given precision. If the result
            can't fit the precision, additional digits are discarded to make it
            fit. Signals FlagInvalid and returns not-a-number (NaN) if the
            arithmetic context defines an exponent range, the new exponent must
            be changed to 0 when rounding, and 0 is outside of the valid range
            of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToPrecision(PeterO.Numbers.EContext)">
            <summary>Rounds this object's value to a given precision, using the
            given rounding mode and range of exponent.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param>
            <returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name='ctx'/> is null or the precision and exponent range
            are unlimited.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.PreRound(PeterO.Numbers.EContext)">
            <summary>Returns a number in which the value of this object is
            rounded to fit the maximum precision allowed if it has more
            significant digits than the maximum precision. The maximum
            precision allowed is given in an arithmetic context. This method is
            designed for preparing operands to a custom arithmetic operation in
            accordance with the "simplified" arithmetic given in Appendix A of
            the General Decimal Arithmetic Specification.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited. Signals the
            flag LostDigits if the input number has greater precision than
            allowed and was rounded to a different numerical value in order to
            fit the precision.</param>
            <returns>This object rounded to the given precision. Returns this
            object and signals no flags if <paramref name='ctx'/> is null or
            specifies an unlimited precision, if this object is infinity or
            not-a-number (including signaling NaN), or if the number's value
            has no more significant digits than the maximum precision given in
            <paramref name='ctx'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(System.Int32)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='places'>The power of 10 to scale by.</param>
            <returns>A number whose exponent is increased by <paramref
            name='places'/>. For example, if <paramref name='places'/> is 5,
            "78E-2" becomes "78E+3" and has a bigger value.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='places'>The power of 10 to scale by.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param>
            <returns>A number whose exponent is generally increased by
            <paramref name='places'/>. For example, in general, if <paramref
            name='places'/> is 5, "78E-2" becomes "78E+3" and has a bigger
            value.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='bigPlaces'>The power of 10 to scale by.</param>
            <returns>A number whose exponent is increased by <paramref
            name='bigPlaces'/>. For example, if <paramref name='bigPlaces'/>
            is 5, "78E-2" becomes "78E+3" and has a bigger value.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with its scale
            adjusted.</summary>
            <param name='bigPlaces'>The power of 10 to scale by.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param>
            <returns>A number whose exponent is generally increased by
            <paramref name='bigPlaces'/>. For example, in general, if
            <paramref name='bigPlaces'/> is 5, "78E-2" becomes "78E+3" and has
            a bigger value.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigPlaces'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Sqrt(PeterO.Numbers.EContext)">
            <summary>Finds the square root of this object's value.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the square root function's
            results are generally not exact for many inputs.</i> (Unlike in the
            General Decimal Arithmetic Specification, any rounding mode is
            allowed.).</param>
            <returns>The square root. Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the square root would be a
            complex number, but the return value is still NaN). Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.SquareRoot(PeterO.Numbers.EContext)">
            <summary>Finds the square root of this object's value.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the square root function's
            results are generally not exact for many inputs.</i> (Unlike in the
            General Decimal Arithmetic Specification, any rounding mode is
            allowed.).</param>
            <returns>The square root. Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the square root would be a
            complex number, but the return value is still NaN). Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Subtract(PeterO.Numbers.EDecimal)">
            <summary>Subtracts an arbitrary-precision decimal floating-point
            number from this arbitrary-precision decimal floating-point number
            and returns the result. The exponent for the result is the lower of
            this arbitrary-precision decimal floating-point number's exponent
            and the other arbitrary-precision decimal floating-point number's
            exponent.</summary>
            <param name='otherValue'>The number to subtract from this
            instance's value.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision decimal floating-point number minus another
            arbitrary-precision decimal floating-point number. If this
            arbitrary-precision decimal floating-point number is not-a-number
            (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Subtract(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Subtracts an arbitrary-precision decimal floating-point
            number from this arbitrary-precision decimal floating-point number
            and returns the result.</summary>
            <param name='otherValue'>The number to subtract from this
            instance's value.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision decimal floating-point number minus another
            arbitrary-precision decimal floating-point number. If this
            arbitrary-precision decimal floating-point number is not-a-number
            (NaN), returns NaN.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='otherValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToDoubleBits">
            <summary>Converts this value to its closest equivalent as a 64-bit
            floating-point number encoded in the IEEE 754 binary64 format,
            using the half-even rounding mode.
            <para>If this value is a NaN, sets the high bit of the binary64
            value's significand area for a quiet NaN, and clears it for a
            signaling NaN. Then the other bits of the significand area are set
            to the lowest bits of this object's unsigned significand, and the
            next-highest bit of the significand area is set if those bits are
            all zeros and this is a signaling NaN.</para></summary>
            <returns>The closest 64-bit floating-point number to this value,
            encoded in the IEEE 754 binary64 format. The return value can be
            positive infinity or negative infinity, encoded in the IEEE 754
            binary64 format, if this value exceeds the range of a 64-bit
            floating point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToDouble">
            <summary>Converts this value to its closest equivalent as a 64-bit
            floating-point number, using the half-even rounding mode.
            <para>If this value is a NaN, sets the high bit of the 64-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN. Unfortunately, in the.NET implementation, the return value of
            this method may be a quiet NaN even if a signaling NaN would
            otherwise be generated.</para></summary>
            <returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEInteger">
            <summary>Converts this value to an arbitrary-precision integer,
            discarding the fractional part in this value. Note that depending
            on the value, especially the exponent, generating the
            arbitrary-precision integer may require a huge amount of memory.
            Use the ToSizedEInteger method to convert a number to an EInteger
            only if the integer fits in a bounded bit range; that method will
            throw an exception on overflow.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
            <exception cref='T:System.NotSupportedException'>There is not enough memory
            to store the value as an EInteger.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEIntegerExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the fractional part of the value would be lost.
            Note that depending on the value, especially the exponent,
            generating the arbitrary-precision integer may require a huge
            amount of memory. Use the ToSizedEIntegerIfExact method to convert
            a number to an EInteger only if the integer fits in a bounded bit
            range; that method will throw an exception on overflow.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
            <exception cref='T:System.ArithmeticException'>This object's value is not an
            exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEIntegerIfExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the fractional part of the value would be lost.
            Note that depending on the value, especially the exponent,
            generating the arbitrary-precision integer may require a huge
            amount of memory. Use the ToSizedEIntegerIfExact method to convert
            a number to an EInteger only if the integer fits in a bounded bit
            range; that method will throw an exception on overflow.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
            <exception cref='T:System.ArithmeticException'>This object's value is not an
            exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEngineeringString">
            <summary>Same as ToString(), except that when an exponent is used
            it will be a multiple of 3.</summary>
            <returns>A text string.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToExtendedFloat">
            <summary>Creates a binary floating-point number from this object's
            value. Note that if the binary floating-point number contains a
            negative exponent, the resulting value might not be exact, in which
            case the resulting binary floating-point number will be an
            approximation of this decimal number's value, using the half-even
            rounding mode.</summary>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEFloat">
            <summary>Creates a binary floating-point number from this object's
            value. Note that if the binary floating-point number contains a
            negative exponent, the resulting value might not be exact, in which
            case the resulting binary floating-point number will be an
            approximation of this decimal number's value, using the half-even
            rounding mode.</summary>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToPlainString">
            <summary>Converts this value to a string as though with the
            ToString method, but without using exponential notation.</summary>
            <returns>A text string.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSingleBits">
            <summary>Converts this value to its closest equivalent as a 32-bit
            floating-point number encoded in the IEEE 754 binary32 format,
            using the half-even rounding mode.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN.</para></summary>
            <returns>The closest 32-bit binary floating-point number to this
            value, encoded in the IEEE 754 binary32 format. The return value
            can be positive infinity or negative infinity if this value exceeds
            the range of a 32-bit floating point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSingle">
            <summary>Converts this value to its closest equivalent as a 32-bit
            floating-point number, using the half-even rounding mode.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN. Unfortunately, in the.NET implementation, the return value of
            this method may be a quiet NaN even if a signaling NaN would
            otherwise be generated.</para></summary>
            <returns>The closest 32-bit binary floating-point number to this
            value. The return value can be positive infinity or negative
            infinity if this value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToString">
            <summary>Converts this value to a text string. Returns a value
            compatible with this class's FromString method.</summary>
            <returns>A string representation of this object. The text string
            will be in exponential notation (expressed as a number 1 or
            greater, but less than 10, times a power of 10) if this object's
            Exponent property is greater than 0 or if the number's first
            nonzero decimal digit is more than five digits after the decimal
            point.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Ulp">
            <summary>Returns the unit in the last place. The significand will
            be 1 and the exponent will be this number's exponent. Returns 1
            with an exponent of 0 if this number is infinity or not-a-number
            (NaN).</summary>
            <returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSizedEInteger(System.Int32)">
            <summary>Converts this value to an arbitrary-precision integer by
            discarding its fractional part and checking whether the resulting
            integer overflows the given signed bit count.</summary>
            <param name='maxBitLength'>The maximum number of signed bits the
            integer can have. The integer's value may not be less than
            -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN), or this number's value, once converted to an
            integer by discarding its fractional part, is less than
            -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSizedEIntegerIfExact(System.Int32)">
            <summary>Converts this value to an arbitrary-precision integer,
            only if this number's value is an exact integer and that integer
            does not overflow the given signed bit count.</summary>
            <param name='maxBitLength'>The maximum number of signed bits the
            integer can have. The integer's value may not be less than
            -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN), or this number's value, once converted to an
            integer by discarding its fractional part, is less than
            -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</exception>
            <exception cref='T:System.ArithmeticException'>This object's value is not an
            exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEFloat(PeterO.Numbers.EContext)">
            <summary>Creates a binary floating-point number from this object's
            value. Note that if the binary floating-point number contains a
            negative exponent, the resulting value might not be exact, in which
            case the resulting binary floating-point number will be an
            approximation of this decimal number's value.</summary>
            <param name='ec'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. The precision is in
            bits, and an example of this parameter is <c>EContext.Binary64</c>. Can be null.</param>
            <returns>An arbitrary-precision float floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetRadix">
            <summary>This is an internal method.</summary>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetSign(PeterO.Numbers.EDecimal)">
            <summary>This is an internal method.</summary>
            <param name='value'>An arbitrary-precision decimal number.</param>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetMantissa(PeterO.Numbers.EDecimal)">
            <summary>This is an internal method.</summary>
            <param name='value'>An arbitrary-precision decimal number.</param>
            <returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetExponent(PeterO.Numbers.EDecimal)">
            <summary>This is an internal method.</summary>
            <param name='value'>An arbitrary-precision decimal number.</param>
            <returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetFlags(PeterO.Numbers.EDecimal)">
            <summary>This is an internal method.</summary>
            <param name='value'>An arbitrary-precision decimal number.</param>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.CreateNewWithFlags(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Int32)">
            <summary>This is an internal method.</summary>
            <param name='mantissa'>The parameter <paramref name='mantissa'/> is
            a Numbers.EInteger object.</param>
            <param name='exponent'>The parameter <paramref name='exponent'/> is
            an internal parameter.</param>
            <param name='flags'>The parameter <paramref name='flags'/> is an
            internal parameter.</param>
            <returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetArithmeticSupport">
            <summary>This is an internal method.</summary>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.ValueOf(System.Int32)">
            <summary>This is an internal method.</summary>
            <param name='val'>The parameter <paramref name='val'/> is a 32-bit
            signed integer.</param>
            <returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Increment">
            <summary>Returns one added to this arbitrary-precision decimal
            number.</summary>
            <returns>The given arbitrary-precision decimal number plus
            one.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Decrement">
            <summary>Returns one subtracted from this arbitrary-precision
            decimal number.</summary>
            <returns>The given arbitrary-precision decimal number minus
            one.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToByteChecked">
            <summary>Converts this number's value to a byte (from 0 to 255) if
            it can fit in a byte (from 0 to 255) after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a byte (from 0 to
            255).</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToByteUnchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a byte (from 0 to 255).</summary>
            <returns>This number, converted to a byte (from 0 to 255). Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToByteIfExact">
            <summary>Converts this number's value to a byte (from 0 to 255) if
            it can fit in a byte (from 0 to 255) without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a byte (from 0 to 255).</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromByte(System.Byte)">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
            decimal number.</summary>
            <param name='inputByte'>The number to convert as a byte (from 0 to
            255).</param>
            <returns>This number's value as an arbitrary-precision decimal
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt16Checked">
            <summary>Converts this number's value to a 16-bit signed integer if
            it can fit in a 16-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 16-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -32768 or greater than
            32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt16Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 16-bit signed integer.</summary>
            <returns>This number, converted to a 16-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt16IfExact">
            <summary>Converts this number's value to a 16-bit signed integer if
            it can fit in a 16-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 16-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -32768 or
            greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromInt16(System.Int16)">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision
            decimal number.</summary>
            <param name='inputInt16'>The number to convert as a 16-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision decimal
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 32-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -2147483648 or greater
            than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt32Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 32-bit signed integer.</summary>
            <returns>This number, converted to a 32-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 32-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -2147483648
            or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt64Checked">
            <summary>Converts this number's value to a 64-bit signed integer if
            it can fit in a 64-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 64-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -9223372036854775808
            or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt64Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 64-bit signed integer.</summary>
            <returns>This number, converted to a 64-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt64IfExact">
            <summary>Converts this number's value to a 64-bit signed integer if
            it can fit in a 64-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 64-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than
            -9223372036854775808 or greater than
            9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToDecimal">
            <summary>Converts this value to a <c>decimal</c> under the Common
            Language Infrastructure (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ),
            using the half-even rounding mode.</summary>
            <returns>A <c>decimal</c> under the Common Language Infrastructure
            (usually a.NET Framework decimal).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromDecimal(System.Decimal)">
            <summary>Converts a <c>decimal</c> under the Common Language
            Infrastructure (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) to
            an arbitrary-precision decimal.</summary>
            <param name='dec'>A <c>decimal</c> under the Common Language
            Infrastructure (usually a.NET Framework decimal).</param>
            <returns>An arbitrary-precision decimal floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(System.Boolean)~PeterO.Numbers.EDecimal">
            <summary>Converts a boolean value (true or false) to an arbitrary
            precision decimal.</summary>
            <param name='boolValue'>Either true or false.</param>
            <returns>The number 1 if <paramref name='boolValue'/> is true;
            otherwise, 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Decimal)~PeterO.Numbers.EDecimal">
            <summary>Converts an arbitrary-precision decimal number to a
            <c>decimal</c> under the Common Language Infrastructure (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ),
            using the half-even rounding mode.</summary>
            <param name='dec'>The number to convert as an arbitrary-precision
            decimal floating-point number.</param>
            <returns>A <c>decimal</c> under the Common Language Infrastructure
            (usually a.NET Framework decimal).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Decimal">
            <summary>Converts an arbitrary-precision decimal's value to a
            <c>decimal</c> under the Common Language Infrastructure (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ),
            using the half-even rounding mode.</summary>
            <param name='bigValue'>The parameter <paramref name='bigValue'/> is
            an arbitrary-precision decimal floating-point number.</param>
            <returns>A <c>decimal</c> under the Common Language Infrastructure
            (usually a.NET Framework decimal).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.EDecimal">
            <summary>Converts an arbitrary-precision integer to an arbitrary
            precision decimal.</summary>
            <param name='eint'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision decimal number with the exponent
            set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Addition(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Adds an arbitrary-precision decimal floating-point number
            and another arbitrary-precision decimal floating-point number and
            returns the result.</summary>
            <param name='bthis'>The first arbitrary-precision decimal
            floating-point number.</param>
            <param name='otherValue'>The second decimal binary floating-point
            number.</param>
            <returns>The sum of the two numbers, that is, an
            arbitrary-precision decimal floating-point number plus another
            arbitrary-precision decimal floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> or <paramref name='otherValue'/> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Subtraction(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Subtracts one arbitrary-precision decimal number from
            another and returns the result.</summary>
            <param name='bthis'>The first operand.</param>
            <param name='subtrahend'>The second operand.</param>
            <returns>The difference of the two decimal numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> or <paramref name='subtrahend'/> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Increment(PeterO.Numbers.EDecimal)">
            <summary>Adds one to an arbitrary-precision decimal
            number.</summary>
            <param name='bthis'>An arbitrary-precision decimal number.</param>
            <returns>The given arbitrary-precision decimal number plus
            one.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Decrement(PeterO.Numbers.EDecimal)">
            <summary>Subtracts one from an arbitrary-precision decimal
            number.</summary>
            <param name='bthis'>An arbitrary-precision decimal number.</param>
            <returns>The given arbitrary-precision decimal number minus
            one.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Multiply(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Multiplies an arbitrary-precision decimal floating-point
            number by another arbitrary-precision decimal floating-point number
            and returns the result.</summary>
            <param name='operand1'>The first operand.</param>
            <param name='operand2'>The second operand.</param>
            <returns>The product of the two numbers, that is, an
            arbitrary-precision decimal floating-point number times another
            arbitrary-precision decimal floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='operand1'/> or <paramref name='operand2'/> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Division(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Divides this object by another decimal number and returns
            the result. When possible, the result will be exact.</summary>
            <param name='dividend'>The number that will be divided by the
            divisor.</param>
            <param name='divisor'>The number to divide by.</param>
            <returns>The quotient of the two numbers. Returns infinity if the
            divisor is 0 and the dividend is nonzero. Returns not-a-number
            (NaN) if the divisor and the dividend are 0. Returns NaN if the
            result can't be exact because it would have a nonterminating
            decimal expansion; examples include 1 divided by any multiple of 3,
            such as 1/3 or 1/12. If this is not desired, use DivideToExponent
            instead, or use the Divide overload that takes an EContext
            instead.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='dividend'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Modulus(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Returns the remainder that would result when an
            arbitrary-precision decimal floating-point number is divided by
            another arbitrary-precision decimal floating-point number. The
            remainder is the number that remains when the absolute value of an
            arbitrary-precision decimal floating-point number is divided (as
            though by DivideToIntegerZeroScale) by the absolute value of the
            other arbitrary-precision decimal floating-point number; the
            remainder has the same sign (positive or negative) as this
            arbitrary-precision decimal floating-point number.</summary>
            <param name='dividend'>The number that will be divided by the
            divisor.</param>
            <param name='divisor'>The number to divide by.</param>
            <returns>The remainder that would result when an
            arbitrary-precision decimal floating-point number is divided by
            another arbitrary-precision decimal floating-point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='dividend'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_UnaryNegation(PeterO.Numbers.EDecimal)">
            <summary>Gets an arbitrary-precision decimal number with the same
            value as the given one, but with the sign reversed.</summary>
            <param name='bigValue'>An arbitrary-precision decimal number to
            negate.</param>
            <returns>An arbitrary-precision decimal number. If this value is
            positive zero, returns negative zero. Returns signaling NaN if this
            value is signaling NaN.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.EInteger">
            <summary>Converts an arbitrary-precision decimal floating-point
            number to an arbitrary-precision integer. Any fractional part in
            this value will be discarded when converting to an
            arbitrary-precision integer.</summary>
            <param name='bigValue'>The number to convert as an
            arbitrary-precision decimal.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Double">
            <summary>Converts this value to its closest equivalent as a 64-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 64-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN. Unfortunately, in the.NET implementation, the return value of
            this method may be a quiet NaN even if a signaling NaN would
            otherwise be generated.</para></summary>
            <param name='bigValue'>The value to convert to a 64-bit
            floating-point number.</param>
            <returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Single">
            <summary>Converts this value to its closest equivalent as a 32-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN. Unfortunately, in the.NET implementation, the return value of
            this method may be a quiet NaN even if a signaling NaN would
            otherwise be generated.</para></summary>
            <param name='bigValue'>The number to convert as an
            arbitrary-precision decimal number.</param>
            <returns>The closest 32-bit binary floating-point number to this
            value. The return value can be positive infinity or negative
            infinity if this value exceeds the range of a 32-bit floating point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Byte">
            <summary>Converts an arbitrary-precision decimal number to a byte
            (from 0 to 255) if it can fit in a byte (from 0 to 255) after
            converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            decimal number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            byte (from 0 to 255).</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 255.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Byte)~PeterO.Numbers.EDecimal">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
            decimal number.</summary>
            <param name='inputByte'>The number to convert as a byte (from 0 to
            255).</param>
            <returns>The value of <paramref name='inputByte'/> as an
            arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSByteChecked">
            <summary>Converts this number's value to an 8-bit signed integer if
            it can fit in an 8-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to an 8-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -128 or greater than
            127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSByteUnchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as an 8-bit signed integer.</summary>
            <returns>This number, converted to an 8-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSByteIfExact">
            <summary>Converts this number's value to an 8-bit signed integer if
            it can fit in an 8-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as an 8-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -128 or
            greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromSByte(System.SByte)">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision
            decimal number.</summary>
            <param name='inputSByte'>The number to convert as an 8-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision decimal
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.SByte">
            <summary>Converts an arbitrary-precision decimal number to an 8-bit
            signed integer if it can fit in an 8-bit signed integer after
            converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            decimal number.</param>
            <returns>The value of <paramref name='input'/>, truncated to an
            8-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -128 or greater than 127.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.SByte)~PeterO.Numbers.EDecimal">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision
            decimal number.</summary>
            <param name='inputSByte'>The number to convert as an 8-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputSByte'/> as an
            arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int16">
            <summary>Converts an arbitrary-precision decimal number to a 16-bit
            signed integer if it can fit in a 16-bit signed integer after
            converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            decimal number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            16-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -32768 or greater than 32767.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int16)~PeterO.Numbers.EDecimal">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision
            decimal number.</summary>
            <param name='inputInt16'>The number to convert as a 16-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt16'/> as an
            arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt16Checked">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer after converting it to
            an integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 16-bit unsigned
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt16Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 16-bit unsigned integer.</summary>
            <returns>This number, converted to a 16-bit unsigned integer.
            Returns 0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt16IfExact">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 16-bit unsigned
            integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromUInt16(System.UInt16)">
            <summary>Converts a 16-bit unsigned integer to an
            arbitrary-precision decimal number.</summary>
            <param name='inputUInt16'>The number to convert as a 16-bit
            unsigned integer.</param>
            <returns>This number's value as an arbitrary-precision decimal
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt16">
            <summary>Converts an arbitrary-precision decimal number to a 16-bit
            unsigned integer if it can fit in a 16-bit unsigned integer after
            converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            decimal number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            16-bit unsigned integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 65535.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt16)~PeterO.Numbers.EDecimal">
            <summary>Converts a 16-bit unsigned integer to an
            arbitrary-precision decimal number.</summary>
            <param name='inputUInt16'>The number to convert as a 16-bit
            unsigned integer.</param>
            <returns>The value of <paramref name='inputUInt16'/> as an
            arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int32">
            <summary>Converts an arbitrary-precision decimal number to a 32-bit
            signed integer if it can fit in a 32-bit signed integer after
            converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            decimal number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            32-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -2147483648 or greater than 2147483647.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int32)~PeterO.Numbers.EDecimal">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            decimal number.</summary>
            <param name='inputInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt32'/> as an
            arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 32-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt32Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 32-bit signed integer.</summary>
            <returns>This number, converted to a 32-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 32-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromUInt32(System.UInt32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            decimal number.</summary>
            <param name='inputUInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision decimal
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt32">
            <summary>Converts an arbitrary-precision decimal number to a 32-bit
            signed integer if it can fit in a 32-bit signed integer after
            converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            decimal number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            32-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 4294967295.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt32)~PeterO.Numbers.EDecimal">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            decimal number.</summary>
            <param name='inputUInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputUInt32'/> as an
            arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int64">
            <summary>Converts an arbitrary-precision decimal number to a 64-bit
            signed integer if it can fit in a 64-bit signed integer after
            converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            decimal number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            64-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -9223372036854775808 or greater than
            9223372036854775807.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int64)~PeterO.Numbers.EDecimal">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision
            decimal number.</summary>
            <param name='inputInt64'>The number to convert as a 64-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt64'/> as an
            arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt64Checked">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer after converting it to
            an integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 64-bit unsigned
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt64Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 64-bit unsigned integer.</summary>
            <returns>This number, converted to a 64-bit unsigned integer.
            Returns 0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt64IfExact">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 64-bit unsigned
            integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromUInt64(System.UInt64)">
            <summary>Converts a 64-bit unsigned integer to an
            arbitrary-precision decimal number.</summary>
            <param name='inputUInt64'>The number to convert as a 64-bit
            unsigned integer.</param>
            <returns>This number's value as an arbitrary-precision decimal
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt64">
            <summary>Converts an arbitrary-precision decimal number to a 64-bit
            unsigned integer if it can fit in a 64-bit unsigned integer after
            converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            decimal number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            64-bit unsigned integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 18446744073709551615.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt64)~PeterO.Numbers.EDecimal">
            <summary>Converts a 64-bit unsigned integer to an
            arbitrary-precision decimal number.</summary>
            <param name='inputUInt64'>The number to convert as a 64-bit
            unsigned integer.</param>
            <returns>The value of <paramref name='inputUInt64'/> as an
            arbitrary-precision decimal number.</returns>
        </member>
        <member name="T:PeterO.Numbers.ERounding">
            <summary>Specifies the mode to use when "shortening" numbers that
            otherwise can't fit a given number of digits, so that the shortened
            number has about the same value. This "shortening" is known as
            rounding. (The "E" stands for "extended", and has this prefix to
            group it with the other classes common to this library,
            particularly EDecimal, EFloat, and ERational.).</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.None">
            <summary>Indicates that rounding will not be used. If rounding to
            an inexact value is required, the rounding operation will report an
            error.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.Up">
            <summary>If there is a fractional part, the number is rounded to
            the closest representable number away from zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.Down">
            <summary>The fractional part is discarded (the number is
            truncated).</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.HalfUp">
            <summary>Rounded to the nearest number; if the fractional part is
            exactly half, the number is rounded to the closest representable
            number away from zero. This is the most familiar rounding mode for
            many people.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.HalfDown">
            <summary>Rounded to the nearest number; if the fractional part is
            exactly half, it is discarded.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.HalfEven">
            <summary>Rounded to the nearest number; if the fractional part is
            exactly half, the number is rounded to the closest representable
            number that is even. This is sometimes also known as "banker's
            rounding".</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.Ceiling">
            <summary>If there is a fractional part, the number is rounded to
            the highest representable number that's closest to it.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.Floor">
            <summary>If there is a fractional part, the number is rounded to
            the lowest representable number that's closest to it.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.Odd">
            <summary>If there is a fractional part and the whole number part is
            even, the number is rounded to the closest representable odd number
            away from zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.ZeroFiveUp">
            <summary>If there is a fractional part and if the last digit before
            rounding is 0 or half the radix, the number is rounded to the
            closest representable number away from zero; otherwise the
            fractional part is discarded. In overflow, the fractional part is
            always discarded.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.OddOrZeroFiveUp">
            <summary>For binary floating point numbers, this is the same as
            Odd. For other bases (including decimal numbers), this is the same
            as ZeroFiveUp. This rounding mode is useful for rounding
            intermediate results at a slightly higher precision (at least 2
            bits more for binary) than the final precision.</summary>
        </member>
        <member name="M:PeterO.Numbers.FastIntegerFixed.ToString">
            <summary>This is an internal API.</summary>
            <returns>A text string.</returns>
        </member>
        <member name="T:PeterO.Numbers.EContext">
            <summary>Contains parameters for controlling the precision,
            rounding, and exponent range of arbitrary-precision numbers. (The
            "E" stands for "extended", and has this prefix to group it with the
            other classes common to this library, particularly EDecimal,
            EFloat, and ERational.).
            <para><b>Thread safety:</b> With one exception, instances of this
            class are immutable and are safe to use among multiple threads. The
            one exception involves the <c>Flags</c> property. If the context's
            <c>HasFlags</c> property (a read-only property) is <c>true</c>,
            the <c>Flags</c> property is mutable, thus making the context
            mutable. This class doesn't synchronize access to such mutable
            contexts, so applications should provide their own synchronization
            if a context with the <c>HasFlags</c> property set to <c>true</c>
            will be shared among multiple threads and at least one of those
            threads needs to write the <c>Flags</c> property (which can happen,
            for example, by passing the context to most methods of
            <c>EDecimal</c> such as <c>Add</c> ).</para></summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagClamped">
            <summary>Signals that the exponent was adjusted to fit the exponent
            range.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagDivideByZero">
            <summary>Signals a division of a nonzero number by zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagInexact">
            <summary>Signals that the result was rounded to a different
            mathematical value, but as close as possible to the
            original.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagInvalid">
            <summary>Signals an invalid operation.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagLostDigits">
            <summary>Signals that an operand was rounded to a different
            mathematical value before an operation.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagOverflow">
            <summary>Signals that the result is non-zero and the exponent is
            higher than the highest exponent allowed.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagRounded">
            <summary>Signals that the result was rounded to fit the precision;
            either the value or the exponent may have changed from the
            original.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagSubnormal">
            <summary>Signals that the result's exponent, before rounding, is
            lower than the lowest exponent allowed.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagUnderflow">
            <summary>Signals that the result's exponent, before rounding, is
            lower than the lowest exponent allowed, and the result was rounded
            to a different mathematical value, but as close as possible to the
            original.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Basic">
            <summary>A basic arithmetic context, 9 digits precision, rounding
            mode half-up, unlimited exponent range. The default rounding mode
            is HalfUp.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.BigDecimalJava">
            <summary>An arithmetic context for Java's BigDecimal format. The
            default rounding mode is HalfUp.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Binary128">
            <summary>An arithmetic context for the IEEE-754-2008 binary128
            format, 113 bits precision. The default rounding mode is
            HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Binary16">
            <summary>An arithmetic context for the IEEE-754-2008 binary16
            format, 11 bits precision. The default rounding mode is
            HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Binary32">
            <summary>An arithmetic context for the IEEE-754-2008 binary32
            format, 24 bits precision. The default rounding mode is
            HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Binary64">
            <summary>An arithmetic context for the IEEE-754-2008 binary64
            format, 53 bits precision. The default rounding mode is
            HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.CliDecimal">
            <summary>An arithmetic context for the.NET Framework decimal format
            (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ), 96
            bits precision, and a valid exponent range of -28 to 0. The default
            rounding mode is HalfEven. (The <c>"Cli"</c> stands for "Common
            Language Infrastructure", which defined this format as the .NET
            Framework decimal format in version 1, but leaves it unspecified in
            later versions.).</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Decimal128">
            <summary>An arithmetic context for the IEEE-754-2008 decimal128
            format. The default rounding mode is HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Decimal32">
            <summary>An arithmetic context for the IEEE-754-2008 decimal32
            format. The default rounding mode is HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Decimal64">
            <summary>An arithmetic context for the IEEE-754-2008 decimal64
            format. The default rounding mode is HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Unlimited">
            <summary>No specific (theoretical) limit on precision. Rounding
            mode HalfUp.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.UnlimitedHalfEven">
            <summary>No specific (theoretical) limit on precision. Rounding
            mode HalfEven.</summary>
        </member>
        <member name="M:PeterO.Numbers.EContext.#ctor(System.Int32,PeterO.Numbers.ERounding,System.Int32,System.Int32,System.Boolean)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Numbers.EContext'/> class.</summary>
            <param name='precision'>The value of the Precision
            property.</param>
            <param name='rounding'>The value of the Rounding property.</param>
            <param name='exponentMinSmall'>The value of the EMin
            property.</param>
            <param name='exponentMaxSmall'>The value of the EMax
            property.</param>
            <param name='clampNormalExponents'>The value of the
            ClampNormalExponents property.</param>
        </member>
        <member name="M:PeterO.Numbers.EContext.#ctor(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Boolean)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Numbers.EContext'/> class,.</summary>
            <param name='bigintPrecision'>The value of the Precision
            property.</param>
            <param name='rounding'>The value of the Rounding property.</param>
            <param name='exponentMin'>The value of the EMin property.</param>
            <param name='exponentMax'>The value of the EMax property.</param>
            <param name='clampNormalExponents'>The value of the
            ClampNormalExponents property.</param>
        </member>
        <member name="P:PeterO.Numbers.EContext.AdjustExponent">
            <summary>Gets a value indicating whether the EMax and EMin
            properties refer to the number's Exponent property adjusted to the
            number's precision, or just the number's Exponent property. The
            default value is true, meaning that EMax and EMin refer to the
            adjusted exponent. Setting this value to false (using
            WithAdjustExponent) is useful for modeling floating point
            representations with an integer significand and an integer
            exponent, such as Java's BigDecimal.</summary>
            <value><c>true</c> if the EMax and EMin properties refer to the
            number's Exponent property adjusted to the number's precision, or
            false if they refer to just the number's Exponent property.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.ClampNormalExponents">
            <summary>Gets a value indicating whether a converted number's
            Exponent property will not be higher than EMax + 1 - Precision. If
            a number's exponent is higher than that value, but not high enough
            to cause overflow, the exponent is clamped to that value and enough
            zeros are added to the number's significand to account for the
            adjustment. If HasExponentRange is false, this value is always
            false.</summary>
            <value>If true, a converted number's Exponent property will not be
            higher than EMax + 1 - Precision.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.EMax">
            <summary>Gets the highest exponent possible when a converted number
            is expressed in scientific notation with one nonzero digit before
            the radix point. For example, with a precision of 3 and an EMax of
            100, the maximum value possible is 9.99E + 100. (This is not the
            same as the highest possible Exponent property.) If
            HasExponentRange is false, this value will be 0.</summary>
            <value>The highest exponent possible when a converted number is
            expressed in scientific notation with one nonzero digit before the
            radix point. For example, with a precision of 3 and an EMax of 100,
            the maximum value possible is 9.99E + 100. (This is not the same as
            the highest possible Exponent property.) If HasExponentRange is
            false, this value will be 0.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.EMin">
            <summary>Gets the lowest exponent possible when a converted number
            is expressed in scientific notation with one nonzero digit before
            the radix point. For example, with a precision of 3 and an EMin of
            -100, the next value that comes after 0 is 0.001E-100. (If
            AdjustExponent is false, this property specifies the lowest
            possible Exponent property instead.) If HasExponentRange is false,
            this value will be 0.</summary>
            <value>The lowest exponent possible when a converted number is
            expressed in scientific notation with one nonzero digit before the
            radix point. For example, with a precision of 3 and an EMin of
            -100, the next value that comes after 0 is 0.001E-100. (If
            AdjustExponent is false, this property specifies the lowest
            possible Exponent property instead.) If HasExponentRange is false,
            this value will be 0.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.Flags">
            <summary>Gets or sets the flags that are set from converting
            numbers according to this arithmetic context. If <c>HasFlags</c> is
            false, this value will be 0. This value is a combination of bit
            fields. To retrieve a particular flag, use the AND operation on the
            return value of this method. For example: <c>(this.Flags
            &amp;EContext.FlagInexact) != 0</c> returns <c>true</c> if the
            Inexact flag is set.</summary>
            <value>The flags that are set from converting numbers according to
            this arithmetic context. If <c>HasFlags</c> is false, this value
            will be 0. This value is a combination of bit fields. To retrieve a
            particular flag, use the AND operation on the return value of this
            method. For example: <c>(this.Flags &amp;EContext.FlagInexact)
            !=0</c> returns <c>true</c> if the Inexact flag is set.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.HasExponentRange">
            <summary>Gets a value indicating whether this context defines a
            minimum and maximum exponent. If false, converted exponents can
            have any exponent and operations can't cause overflow or
            underflow.</summary>
            <value><c>true</c> if this context defines a minimum and maximum
            exponent; otherwise, <c>false</c>.. If false, converted exponents
            can have any exponent and operations can't cause overflow or
            underflow. <c>true</c> if this context defines a minimum and
            maximum exponent; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.HasFlags">
            <summary>Gets a value indicating whether this context has a mutable
            Flags field.</summary>
            <value><c>true</c> if this context has a mutable Flags field;
            otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.HasMaxPrecision">
            <summary>Gets a value indicating whether this context defines a
            maximum precision. This is the same as whether this context's
            Precision property is zero.</summary>
            <value><c>true</c> if this context defines a maximum precision;
            otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.IsPrecisionInBits">
            <summary>Gets a value indicating whether this context's Precision
            property is in bits, rather than digits. The default is
            false.</summary>
            <value><c>true</c> if this context's Precision property is in bits,
            rather than digits; otherwise, <c>false</c>.. The default is
            false. <c>true</c> if this context's Precision property is in bits,
            rather than digits; otherwise, <c>false</c>. The default is
            false.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.IsSimplified">
            <summary>Gets a value indicating whether to use a "simplified"
            arithmetic. In the simplified arithmetic, infinity, not-a-number,
            and subnormal numbers are not allowed, and negative zero is treated
            the same as positive zero. For further details, see
            <a
              href='http://speleotrove.com/decimal/dax3274.html'><c>http://speleotrove.com/decimal/dax3274.html</c></a>
            .</summary>
            <value><c>true</c> if to use a "simplified" arithmetic; otherwise,
            <c>false</c> In the simplified arithmetic, infinity, not-a-number,
            and subnormal numbers are not allowed, and negative zero is treated
            the same as positive zero. For further details, see
            <a
              href='http://speleotrove.com/decimal/dax3274.html'><c>http://speleotrove.com/decimal/dax3274.html</c></a>
            . <c>true</c> if a "simplified" arithmetic will be used; otherwise,
            <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.Precision">
            <summary>Gets the maximum length of a converted number in digits,
            ignoring the radix point and exponent. For example, if precision is
            3, a converted number's significand can range from 0 to 999 (up to
            three digits long). If 0, converted numbers can have any precision.
            <para>Not-a-number (NaN) values can carry an optional number, its
            payload, that serves as its "diagnostic information", In general,
            if an operation requires copying an NaN's payload, only up to as
            many digits of that payload as the precision given in this context,
            namely the least significant digits, are copied.</para></summary>
            <value>The maximum length of a converted number in digits, ignoring
            the radix point and exponent. For example, if precision is 3, a
            converted number's significand can range from 0 to 999 (up to three
            digits long). If 0, converted numbers can have any
            precision.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.Rounding">
            <summary>Gets the desired rounding mode when converting numbers
            that can't be represented in the given precision and exponent
            range.</summary>
            <value>The desired rounding mode when converting numbers that can't
            be represented in the given precision and exponent range.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.Traps">
            <summary>Gets the traps that are set for each flag in the context.
            Whenever a flag is signaled, even if <c>HasFlags</c> is false, and
            the flag's trap is enabled, the operation will throw a
            TrapException.
            <para>For example, if Traps equals <c>FlagInexact</c> and
            FlagSubnormal, a TrapException will be thrown if an operation's
            return value is not the same as the exact result (FlagInexact) or
            if the return value's exponent is lower than the lowest allowed
            (FlagSubnormal).</para></summary>
            <value>The traps that are set for each flag in the context.
            Whenever a flag is signaled, even if <c>HasFlags</c> is false, and
            the flag's trap is enabled, the operation will throw a
            TrapException.
            <para>For example, if Traps equals <c>FlagInexact</c> and
            FlagSubnormal, a TrapException will be thrown if an operation's
            return value is not the same as the exact result (FlagInexact) or
            if the return value's exponent is lower than the lowest allowed
            (FlagSubnormal).</para>.</value>
        </member>
        <member name="M:PeterO.Numbers.EContext.ForPrecision(System.Int32)">
            <summary>Creates a new arithmetic context using the given maximum
            number of digits, an unlimited exponent range, and the HalfUp
            rounding mode.</summary>
            <param name='precision'>Maximum number of digits
            (precision).</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.ForPrecisionAndRounding(System.Int32,PeterO.Numbers.ERounding)">
            <summary>Creates a new EContext object initialized with an
            unlimited exponent range, and the given rounding mode and maximum
            precision.</summary>
            <param name='precision'>Maximum number of digits
            (precision).</param>
            <param name='rounding'>The parameter <paramref name='rounding'/> is
            an ERounding object.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.ForRounding(PeterO.Numbers.ERounding)">
            <summary>Creates a new EContext object initialized with an
            unlimited precision, an unlimited exponent range, and the given
            rounding mode.</summary>
            <param name='rounding'>The rounding mode for the new precision
            context.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.Copy">
            <summary>Initializes a new EContext that is a copy of another
            EContext.</summary>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.ExponentWithinRange(PeterO.Numbers.EInteger)">
            <summary>Determines whether a number can have the given Exponent
            property under this arithmetic context.</summary>
            <param name='exponent'>An arbitrary-precision integer indicating
            the desired exponent.</param>
            <returns><c>true</c> if a number can have the given Exponent
            property under this arithmetic context; otherwise, <c>false</c>.
            If this context allows unlimited precision, returns true for the
            exponent EMax and any exponent less than EMax.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='exponent'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EContext.ToString">
            <summary>Returns this object in a text form intended to be read by
            humans. The value returned by this method is not intended to be
            parsed by computer programs, and the exact text of the value may
            change at any time between versions of this library.</summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="P:PeterO.Numbers.EContext.HasFlagsOrTraps">
            <summary>Gets a value indicating whether this context has a mutable
            Flags field, one or more trap enablers, or both.</summary>
            <value><c>true</c> if this context has a mutable Flags field, one
            or more trap enablers, or both; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithAdjustExponent(System.Boolean)">
            <summary>Copies this EContext and sets the copy's "AdjustExponent"
            property to the given value.</summary>
            <param name='adjustExponent'>The new value of the "AdjustExponent"
            property for the copy.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithBigExponentRange(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Copies this arithmetic context and sets the copy's
            exponent range.</summary>
            <param name='exponentMin'>Desired minimum exponent (EMin).</param>
            <param name='exponentMax'>Desired maximum exponent (EMax).</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='exponentMin'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>ExponentMin greater than
            exponentMax".</exception>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithNoFlagsOrTraps">
            <summary>Copies this EContext with <c>HasFlags</c> set to false, a
            Traps value of 0, and a Flags value of 0.</summary>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithBigPrecision(PeterO.Numbers.EInteger)">
            <summary>Copies this EContext and gives it a particular precision
            value.</summary>
            <param name='bigintPrecision'>Desired precision. 0 means unlimited
            precision.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigintPrecision'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithBlankFlags">
            <summary>Copies this EContext with <c>HasFlags</c> set to true and
            a Flags value of 0.</summary>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithExponentClamp(System.Boolean)">
            <summary>Copies this arithmetic context and sets the copy's
            "ClampNormalExponents" flag to the given value.</summary>
            <param name='clamp'>The desired value of the "ClampNormalExponents"
            flag.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithExponentRange(System.Int32,System.Int32)">
            <summary>Copies this arithmetic context and sets the copy's
            exponent range.</summary>
            <param name='exponentMinSmall'>Desired minimum exponent
            (EMin).</param>
            <param name='exponentMaxSmall'>Desired maximum exponent
            (EMax).</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithNoFlags">
            <summary>Copies this EContext with <c>HasFlags</c> set to false and
            a Flags value of 0.</summary>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithPrecision(System.Int32)">
            <summary>Copies this EContext and gives it a particular precision
            value.</summary>
            <param name='precision'>Desired precision. 0 means unlimited
            precision.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithPrecisionInBits(System.Boolean)">
            <summary>Copies this EContext and sets the copy's
            "IsPrecisionInBits" property to the given value.</summary>
            <param name='isPrecisionBits'>The new value of the
            "IsPrecisionInBits" property for the copy.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithRounding(PeterO.Numbers.ERounding)">
            <summary>Copies this EContext with the specified rounding
            mode.</summary>
            <param name='rounding'>Desired value of the Rounding
            property.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithSimplified(System.Boolean)">
            <summary>Copies this EContext and sets the copy's "IsSimplified"
            property to the given value.</summary>
            <param name='simplified'>Desired value of the IsSimplified
            property.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithTraps(System.Int32)">
            <summary>Copies this EContext with Traps set to the given value.
            (Also sets HasFlags on the copy to <c>True</c>, but this may
            change in version 2.0 of this library.).</summary>
            <param name='traps'>Flags representing the traps to enable. See the
            property "Traps".</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithUnlimitedExponents">
            <summary>Copies this EContext with an unlimited exponent
            range.</summary>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.GetNontrapping">
            <summary>Returns this context if it doesn't set traps, or a context
            without traps and with blank flags if it does, so that the
            resulting context does not cause trap exceptions to occur. This is
            not a general-purpose method; it is intended to support custom
            implementations of arithmetic operations.</summary>
            <returns>This context if it doesn't set traps, or a context without
            traps and with blank flags if it does.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.TriggerTraps``1(``0,PeterO.Numbers.EContext)">
            <summary>Throws trap exceptions if the given context has flags set
            that also have traps enabled for them in this context, and adds the
            given context's flags to this context if HasFlags for this context
            is true. This is not a general-purpose method; it is intended to
            support custom implementations of arithmetic operations.</summary>
            <param name='result'>The result of the operation.</param>
            <param name='trappableContext'>An arithmetic context, usually a
            context returned by the GetNontrapping method. Can be null.</param>
            <typeparam name='T'>Data type for the result of the
            operation.</typeparam>
            <returns>The parameter <paramref name='result'/> if no trap
            exceptions were thrown.</returns>
        </member>
        <member name="T:PeterO.Numbers.EInteger">
            <summary>Represents an arbitrary-precision integer. (The "E" stands
            for "extended", and has this prefix to group it with the other
            classes common to this library, particularly EDecimal, EFloat, and
            ERational.)
            <para>Instances of this class are immutable, so they are inherently
            safe for use by multiple threads. Multiple instances of this object
            with the same value are interchangeable, but they should be
            compared using the "Equals" method rather than the "=="
            operator.</para>
            <para><b>Security note</b></para>
            <para>It is not recommended to implement security-sensitive
            algorithms using the methods in this class, for several
            reasons:</para>
            <list>
            <item><c>EInteger</c> objects are immutable, so they can't be
            modified, and the memory they occupy is not guaranteed to be
            cleared in a timely fashion due to garbage collection. This is
            relevant for applications that use many-bit-long numbers as secret
            parameters.</item>
            <item>The methods in this class (especially those that involve
            arithmetic) are not guaranteed to be "constant-time"
            (non-data-dependent) for all relevant inputs. Certain attacks that
            involve encrypted communications have exploited the timing and
            other aspects of such communications to derive keying material or
            cleartext indirectly.</item></list>
            <para>Applications should instead use dedicated security libraries
            to handle big numbers in security-sensitive
            algorithms.</para></summary>
        </member>
        <member name="P:PeterO.Numbers.EInteger.One">
            <summary>Gets the number 1 as an arbitrary-precision
            integer.</summary>
            <value>The number 1 as an arbitrary-precision integer.</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.Ten">
            <summary>Gets the number 10 as an arbitrary-precision
            integer.</summary>
            <value>The number 10 as an arbitrary-precision integer.</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.Zero">
            <summary>Gets the number zero as an arbitrary-precision
            integer.</summary>
            <value>The number zero as an arbitrary-precision integer.</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.IsEven">
            <summary>Gets a value indicating whether this value is
            even.</summary>
            <value><c>true</c> if this value is even; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.IsPowerOfTwo">
            <summary>Gets a value indicating whether this object's value is a
            power of two, and greater than 0.</summary>
            <value><c>true</c> if this object's value is a power of two, and
            greater than 0; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.IsZero">
            <summary>Gets a value indicating whether this value is 0.</summary>
            <value><c>true</c> if this value is 0; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.Sign">
            <summary>Gets the sign of this object's value.</summary>
            <value>The sign of this object's value.</value>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromBytes(System.Byte[],System.Boolean)">
            <summary>Initializes an arbitrary-precision integer from an array
            of bytes.</summary>
            <param name='bytes'>A byte array consisting of the two's-complement
            form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
            the arbitrary-precision integer to create. The byte array is
            encoded using the rules given in the FromBytes(bytes, offset,
            length, littleEndian) overload.</param>
            <param name='littleEndian'>If true, the byte order is
            little-endian, or least-significant-byte first. If false, the byte
            order is big-endian, or most-significant-byte first.</param>
            <returns>An arbitrary-precision integer. Returns 0 if the byte
            array's length is 0.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromBytes(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>Initializes an arbitrary-precision integer from a portion
            of an array of bytes. The portion of the byte array is encoded
            using the following rules:
            <list>
            <item>Positive numbers have the first byte's highest bit cleared,
            and negative numbers have the bit set.</item>
            <item>The last byte contains the lowest 8-bits, the next-to-last
            contains the next lowest 8 bits, and so on. For example, the number
            300 can be encoded as <c>0x01, 0x2C</c> and 200 as <c>0x00,
            0xC8</c>. (Note that the second example contains a set high bit in
            <c>0xC8</c>, so an additional 0 is added at the start to ensure
            it's interpreted as positive.)</item>
            <item>To encode negative numbers, take the absolute value of the
            number, subtract by 1, encode the number into bytes, and toggle
            each bit of each byte. Any further bits that appear beyond the most
            significant bit of the number will be all ones. For example, the
            number -450 can be encoded as <c>0xfe, 0x70</c> and -52869 as
            <c>0xff, 0x31, 0x7B</c>. (Note that the second example contains a
            cleared high bit in <c>0x31, 0x7B</c>, so an additional 0xff is
            added at the start to ensure it's interpreted as
            negative.)</item></list>
            <para>For little-endian, the byte order is reversed from the byte
            order just discussed.</para></summary>
            <param name='bytes'>A byte array consisting of the two's-complement
            form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
            the arbitrary-precision integer to create. The byte array is
            encoded using the rules given in the FromBytes(bytes, offset,
            length, littleEndian) overload.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='bytes'/> begins.</param>
            <param name='length'>The length, in bytes, of the desired portion
            of <paramref name='bytes'/> (but not more than <paramref
            name='bytes'/> 's length).</param>
            <param name='littleEndian'>If true, the byte order is
            little-endian, or least-significant-byte first. If false, the byte
            order is big-endian, or most-significant-byte first.</param>
            <returns>An arbitrary-precision integer. Returns 0 if the byte
            array's length is 0.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='bytes'/> 's length, or <paramref
            name='bytes'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromBoolean(System.Boolean)">
            <summary>Converts a boolean value (true or false) to an
            arbitrary-precision integer.</summary>
            <param name='boolValue'>Either true or false.</param>
            <returns>The number 1 if <paramref name='boolValue'/> is true;
            otherwise, 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromInt32(System.Int32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            integer.</summary>
            <param name='intValue'>The parameter <paramref name='intValue'/> is
            a 32-bit signed integer.</param>
            <returns>An arbitrary-precision integer with the same value as the
            64-bit number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromInt64AsUnsigned(System.Int64)">
            <summary>Converts an unsigned integer expressed as a 64-bit signed
            integer to an arbitrary-precision integer.</summary>
            <param name='longerValue'>A 64-bit signed integer. If this value is
            0 or greater, the return value will represent it. If this value is
            less than 0, the return value will store 2^64 plus this value
            instead.</param>
            <returns>An arbitrary-precision integer. If <paramref
            name='longerValue'/> is 0 or greater, the return value will
            represent it. If <paramref name='longerValue'/> is less than 0, the
            return value will store 2^64 plus this value instead.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromInt64(System.Int64)">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision
            integer.</summary>
            <param name='longerValue'>The parameter <paramref
            name='longerValue'/> is a 64-bit signed integer.</param>
            <returns>An arbitrary-precision integer with the same value as the
            64-bit number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromRadixString(System.String,System.Int32)">
            <summary>Converts a string to an arbitrary-precision integer in a
            given radix.</summary>
            <param name='str'>A string described by the FromRadixSubstring
            method.</param>
            <param name='radix'>A base from 2 to 36. Depending on the radix,
            the string can use the basic digits 0 to 9 (U+0030 to U+0039) and
            then the basic upper-case letters A to Z (U+0041 to U+005A). For
            example, 0-9 in radix 10, and 0-9, then A-F in radix 16. Where a
            basic upper-case letter A to Z is allowed in the string, the
            corresponding basic lower-case letter (U+0061 to U+007a) is allowed
            instead.</param>
            <returns>An arbitrary-precision integer with the same value as the
            given string.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:System.FormatException'>The string is empty or in an
            invalid format.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromRadixSubstring(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>Converts a portion of a string to an arbitrary-precision
            integer in a given radix.</summary>
            <param name='str'>A text string. The desired portion of the string
            must contain only characters allowed by the given radix, except
            that it may start with a minus sign ("-", U+002D) to indicate a
            negative number. The desired portion is not allowed to contain
            white space characters, including spaces. The desired portion may
            start with any number of zeros.</param>
            <param name='radix'>A base from 2 to 36. Depending on the radix,
            the string can use the basic digits 0 to 9 (U+0030 to U+0039) and
            then the basic upper-case letters A to Z (U+0041 to U+005A). For
            example, 0-9 in radix 10, and 0-9, then A-F in radix 16. Where a
            basic upper-case letter A to Z is allowed in the string, the
            corresponding basic lower-case letter (U+0061 to U+007a) is allowed
            instead.</param>
            <param name='index'>The index of the string that starts the string
            portion.</param>
            <param name='endIndex'>The index of the string that ends the string
            portion. The length will be index + endIndex - 1.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the string portion.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:System.FormatException'>The string portion is empty or in
            an invalid format.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromSubstring(System.Char[],System.Int32,System.Int32)">
            <summary>Converts a portion of a sequence of <c>char</c> s to an
            arbitrary-precision integer.</summary>
            <param name='cs'>A sequence of <c>char</c> s, the desired portion
            of which describes an integer in base-10 (decimal) form. The
            desired portion of the sequence of <c>char</c> s must contain only
            basic digits 0 to 9 (U+0030 to U+0039), except that it may start
            with a minus sign ("-", U+002D) to indicate a negative number. The
            desired portion is not allowed to contain white space characters,
            including spaces. The desired portion may start with any number of
            zeros.</param>
            <param name='index'>The index of the sequence of <c>char</c> s that
            starts the desired portion.</param>
            <param name='endIndex'>The index of the sequence of <c>char</c> s
            that ends the desired portion. The length will be index + endIndex
            - 1.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the sequence of <c>char</c> s portion.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='index'/> is less than 0, <paramref name='endIndex'/> is less
            than 0, or either is greater than the sequence's length, or
            <paramref name='endIndex'/> is less than <paramref
            name='index'/>.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='cs'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromString(System.Char[])">
            <summary>Converts a sequence of <c>char</c> s to an
            arbitrary-precision integer.</summary>
            <param name='cs'>A sequence of <c>char</c> s describing an integer
            in base-10 (decimal) form. The sequence must contain only basic
            digits 0 to 9 (U+0030 to U+0039), except that it may start with a
            minus sign ("-", U+002D) to indicate a negative number. The
            sequence is not allowed to contain white space characters,
            including spaces. The sequence may start with any number of
            zeros.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the sequence of <c>char</c> s.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='cs'/> is in an invalid format.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='cs'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromRadixString(System.Char[],System.Int32)">
            <summary>Converts a sequence of <c>char</c> s to an
            arbitrary-precision integer in a given radix.</summary>
            <param name='cs'>A sequence of <c>char</c> s described by the
            FromRadixSubstring method.</param>
            <param name='radix'>A base from 2 to 36. Depending on the radix,
            the sequence of <c>char</c> s can use the basic digits 0 to 9
            (U+0030 to U+0039) and then the basic upper-case letters A to Z
            (U+0041 to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F
            in radix 16. Where a basic upper-case letter A to Z is allowed in
            the sequence of <c>char</c> s, the corresponding basic lower-case
            letter (U+0061 to U+007a) is allowed instead.</param>
            <returns>An arbitrary-precision integer with the same value as the
            given sequence of <c>char</c> s.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='cs'/> is null.</exception>
            <exception cref='T:System.FormatException'>The sequence of <c>char</c> s is
            empty or in an invalid format.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromRadixSubstring(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>Converts a portion of a sequence of <c>char</c> s to an
            arbitrary-precision integer in a given radix.</summary>
            <param name='cs'>A text sequence of <c>char</c> s. The desired
            portion of the sequence of <c>char</c> s must contain only
            characters allowed by the given radix, except that it may start
            with a minus sign ("-", U+002D) to indicate a negative number. The
            desired portion is not allowed to contain white space characters,
            including spaces. The desired portion may start with any number of
            zeros.</param>
            <param name='radix'>A base from 2 to 36. Depending on the radix,
            the sequence of <c>char</c> s can use the basic digits 0 to 9
            (U+0030 to U+0039) and then the basic upper-case letters A to Z
            (U+0041 to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F
            in radix 16. Where a basic upper-case letter A to Z is allowed in
            the sequence of <c>char</c> s, the corresponding basic lower-case
            letter (U+0061 to U+007a) is allowed instead.</param>
            <param name='index'>The index of the sequence of <c>char</c> s that
            starts the desired portion.</param>
            <param name='endIndex'>The index of the sequence of <c>char</c> s
            that ends the desired portion. The length will be index + endIndex
            - 1.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the sequence's portion.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='cs'/> is null.</exception>
            <exception cref='T:System.FormatException'>The portion is empty or in an
            invalid format.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromSubstring(System.Byte[],System.Int32,System.Int32)">
            <summary>Converts a portion of a sequence of bytes (interpreted as
            text) to an arbitrary-precision integer. Each byte in the sequence
            has to be a character in the Basic Latin range (0x00 to 0x7f or
            U+0000 to U+007F) of the Unicode Standard.</summary>
            <param name='bytes'>A sequence of bytes (interpreted as text), the
            desired portion of which describes an integer in base-10 (decimal)
            form. The desired portion of the sequence of bytes (interpreted as
            text) must contain only basic digits 0 to 9 (U+0030 to U+0039),
            except that it may start with a minus sign ("-", U+002D) to
            indicate a negative number. The desired portion is not allowed to
            contain white space characters, including spaces. The desired
            portion may start with any number of zeros.</param>
            <param name='index'>The index of the sequence of bytes (interpreted
            as text) that starts the desired portion.</param>
            <param name='endIndex'>The index of the sequence of bytes
            (interpreted as text) that ends the desired portion. The length
            will be index + endIndex - 1.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the sequence of bytes (interpreted as text)
            portion.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='index'/> is less than 0, <paramref name='endIndex'/> is less
            than 0, or either is greater than the sequence's length, or
            <paramref name='endIndex'/> is less than <paramref
            name='index'/>.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromString(System.Byte[])">
            <summary>Converts a sequence of bytes (interpreted as text) to an
            arbitrary-precision integer. Each byte in the sequence has to be a
            code point in the Basic Latin range (0x00 to 0x7f or U+0000 to
            U+007F) of the Unicode Standard.</summary>
            <param name='bytes'>A sequence of bytes describing an integer in
            base-10 (decimal) form. The sequence must contain only basic digits
            0 to 9 (U+0030 to U+0039), except that it may start with a minus
            sign ("-", U+002D) to indicate a negative number. The sequence is
            not allowed to contain white space characters, including spaces.
            The sequence may start with any number of zeros.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the sequence of bytes.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='bytes'/> is in an invalid format.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromRadixString(System.Byte[],System.Int32)">
            <summary>Converts a sequence of bytes (interpreted as text) to an
            arbitrary-precision integer in a given radix. Each byte in the
            sequence has to be a character in the Basic Latin range (0x00 to
            0x7f or U+0000 to U+007F) of the Unicode Standard.</summary>
            <param name='bytes'>A sequence of bytes (interpreted as text)
            described by the FromRadixSubstring method.</param>
            <param name='radix'>A base from 2 to 36. Depending on the radix,
            the sequence of bytes can use the basic digits 0 to 9 (U+0030 to
            U+0039) and then the basic upper-case letters A to Z (U+0041 to
            U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix
            16. Where a basic upper-case letter A to Z is allowed in the
            sequence of bytes, the corresponding basic lower-case letter
            (U+0061 to U+007a) is allowed instead.</param>
            <returns>An arbitrary-precision integer with the same value as the
            given sequence of bytes.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.FormatException'>The sequence of bytes
            (interpreted as text) is empty or in an invalid format.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromRadixSubstring(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Converts a portion of a sequence of bytes (interpreted as
            text) to an arbitrary-precision integer in a given radix. Each byte
            in the sequence has to be a character in the Basic Latin range
            (0x00 to 0x7f or U+0000 to U+007F) of the Unicode
            Standard.</summary>
            <param name='bytes'>A sequence of bytes (interpreted as text). The
            desired portion of the sequence of bytes (interpreted as text) must
            contain only characters allowed by the given radix, except that it
            may start with a minus sign ("-", U+002D) to indicate a negative
            number. The desired portion is not allowed to contain white space
            characters, including spaces. The desired portion may start with
            any number of zeros.</param>
            <param name='radix'>A base from 2 to 36. Depending on the radix,
            the sequence of bytes (interpreted as text) can use the basic
            digits 0 to 9 (U+0030 to U+0039) and then the basic upper-case
            letters A to Z (U+0041 to U+005A). For example, 0-9 in radix 10,
            and 0-9, then A-F in radix 16. Where a basic upper-case letter A to
            Z is allowed in the sequence of bytes (interpreted as text), the
            corresponding basic lower-case letter (U+0061 to U+007a) is allowed
            instead.</param>
            <param name='index'>The index of the sequence of bytes (interpreted
            as text) that starts the desired portion.</param>
            <param name='endIndex'>The index of the sequence of bytes
            (interpreted as text) that ends the desired portion. The length
            will be index + endIndex - 1.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the sequence's portion.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.FormatException'>The portion is empty or in an
            invalid format.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromString(System.String)">
            <summary>Converts a string to an arbitrary-precision
            integer.</summary>
            <param name='str'>A text string describing an integer in base-10
            (decimal) form. The string must contain only basic digits 0 to 9
            (U+0030 to U+0039), except that it may start with a minus sign
            ("-", U+002D) to indicate a negative number. The string is not
            allowed to contain white space characters, including spaces. The
            string may start with any number of zeros.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the string.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='str'/> is in an invalid format.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromSubstring(System.String,System.Int32,System.Int32)">
            <summary>Converts a portion of a string to an arbitrary-precision
            integer.</summary>
            <param name='str'>A text string, the desired portion of which
            describes an integer in base-10 (decimal) form. The desired portion
            of the string must contain only basic digits 0 to 9 (U+0030 to
            U+0039), except that it may start with a minus sign ("-", U+002D)
            to indicate a negative number. The desired portion is not allowed
            to contain white space characters, including spaces. The desired
            portion may start with any number of zeros.</param>
            <param name='index'>The index of the string that starts the string
            portion.</param>
            <param name='endIndex'>The index of the string that ends the string
            portion. The length will be index + endIndex - 1.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the string portion.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='index'/> is less than 0, <paramref name='endIndex'/> is less
            than 0, or either is greater than the string's length, or <paramref
            name='endIndex'/> is less than <paramref
            name='index'/>.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Abs">
            <summary>Returns the absolute value of this object's
            value.</summary>
            <returns>This object's value with the sign removed.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Add(PeterO.Numbers.EInteger)">
            <summary>Adds this arbitrary-precision integer and another
            arbitrary-precision integer and returns the result.</summary>
            <param name='bigintAugend'>Another arbitrary-precision
            integer.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision integer plus another arbitrary-precision
            integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigintAugend'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.AsInt32Checked">
            <summary>Converts this object's value to a 32-bit signed integer,
            throwing an exception if it can't fit.</summary>
            <returns>A 32-bit signed integer.</returns>
            <exception cref=' T:System.OverflowException'>This object's value
            is too big to fit a 32-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.AsInt32Unchecked">
            <summary>Converts this object's value to a 32-bit signed integer.
            If the value can't fit in a 32-bit integer, returns the lower 32
            bits of this object's two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) (in
            which case the return value might have a different sign than this
            object's value).</summary>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.AsInt64Checked">
            <summary>Converts this object's value to a 64-bit signed integer,
            throwing an exception if it can't fit.</summary>
            <returns>A 64-bit signed integer.</returns>
            <exception cref=' T:System.OverflowException'>This object's value
            is too big to fit a 64-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.AsInt64Unchecked">
            <summary>Converts this object's value to a 64-bit signed integer.
            If the value can't fit in a 64-bit integer, returns the lower 64
            bits of this object's two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) (in
            which case the return value might have a different sign than this
            object's value).</summary>
            <returns>A 64-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.CanFitInInt32">
            <summary>Returns whether this object's value can fit in a 32-bit
            signed integer.</summary>
            <returns><c>true</c> if this object's value is from -2147483648
            through 2147483647; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.CanFitInInt64">
            <summary>Returns whether this object's value can fit in a 64-bit
            signed integer.</summary>
            <returns><c>true</c> if this object's value is from
            -9223372036854775808 through 9223372036854775807; otherwise,
            <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.CompareTo(PeterO.Numbers.EInteger)">
            <summary>Compares an arbitrary-precision integer with this
            instance.</summary>
            <param name='other'>The integer to compare to this value.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.CompareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Max(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Returns the greater of two arbitrary-precision
            integers.</summary>
            <param name='first'>The first integer to compare.</param>
            <param name='second'>The second integer to compare.</param>
            <returns>The greater of the two integers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Min(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Returns the smaller of two arbitrary-precision
            integers.</summary>
            <param name='first'>The first integer to compare.</param>
            <param name='second'>The second integer to compare.</param>
            <returns>The smaller of the two integers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.MaxMagnitude(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Of two arbitrary-precision integers, returns the one with
            the greater absolute value. If both integers have the same absolute
            value, this method has the same effect as Max.</summary>
            <param name='first'>The first integer to compare.</param>
            <param name='second'>The second integer to compare.</param>
            <returns>The integer with the greater absolute value.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.MinMagnitude(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Of two arbitrary-precision integers, returns the one with
            the smaller absolute value. If both integers have the same absolute
            value, this method has the same effect as Min.</summary>
            <param name='first'>The first integer to compare.</param>
            <param name='second'>The second integer to compare.</param>
            <returns>The integer with the smaller absolute value.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Add(System.Int32)">
            <summary>Adds this arbitrary-precision integer and a 32-bit signed
            integer and returns the result.</summary>
            <param name='intValue'>The parameter <paramref name='intValue'/> is
            a 32-bit signed integer.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision integer plus a 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Subtract(System.Int32)">
            <summary>Subtracts a 32-bit signed integer from this
            arbitrary-precision integer and returns the result.</summary>
            <param name='intValue'>The parameter <paramref name='intValue'/> is
            a 32-bit signed integer.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision integer minus a 32-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Multiply(System.Int32)">
            <summary>Multiplies this arbitrary-precision integer by a 32-bit
            signed integer and returns the result.</summary>
            <param name='intValue'>The parameter <paramref name='intValue'/> is
            a 32-bit signed integer.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision integer times a 32-bit signed
            integer.</returns>
            <example>
            <code>EInteger result = EInteger.FromString("5").Multiply(200);</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Divide(System.Int32)">
            <summary>Divides this arbitrary-precision integer by a 32-bit
            signed integer and returns the result. The result of the division
            is rounded down (the fractional part is discarded). Except if the
            result of the division is 0, it will be negative if this
            arbitrary-precision integer is positive and the other 32-bit signed
            integer is negative, or vice versa, and will be positive if both
            are positive or both are negative.</summary>
            <param name='intValue'>The divisor.</param>
            <returns>The result of dividing this arbitrary-precision integer by
            a 32-bit signed integer. The result of the division is rounded down
            (the fractional part is discarded). Except if the result of the
            division is 0, it will be negative if this arbitrary-precision
            integer is positive and the other 32-bit signed integer is
            negative, or vice versa, and will be positive if both are positive
            or both are negative.</returns>
            <exception cref='T:System.DivideByZeroException'>Attempted to divide by
            zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Remainder(System.Int32)">
            <summary>Returns the remainder that would result when this
            arbitrary-precision integer is divided by a 32-bit signed integer.
            The remainder is the number that remains when the absolute value of
            this arbitrary-precision integer is divided by the absolute value
            of the other 32-bit signed integer; the remainder has the same sign
            (positive or negative) as this arbitrary-precision
            integer.</summary>
            <param name='intValue'>The parameter <paramref name='intValue'/> is
            a 32-bit signed integer.</param>
            <returns>The remainder that would result when this
            arbitrary-precision integer is divided by a 32-bit signed
            integer.</returns>
            <exception cref='T:System.DivideByZeroException'>Attempted to divide by
            zero.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='intValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.CompareTo(System.Int32)">
            <summary>Compares an arbitrary-precision integer with this
            instance.</summary>
            <param name='intValue'>The parameter <paramref name='intValue'/> is
            a 32-bit signed integer.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Divide(PeterO.Numbers.EInteger)">
            <summary>Divides this arbitrary-precision integer by another
            arbitrary-precision integer and returns the result. The result of
            the division is rounded down (the fractional part is discarded).
            Except if the result of the division is 0, it will be negative if
            this arbitrary-precision integer is positive and the other
            arbitrary-precision integer is negative, or vice versa, and will be
            positive if both are positive or both are negative.</summary>
            <param name='bigintDivisor'>The divisor.</param>
            <returns>The result of dividing this arbitrary-precision integer by
            another arbitrary-precision integer. The result of the division is
            rounded down (the fractional part is discarded). Except if the
            result of the division is 0, it will be negative if this
            arbitrary-precision integer is positive and the other
            arbitrary-precision integer is negative, or vice versa, and will be
            positive if both are positive or both are negative.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigintDivisor'/> is null.</exception>
            <exception cref='T:System.DivideByZeroException'>Attempted to divide by
            zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.DivRem(System.Int32)">
            <summary>Divides this arbitrary-precision integer by a 32-bit
            signed integer and returns a two-item array containing the result
            of the division and the remainder, in that order. The result of the
            division is rounded down (the fractional part is discarded). Except
            if the result of the division is 0, it will be negative if this
            arbitrary-precision integer is positive and the other 32-bit signed
            integer is negative, or vice versa, and will be positive if both
            are positive or both are negative. The remainder is the number that
            remains when the absolute value of this arbitrary-precision integer
            is divided by the absolute value of the other 32-bit signed
            integer; the remainder has the same sign (positive or negative) as
            this arbitrary-precision integer.</summary>
            <param name='intDivisor'>The number to divide by.</param>
            <returns>An array of two items: the first is the result of the
            division as an arbitrary-precision integer, and the second is the
            remainder as an arbitrary-precision integer. The result of division
            is the result of the Divide method on the two operands, and the
            remainder is the result of the Remainder method on the two
            operands.</returns>
            <exception cref='T:System.DivideByZeroException'>The parameter <paramref
            name='intDivisor'/> is 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Add(System.Int64)">
            <summary>Adds this arbitrary-precision integer and a 64-bit signed
            integer and returns the result.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision integer plus a 64-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Subtract(System.Int64)">
            <summary>Subtracts a 64-bit signed integer from this
            arbitrary-precision integer and returns the result.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision integer minus a 64-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Multiply(System.Int64)">
            <summary>Multiplies this arbitrary-precision integer by a 64-bit
            signed integer and returns the result.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision integer times a 64-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Divide(System.Int64)">
            <summary>Divides this arbitrary-precision integer by a 64-bit
            signed integer and returns the result. The result of the division
            is rounded down (the fractional part is discarded). Except if the
            result of the division is 0, it will be negative if this
            arbitrary-precision integer is positive and the other 64-bit signed
            integer is negative, or vice versa, and will be positive if both
            are positive or both are negative.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The result of dividing this arbitrary-precision integer by
            a 64-bit signed integer. The result of the division is rounded down
            (the fractional part is discarded). Except if the result of the
            division is 0, it will be negative if this arbitrary-precision
            integer is positive and the other 64-bit signed integer is
            negative, or vice versa, and will be positive if both are positive
            or both are negative.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Remainder(System.Int64)">
            <summary>Returns the remainder that would result when this
            arbitrary-precision integer is divided by a 64-bit signed integer.
            The remainder is the number that remains when the absolute value of
            this arbitrary-precision integer is divided by the absolute value
            of the other 64-bit signed integer; the remainder has the same sign
            (positive or negative) as this arbitrary-precision
            integer.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The remainder that would result when this
            arbitrary-precision integer is divided by a 64-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.CompareTo(System.Int64)">
            <summary>Compares an arbitrary-precision integer with this
            instance.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.DivRem(System.Int64)">
            <summary>Divides this arbitrary-precision integer by a 64-bit
            signed integer and returns a two-item array containing the result
            of the division and the remainder, in that order. The result of the
            division is rounded down (the fractional part is discarded). Except
            if the result of the division is 0, it will be negative if this
            arbitrary-precision integer is positive and the other 64-bit signed
            integer is negative, or vice versa, and will be positive if both
            are positive or both are negative. The remainder is the number that
            remains when the absolute value of this arbitrary-precision integer
            is divided by the absolute value of the other 64-bit signed
            integer; the remainder has the same sign (positive or negative) as
            this arbitrary-precision integer.</summary>
            <param name='intDivisor'>The parameter <paramref
            name='intDivisor'/> is a 64-bit signed integer.</param>
            <returns>An array of two items: the first is the result of the
            division as an arbitrary-precision integer, and the second is the
            remainder as an arbitrary-precision integer. The result of division
            is the result of the Divide method on the two operands, and the
            remainder is the result of the Remainder method on the two
            operands.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.DivRem(PeterO.Numbers.EInteger)">
            <summary>Divides this arbitrary-precision integer by another
            arbitrary-precision integer and returns a two-item array containing
            the result of the division and the remainder, in that order. The
            result of the division is rounded down (the fractional part is
            discarded). Except if the result of the division is 0, it will be
            negative if this arbitrary-precision integer is positive and the
            other arbitrary-precision integer is negative, or vice versa, and
            will be positive if both are positive or both are negative. The
            remainder is the number that remains when the absolute value of
            this arbitrary-precision integer is divided by the absolute value
            of the other arbitrary-precision integer; the remainder has the
            same sign (positive or negative) as this arbitrary-precision
            integer.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>An array of two items: the first is the result of the
            division as an arbitrary-precision integer, and the second is the
            remainder as an arbitrary-precision integer. The result of division
            is the result of the Divide method on the two operands, and the
            remainder is the result of the Remainder method on the two
            operands.</returns>
            <exception cref='T:System.DivideByZeroException'>The parameter <paramref
            name='divisor'/> is 0.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='divisor'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Equals(System.Object)">
            <summary>Determines whether this object and another object are
            equal and have the same type.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if this object and another object are equal;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Gcd(PeterO.Numbers.EInteger)">
            <summary>Returns the greatest common divisor of this integer and
            the given integer. The greatest common divisor (GCD) is also known
            as the greatest common factor (GCF). This method works even if
            either or both integers are negative.</summary>
            <param name='bigintSecond'>Another arbitrary-precision integer. Can
            be negative.</param>
            <returns>The greatest common divisor of this integer and the given
            integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigintSecond'/> is null.</exception>
            <exception cref='T:System.DivideByZeroException'>Attempted to divide by
            zero.</exception>
            <exception cref='T:System.ArgumentException'>BigPower is
            negative.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetDigitCountAsEInteger">
            <summary>Returns the number of decimal digits used by this integer,
            in the form of an arbitrary-precision integer.</summary>
            <returns>The number of digits in the decimal form of this integer.
            Returns 1 if this number is 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetDigitCount">
            <summary>Returns the number of decimal digits used by this
            integer.</summary>
            <returns>The number of digits in the decimal form of this integer.
            Returns 1 if this number is 0.</returns>
            <exception cref='T:System.OverflowException'>The return value would exceed
            the range of a 32-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetDigitCountAsInt64">
            <summary>Returns the number of decimal digits used by this integer,
            in the form of a 64-bit signed integer.</summary>
            <returns>The number of digits in the decimal form of this integer.
            Returns 1 if this number is 0. Returns 2^63 - 1(
            <c>Int64.MaxValue</c> in.NET or <c>Long.MAX_VALUE</c> in Java) if
            the number of decimal digits is 2^63 - 1 or greater. (Use
            <c>GetDigitCountAsEInteger</c> instead if the application relies on
            the exact number of decimal digits.).</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetHashCode">
            <summary>Returns the hash code for this instance. No application or
            process IDs are used in the hash code calculation.</summary>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetLowBit">
            <summary>Gets the bit position of the lowest set bit in this
            number's absolute value. (This will also be the position of the
            lowest set bit in the number's two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see>
            ).).</summary>
            <returns>The bit position of the lowest bit set in the number's
            absolute value, starting at 0. Returns -1 if this value is
            0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetLowBitAsInt64">
            <summary>Gets the bit position of the lowest set bit in this
            number's absolute value, in the form of a 64-bit signed integer.
            (This will also be the position of the lowest set bit in the
            number's two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see>
            ).).</summary>
            <returns>The bit position of the lowest bit set in the number's
            absolute value, starting at 0. Returns -1 if this value is 0 or
            odd. Returns 2^63 - 1 ( <c>Int64.MaxValue</c> in.NET or
            <c>Long.MAX_VALUE</c> in Java) if this number is other than zero
            but the lowest set bit is at 2^63 - 1 or greater. (Use
            <c>GetLowBitAsEInteger</c> instead if the application relies on the
            exact value of the lowest set bit position.).</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetLowBitAsEInteger">
            <summary>Gets the bit position of the lowest set bit in this
            number's absolute value, in the form of an arbitrary-precision
            integer. (This will also be the position of the lowest set bit in
            the number's two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see>
            ).).</summary>
            <returns>The bit position of the lowest bit set in the number's
            absolute value, starting at 0. Returns -1 if this value is 0 or
            odd.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetSignedBit(PeterO.Numbers.EInteger)">
            <summary>Returns whether a bit is set in the two's-complement form
            (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
            this object's value.</summary>
            <param name='bigIndex'>The index, starting at zero, of the bit to
            test, where 0 is the least significant bit, 1 is the next least
            significant bit, and so on.</param>
            <returns><c>true</c> if the given bit is set in the two'
            s-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
            this object's value; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigIndex'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetSignedBit(System.Int32)">
            <summary>Returns whether a bit is set in the two's-complement form
            (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
            this object's value.</summary>
            <param name='index'>The index, starting at 0, of the bit to test,
            where 0 is the least significant bit, 1 is the next least
            significant bit, and so on.</param>
            <returns><c>true</c> if the given bit is set in the two'
            s-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
            this object's value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetSignedBitLengthAsEInteger">
            <summary>Finds the minimum number of bits needed to represent this
            object's value, except for its sign, and returns that number of
            bits as an arbitrary-precision integer. If the value is negative,
            finds the number of bits in the value equal to this object's
            absolute value minus 1. For example, all integers in the interval
            [-(2^63), (2^63) - 1], which is the same as the range of integers
            in Java's and.NET's <c>long</c> type, have a signed bit length of
            63 or less, and all other integers have a signed bit length of
            greater than 63.</summary>
            <returns>The number of bits in this object's value, except for its
            sign. Returns 0 if this object's value is 0 or negative
            1.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetSignedBitLengthAsInt64">
            <summary>Finds the minimum number of bits needed to represent this
            object's value, except for its sign, and returns that number of
            bits as a 64-bit signed integer. If the value is negative, finds
            the number of bits in the value equal to this object's absolute
            value minus 1. For example, all integers in the interval [-(2^63),
            (2^63) - 1], which is the same as the range of integers in Java's
            and.NET's <c>long</c> type, have a signed bit length of 63 or less,
            and all other integers have a signed bit length of greater than
            63.</summary>
            <returns>The number of bits in this object's value, except for its
            sign. Returns 0 if this object's value is 0 or negative 1. If the
            return value would be greater than 2^63 - 1 ( <c>Int64.MaxValue</c>
            in.NET or <c>Long.MAX_VALUE</c> in Java), returns 2^63 - 1 instead.
            (Use <c>GetSignedBitLengthAsEInteger</c> instead of this method if
            the application relies on the exact number of bits.).</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetSignedBitLength">
            <summary>Finds the minimum number of bits needed to represent this
            object's value, except for its sign. If the value is negative,
            finds the number of bits in the value equal to this object's
            absolute value minus 1. For example, all integers in the interval
            [-(2^63), (2^63) - 1], which is the same as the range of integers
            in Java's and.NET's <c>long</c> type, have a signed bit length of
            63 or less, and all other integers have a signed bit length of
            greater than 63.</summary>
            <returns>The number of bits in this object's value, except for its
            sign. Returns 0 if this object's value is 0 or negative
            1.</returns>
            <exception cref='T:System.OverflowException'>The return value would exceed
            the range of a 32-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetUnsignedBit(PeterO.Numbers.EInteger)">
            <summary>Returns whether a bit is set in this number's absolute
            value.</summary>
            <param name='bigIndex'>The index, starting at zero, of the bit to
            test, where 0 is the least significant bit, 1 is the next least
            significant bit, and so on.</param>
            <returns><c>true</c> if the given bit is set in this number's
            absolute value.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigIndex'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetUnsignedBit(System.Int32)">
            <summary>Returns whether a bit is set in this number's absolute
            value.</summary>
            <param name='index'>The index, starting at 0, of the bit to test,
            where 0 is the least significant bit, 1 is the next least
            significant bit, and so on.</param>
            <returns><c>true</c> if the given bit is set in this number's
            absolute value.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetUnsignedBitLengthAsEInteger">
            <summary>Finds the minimum number of bits needed to represent this
            number's absolute value, and returns that number of bits as an
            arbitrary-precision integer. For example, all integers in the
            interval [-((2^63) - 1), (2^63) - 1] have an unsigned bit length of
            63 or less, and all other integers have an unsigned bit length of
            greater than 63. This interval is not the same as the range of
            integers in Java's and.NET's <c>long</c> type.</summary>
            <returns>The number of bits in this object's absolute value.
            Returns 0 if this object's value is 0, and returns 1 if the value
            is negative 1.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetUnsignedBitLengthAsInt64">
            <summary>Finds the minimum number of bits needed to represent this
            number's absolute value, and returns that number of bits as a
            64-bit signed integer. For example, all integers in the interval
            [-((2^63) - 1), (2^63) - 1] have an unsigned bit length of 63 or
            less, and all other integers have an unsigned bit length of greater
            than 63. This interval is not the same as the range of integers in
            Java's and.NET's <c>long</c> type.</summary>
            <returns>The number of bits in this object's absolute value.
            Returns 0 if this object's value is 0, and returns 1 if the value
            is negative 1. If the return value would be greater than 2^63 - 1(
            <c>Int64.MaxValue</c> in.NET or <c>Long.MAX_VALUE</c> in Java),
            returns 2^63 - 1 instead. (Use
            <c>GetUnsignedBitLengthAsEInteger</c> instead of this method if the
            application relies on the exact number of bits.).</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetUnsignedBitLength">
            <summary>Finds the minimum number of bits needed to represent this
            number's absolute value. For example, all integers in the interval
            [-((2^63) - 1), (2^63) - 1] have an unsigned bit length of 63 or
            less, and all other integers have an unsigned bit length of greater
            than 63. This interval is not the same as the range of integers in
            Java's and.NET's <c>long</c> type.</summary>
            <returns>The number of bits in this object's absolute value.
            Returns 0 if this object's value is 0, and returns 1 if the value
            is negative 1.</returns>
            <exception cref='T:System.OverflowException'>The return value would exceed
            the range of a 32-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Mod(PeterO.Numbers.EInteger)">
            <summary>Finds the modulus remainder that results when this
            instance is divided by the value of an arbitrary-precision integer.
            The modulus remainder is the same as the normal remainder if the
            normal remainder is positive, and equals divisor plus normal
            remainder if the normal remainder is negative.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='divisor'/> is less than 0.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='divisor'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Mod(System.Int32)">
            <summary>Finds the modulus remainder that results when this
            instance is divided by the value of another integer. The modulus
            remainder is the same as the normal remainder if the normal
            remainder is positive, and equals divisor plus normal remainder if
            the normal remainder is negative.</summary>
            <param name='smallDivisor'>The divisor of the modulus.</param>
            <returns>The modulus remainder.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='smallDivisor'/> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ModPow(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Calculates the remainder when this arbitrary-precision
            integer raised to a certain power is divided by another
            arbitrary-precision integer.</summary>
            <param name='pow'>The power to raise this integer by.</param>
            <param name='mod'>The integer to divide the raised number
            by.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='pow'/> or <paramref name='mod'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Multiply(PeterO.Numbers.EInteger)">
            <summary>Multiplies this arbitrary-precision integer by another
            arbitrary-precision integer and returns the result.</summary>
            <param name='bigintMult'>Another arbitrary-precision
            integer.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision integer times another arbitrary-precision
            integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigintMult'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Negate">
            <summary>Gets the value of this object with the sign
            reversed.</summary>
            <returns>This object's value with the sign reversed.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Pow(System.Int64)">
            <summary>Raises an arbitrary-precision integer to a
            power.</summary>
            <param name='longPower'>The exponent to raise this integer
            to.</param>
            <returns>The result. Returns 1 if <paramref name='longPower'/> is
            0.</returns>
            <exception cref='T:System.ArgumentException'>BigPower is
            negative.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Pow(PeterO.Numbers.EInteger)">
            <summary>Raises an arbitrary-precision integer to a
            power.</summary>
            <param name='bigPower'>The exponent to raise this integer
            to.</param>
            <returns>The result. Returns 1 if <paramref name='bigPower'/> is
            0.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigPower'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>BigPower is
            negative.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Pow(System.Int32)">
            <summary>Raises an arbitrary-precision integer to a
            power.</summary>
            <param name='powerSmall'>The exponent to raise this integer
            to.</param>
            <returns>The result. Returns 1 if <paramref name='powerSmall'/> is
            0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.PowBigIntVar(PeterO.Numbers.EInteger)">
            <summary>Raises an arbitrary-precision integer to a power, which is
            given as another arbitrary-precision integer.</summary>
            <param name='power'>The exponent to raise to.</param>
            <returns>The result. Returns 1 if <paramref name='power'/> is
            0.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='power'/> is less than 0.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='power'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Remainder(PeterO.Numbers.EInteger)">
            <summary>Returns the remainder that would result when this
            arbitrary-precision integer is divided by another
            arbitrary-precision integer. The remainder is the number that
            remains when the absolute value of this arbitrary-precision integer
            is divided by the absolute value of the other arbitrary-precision
            integer; the remainder has the same sign (positive or negative) as
            this arbitrary-precision integer.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>The remainder that would result when this
            arbitrary-precision integer is divided by another
            arbitrary-precision integer.</returns>
            <exception cref='T:System.DivideByZeroException'>Attempted to divide by
            zero.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='divisor'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ShiftRight(PeterO.Numbers.EInteger)">
            <summary>Returns an arbitrary-precision integer with the bits
            shifted to the right. For this operation, the arbitrary-precision
            integer is treated as a two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ).
            Thus, for negative values, the arbitrary-precision integer is
            sign-extended.</summary>
            <param name='eshift'>The number of bits to shift. Can be negative,
            in which case this is the same as ShiftLeft with the absolute value
            of this parameter.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='eshift'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ShiftLeft(PeterO.Numbers.EInteger)">
            <summary>Returns an arbitrary-precision integer with the bits
            shifted to the left by a number of bits given as an
            arbitrary-precision integer. A value of 1 doubles this value, a
            value of 2 multiplies it by 4, a value of 3 by 8, a value of 4 by
            16, and so on.</summary>
            <param name='eshift'>The number of bits to shift. Can be negative,
            in which case this is the same as ShiftRight with the absolute
            value of this parameter.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='eshift'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ShiftLeft(System.Int32)">
            <summary>Returns an arbitrary-precision integer with the bits
            shifted to the left by a number of bits. A value of 1 doubles this
            value, a value of 2 multiplies it by 4, a value of 3 by 8, a value
            of 4 by 16, and so on.</summary>
            <param name='numberBits'>The number of bits to shift. Can be
            negative, in which case this is the same as shiftRight with the
            absolute value of this parameter.</param>
            <returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Not">
            <summary>Returns an arbitrary-precision integer with every bit
            flipped from this one (also called an inversion or NOT
            operation).</summary>
            <returns>An arbitrary-precision integer in which each bit in its
            two's complement representation is set if the corresponding bit of
            this integer is clear, and vice versa. Returns -1 if this integer
            is 0. If this integer is positive, the return value is negative,
            and vice versa. This method uses the two's complement form of
            negative integers (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
            example, in binary, NOT 10100 = ...11101011 (or in decimal, NOT 20
            = -21). In binary, NOT ...11100110 = 11001 (or in decimal, NOT -26
            = 25).</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.LowBits(System.Int64)">
            <summary>Extracts the lowest bits of this integer. This is
            equivalent to <c>And(2^longBitCount - 1)</c>, but is more
            efficient when this integer is non-negative and longBitCount's
            value is large.</summary>
            <param name='longBitCount'>The number of bits to extract from the
            lowest part of this integer.</param>
            <returns>A value equivalent to <c>And(2^longBitCount - 1)</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.LowBits(System.Int32)">
            <summary>Extracts the lowest bits of this integer. This is
            equivalent to <c>And(2^bitCount - 1)</c>, but is more efficient
            when this integer is non-negative and bitCount's value is
            large.</summary>
            <param name='bitCount'>The number of bits to extract from the
            lowest part of this integer.</param>
            <returns>A value equivalent to <c>And(2^bitCount - 1)</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.LowBits(PeterO.Numbers.EInteger)">
            <summary>Extracts the lowest bits of this integer. This is
            equivalent to <c>And(2^bigBitCount - 1)</c>, but is more efficient
            when this integer is non-negative and bigBitCount's value is
            large.</summary>
            <param name='bigBitCount'>The number of bits to extract from the
            lowest part of this integer.</param>
            <returns>A value equivalent to <c>And(2^bigBitCount - 1)</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigBitCount'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.And(PeterO.Numbers.EInteger)">
            <summary>Does an AND operation between this arbitrary-precision
            integer and another one.</summary>
            <param name='other'>Another arbitrary-precision integer that
            participates in the operation.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            the corresponding bits of this integer and the other integer (in
            their two's-complement representation) are both set. For example,
            in binary, 10110 AND 01100 = 00100 (or in decimal, 22 AND 12 = 4).
            This method uses the two's complement form of negative integers
            (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
            example, in binary, ...11100111 AND 01100 = 00100 (or in decimal,
            -25 AND 12 = 4).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='other'/> is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Or(PeterO.Numbers.EInteger)">
            <summary>Does an OR operation between this arbitrary-precision
            integer and another one.</summary>
            <param name='second'>Another arbitrary-precision integer that
            participates in the operation.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            the corresponding bit of this integer is set, the other integer's
            corresponding bit is set, or both. For example, in binary, 10110 OR
            11010 = 11110 (or in decimal, 22 OR 26 = 30). This method uses the
            two's complement form of negative integers (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
            example, in binary, ...11101110 OR 01011 = ...11101111 (or in
            decimal, -18 OR 11 = -17).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='second'/> is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.AndNot(PeterO.Numbers.EInteger)">
            <summary>Does an AND NOT operation between this arbitrary-precision
            integer and another one.</summary>
            <param name='second'>Another arbitrary-precision integer that
            participates in the operation.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            the corresponding bit of this integer is set, and the other
            integer's corresponding bit is
            <i>not</i> set. For example, in binary, 10110 AND NOT 11010 = 00100
            (or in decimal, 22 AND NOT 26 = 4). This method uses the two's
            complement form of negative integers (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
            example, in binary, ...11101110 AND NOT 01011 = 00100 (or in
            decimal, -18 OR 11 = 4).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='second'/> is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.OrNot(PeterO.Numbers.EInteger)">
            <summary>Does an OR NOT operation between this arbitrary-precision
            integer and another one.</summary>
            <param name='second'>Another arbitrary-precision integer that
            participates in the operation.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            the corresponding bit of this integer is set, the other integer's
            corresponding bit is
            <i>not</i> set, or both. For example, in binary, 10110 OR NOT 11010
            = 00100 (or in decimal, 22 OR NOT 26 = 23). This method uses the
            two's complement form of negative integers (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
            example, in binary, ...11101110 OR NOT 01011 = ...11111110 (or in
            decimal, -18 OR 11 = -2).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='second'/> is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Imp(PeterO.Numbers.EInteger)">
            <summary>Does an OR NOT operation between this arbitrary-precision
            integer and another one.</summary>
            <param name='second'>Another arbitrary-precision integer that
            participates in the operation.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            the corresponding bit of this integer is set, the other integer's
            corresponding bit is
            <i>not</i> set, or both. For example, in binary, 10110 OR NOT 11010
            = 00100 (or in decimal, 22 OR NOT 26 = 23). This method uses the
            two's complement form of negative integers (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
            example, in binary, ...11101110 OR NOT 01011 = ...11111110 (or in
            decimal, -18 OR 11 = -2).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='second'/> is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.XorNot(PeterO.Numbers.EInteger)">
            <summary>Does an XOR NOT operation (or equivalence operation, EQV
            operation, or exclusive-OR NOT operation) between this
            arbitrary-precision integer and another one.</summary>
            <param name='second'>Another arbitrary-precision integer that
            participates in the operation.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            the corresponding bit of this integer is set or the other integer's
            corresponding bit is
            <i>not</i> set, but not both. For example, in binary, 10110 XOR NOT
            11010 = 10011 (or in decimal, 22 XOR NOT 26 = 19). This method uses
            the two's complement form of negative integers (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
            example, in binary, ...11101110 XOR NOT 01011 = ...11111010 (or in
            decimal, -18 OR 11 = -6).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='second'/> is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Eqv(PeterO.Numbers.EInteger)">
            <summary>Does an XOR NOT operation (or equivalence operation, EQV
            operation, or exclusive-OR NOT operation) between this
            arbitrary-precision integer and another one.</summary>
            <param name='second'>Another arbitrary-precision integer that
            participates in the operation.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            the corresponding bit of this integer is set or the other integer's
            corresponding bit is
            <i>not</i> set, but not both. For example, in binary, 10110 XOR NOT
            11010 = 10011 (or in decimal, 22 XOR NOT 26 = 19). This method uses
            the two's complement form of negative integers (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
            example, in binary, ...11101110 XOR NOT 01011 = ...11111010 (or in
            decimal, -18 OR 11 = -6).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='second'/> is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Xor(PeterO.Numbers.EInteger)">
            <summary>Does an exclusive OR (XOR) operation between this
            arbitrary-precision integer and another one.</summary>
            <param name='other'>Another arbitrary-precision integer that
            participates in the operation.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            the corresponding bit is set in one input integer but not in the
            other. For example, in binary, 11010 XOR 01001 = 10011 (or in
            decimal, 26 XOR 9 = 19). This method uses the two's complement form
            of negative integers (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
            example, in binary, ...11101101 XOR 00011 = ...11101110 (or in
            decimal, -19 XOR 3 = -18).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='other'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ShiftRight(System.Int32)">
            <summary>Returns an arbitrary-precision integer with the bits
            shifted to the right. For this operation, the arbitrary-precision
            integer is treated as a two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ).
            Thus, for negative values, the arbitrary-precision integer is
            sign-extended.</summary>
            <param name='numberBits'>The number of bits to shift. Can be
            negative, in which case this is the same as shiftLeft with the
            absolute value of this parameter.</param>
            <returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Sqrt">
            <summary>Finds the square root of this instance's value, rounded
            down.</summary>
            <returns>The square root of this object's value. Returns 0 if this
            value is 0 or less.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.SqrtRem">
            <summary>Calculates the square root and the remainder.</summary>
            <returns>An array of two arbitrary-precision integers: the first
            integer is the square root, and the second is the difference
            between this value and the square of the first integer. Returns two
            zeros if this value is 0 or less, or one and zero if this value
            equals 1.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Root(PeterO.Numbers.EInteger)">
            <summary>Finds the nth root of this instance's value, rounded
            down.</summary>
            <param name='root'>The root to find; must be 1 or greater. If this
            value is 2, this method finds the square root; if 3, the cube root,
            and so on.</param>
            <returns>The square root of this object's value. Returns 0 if this
            value is 0 or less.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='root'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.RootRem(PeterO.Numbers.EInteger)">
            <summary>Calculates the nth root and the remainder.</summary>
            <param name='root'>The root to find; must be 1 or greater. If this
            value is 2, this method finds the square root; if 3, the cube root,
            and so on.</param>
            <returns>An array of two arbitrary-precision integers: the first
            integer is the nth root, and the second is the difference between
            this value and the nth power of the first integer. Returns two
            zeros if this value is 0 or less, or one and zero if this value
            equals 1.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='root'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Root(System.Int32)">
            <summary>Finds the nth root of this instance's value, rounded
            down.</summary>
            <param name='root'>The root to find; must be 1 or greater. If this
            value is 2, this method finds the square root; if 3, the cube root,
            and so on.</param>
            <returns>The square root of this object's value. Returns 0 if this
            value is 0 or less.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.RootRem(System.Int32)">
            <summary>Calculates the nth root and the remainder.</summary>
            <param name='root'>The root to find; must be 1 or greater. If this
            value is 2, this method finds the square root; if 3, the cube root,
            and so on.</param>
            <returns>An array of two arbitrary-precision integers: the first
            integer is the nth root, and the second is the difference between
            this value and the nth power of the first integer. Returns two
            zeros if this value is 0 or less, or one and zero if this value
            equals 1.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Subtract(PeterO.Numbers.EInteger)">
            <summary>Subtracts an arbitrary-precision integer from this
            arbitrary-precision integer and returns the result.</summary>
            <param name='subtrahend'>Another arbitrary-precision
            integer.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision integer minus another arbitrary-precision
            integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='subtrahend'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToBytes(System.Boolean)">
            <summary>Returns a byte array of this integer's value. The byte
            array will take the number's two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ),
            using the fewest bytes necessary to store its value unambiguously.
            If this value is negative, the bits that appear beyond the most
            significant bit of the number will be all ones. The resulting byte
            array can be passed to the <c>FromBytes()</c> method (with the same
            byte order) to reconstruct this integer's value.</summary>
            <param name='littleEndian'>See the 'littleEndian' parameter of the
            <c>FromBytes()</c> method.</param>
            <returns>A byte array. If this value is 0, returns a byte array
            with the single element 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt32Checked">
            <summary>Converts this object's value to a 32-bit signed integer,
            throwing an exception if it can't fit.</summary>
            <returns>A 32-bit signed integer.</returns>
            <exception cref=' T:System.OverflowException'>This object's value
            is too big to fit a 32-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt32Unchecked">
            <summary>Converts this object's value to a 32-bit signed integer.
            If the value can't fit in a 32-bit integer, returns the lower 32
            bits of this object's two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) (in
            which case the return value might have a different sign than this
            object's value).</summary>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt64Checked">
            <summary>Converts this object's value to a 64-bit signed integer,
            throwing an exception if it can't fit.</summary>
            <returns>A 64-bit signed integer.</returns>
            <exception cref=' T:System.OverflowException'>This object's value
            is too big to fit a 64-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt64Unchecked">
            <summary>Converts this object's value to a 64-bit signed integer.
            If the value can't fit in a 64-bit integer, returns the lower 64
            bits of this object's two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) (in
            which case the return value might have a different sign than this
            object's value).</summary>
            <returns>A 64-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToRadixString(System.Int32)">
            <summary>Generates a string representing the value of this object,
            in the given radix.</summary>
            <param name='radix'>A radix from 2 through 36. For example, to
            generate a hexadecimal (base-16) string, specify 16. To generate a
            decimal (base-10) string, specify 10.</param>
            <returns>A string representing the value of this object. If this
            value is 0, returns "0". If negative, the string will begin with a
            minus sign ("-", U+002D). Depending on the radix, the string will
            use the basic digits 0 to 9 (U+0030 to U+0039) and then the basic
            upper-case letters A to Z (U+0041 to U+005A). For example, 0-9 in
            radix 10, and 0-9, then A-F in radix 16.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToString">
            <summary>Converts this object to a text string in base
            10.</summary>
            <returns>A string representation of this object. If this value is
            0, returns "0". If negative, the string will begin with a minus
            sign ("-", U+002D). The string will use the basic digits 0 to 9
            (U+0030 to U+0039).</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Increment">
            <summary>Returns one added to this arbitrary-precision
            integer.</summary>
            <returns>The given arbitrary-precision integer plus one.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Decrement">
            <summary>Returns one subtracted from this arbitrary-precision
            integer.</summary>
            <returns>The given arbitrary-precision integer minus one.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToByteChecked">
            <summary>Converts this number's value to a byte (from 0 to 255) if
            it can fit in a byte (from 0 to 255).</summary>
            <returns>This number's value as a byte (from 0 to 255).</returns>
            <exception cref='T:System.OverflowException'>This value is less than 0 or
            greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToByteUnchecked">
            <summary>Converts this number to a byte (from 0 to 255), returning
            the least-significant bits of this number's two's-complement
            form.</summary>
            <returns>This number, converted to a byte (from 0 to
            255).</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromByte(System.Byte)">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
            integer.</summary>
            <param name='inputByte'>The number to convert as a byte (from 0 to
            255).</param>
            <returns>This number's value as an arbitrary-precision
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt16Checked">
            <summary>Converts this number's value to a 16-bit signed integer if
            it can fit in a 16-bit signed integer.</summary>
            <returns>This number's value as a 16-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>This value is less than -32768
            or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt16Unchecked">
            <summary>Converts this number to a 16-bit signed integer, returning
            the least-significant bits of this number's two's-complement
            form.</summary>
            <returns>This number, converted to a 16-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromInt16(System.Int16)">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision
            integer.</summary>
            <param name='inputInt16'>The number to convert as a 16-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromUInt64(System.UInt64)">
            <summary>Converts a 64-bit unsigned integer to an
            arbitrary-precision integer.</summary>
            <param name='ulongValue'>The number to convert as a 64-bit unsigned
            integer.</param>
            <returns>The value of <paramref name='ulongValue'/> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Addition(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Adds an arbitrary-precision integer and another
            arbitrary-precision integer and returns the result.</summary>
            <param name='bthis'>The first operand.</param>
            <param name='augend'>The second operand.</param>
            <returns>The sum of the two numbers, that is, an
            arbitrary-precision integer plus another arbitrary-precision
            integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Subtraction(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Subtracts two arbitrary-precision integer
            values.</summary>
            <param name='bthis'>An arbitrary-precision integer.</param>
            <param name='subtrahend'>Another arbitrary-precision
            integer.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Increment(PeterO.Numbers.EInteger)">
            <summary>Adds one to an arbitrary-precision integer.</summary>
            <param name='bthis'>An arbitrary-precision integer.</param>
            <returns>The given arbitrary-precision integer plus one.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Decrement(PeterO.Numbers.EInteger)">
            <summary>Subtracts one from an arbitrary-precision
            integer.</summary>
            <param name='bthis'>An arbitrary-precision integer.</param>
            <returns>The given arbitrary-precision integer minus one.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Multiply(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Multiplies an arbitrary-precision integer by another
            arbitrary-precision integer and returns the result.</summary>
            <param name='operand1'>The first operand.</param>
            <param name='operand2'>The second operand.</param>
            <returns>The product of the two numbers, that is, an
            arbitrary-precision integer times another arbitrary-precision
            integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='operand1'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Division(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Divides an arbitrary-precision integer by the value of an
            arbitrary-precision integer object.</summary>
            <param name='dividend'>The number that will be divided by the
            divisor.</param>
            <param name='divisor'>The number to divide by.</param>
            <returns>The quotient of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='dividend'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Modulus(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Returns the remainder that would result when an
            arbitrary-precision integer is divided by another
            arbitrary-precision integer. The remainder is the number that
            remains when the absolute value of an arbitrary-precision integer
            is divided by the absolute value of the other arbitrary-precision
            integer; the remainder has the same sign (positive or negative) as
            this arbitrary-precision integer.</summary>
            <param name='dividend'>The first operand.</param>
            <param name='divisor'>The number to divide by.</param>
            <returns>The remainder that would result when an
            arbitrary-precision integer is divided by another
            arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='dividend'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_LeftShift(PeterO.Numbers.EInteger,System.Int32)">
            <summary>Returns an arbitrary-precision integer with the bits
            shifted to the left by a number of bits. A value of 1 doubles this
            value, a value of 2 multiplies it by 4, a value of 3 by 8, a value
            of 4 by 16, and so on.</summary>
            <param name='bthis'>The arbitrary-precision integer to shift
            left.</param>
            <param name='bitCount'>The number of bits to shift. Can be
            negative, in which case this is the same as shiftRight with the
            absolute value of this parameter.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ModPow(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Calculates the remainder when an arbitrary-precision
            integer raised to a certain power is divided by another
            arbitrary-precision integer.</summary>
            <param name='bigintValue'>The starting operand.</param>
            <param name='pow'>The power to raise this integer by.</param>
            <param name='mod'>The integer to divide the raised number
            by.</param>
            <returns>The value ( <paramref name='bigintValue'/> ^ <paramref
            name='pow'/> )% <paramref name='mod'/>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigintValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_RightShift(PeterO.Numbers.EInteger,System.Int32)">
            <summary>Shifts the bits of an arbitrary-precision integer to the
            right.</summary>
            <param name='bthis'>Another arbitrary-precision integer.</param>
            <param name='smallValue'>The parameter <paramref
            name='smallValue'/> is a 32-bit signed integer.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
            <remarks>For this operation, the arbitrary-precision integer is
            treated as a two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ).
            Thus, for negative values, the arbitrary-precision integer is
            sign-extended.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_UnaryNegation(PeterO.Numbers.EInteger)">
            <summary>Negates an arbitrary-precision integer.</summary>
            <param name='bigValue'>An arbitrary-precision integer to
            negate.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt64Checked">
            <summary>Converts this number's value to a 64-bit signed integer if
            it can fit in a 64-bit signed integer.</summary>
            <returns>This number's value as a 64-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>This value is outside the range
            of a 64-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt64Unchecked">
            <summary>Converts this number to a 64-bit signed integer, returning
            the least-significant bits of this number's two's-complement
            form.</summary>
            <returns>This number, converted to a 64-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_LessThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Determines whether an arbitrary-precision integer is less
            than another arbitrary-precision integer.</summary>
            <param name='thisValue'>The first arbitrary-precision
            integer.</param>
            <param name='otherValue'>The second arbitrary-precision
            integer.</param>
            <returns><c>true</c> if <paramref name='thisValue'/> is less than
            <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_LessThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Determines whether an arbitrary-precision integer is up to
            another arbitrary-precision integer.</summary>
            <param name='thisValue'>The first arbitrary-precision
            integer.</param>
            <param name='otherValue'>The second arbitrary-precision
            integer.</param>
            <returns><c>true</c> if <paramref name='thisValue'/> is up to
            <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_GreaterThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Determines whether an arbitrary-precision integer is
            greater than another arbitrary-precision integer.</summary>
            <param name='thisValue'>The first arbitrary-precision
            integer.</param>
            <param name='otherValue'>The second arbitrary-precision
            integer.</param>
            <returns><c>true</c> if <paramref name='thisValue'/> is greater
            than <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_GreaterThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Determines whether an arbitrary-precision integer value is
            greater than another arbitrary-precision integer.</summary>
            <param name='thisValue'>The first arbitrary-precision
            integer.</param>
            <param name='otherValue'>The second arbitrary-precision
            integer.</param>
            <returns><c>true</c> if <paramref name='thisValue'/> is at least
            <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_OnesComplement(PeterO.Numbers.EInteger)">
            <summary>Returns an arbitrary-precision integer with every bit
            flipped.</summary>
            <param name='thisValue'>The operand as an arbitrary-precision
            integer.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='thisValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_BitwiseAnd(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Does an AND operation between two arbitrary-precision
            integer values. For each bit of the result, that bit is 1 if the
            corresponding bits of the two operands are both 1, or is 0
            otherwise.</summary>
            <param name='thisValue'>The first operand.</param>
            <param name='otherValue'>The second operand.</param>
            <returns>The result of the operation.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter "a" or "b" is
            null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_BitwiseOr(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Does an OR operation between two arbitrary-precision
            integer instances. For each bit of the result, that bit is 1 if
            either or both of the corresponding bits of the two operands are 1,
            or is 0 otherwise.</summary>
            <param name='thisValue'>An arbitrary-precision integer.</param>
            <param name='otherValue'>Another arbitrary-precision
            integer.</param>
            <returns>The result of the operation.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter "first" or
            "second" is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_ExclusiveOr(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Finds the exclusive "or" of two arbitrary-precision
            integer objects. For each bit of the result, that bit is 1 if
            either of the corresponding bits of the two operands, but not both,
            is 1, or is 0 otherwise.
            <para>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</para></summary>
            <param name='a'>The first arbitrary-precision integer.</param>
            <param name='b'>The second arbitrary-precision integer.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            it's set in one input integer but not the other.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> or <paramref name='b'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetBits(System.Int32,System.Int32)">
            <summary>Retrieves bits from this integer's two's-complement
            form.</summary>
            <param name='index'>Zero-based index of the first bit to retrieve,
            where 0 is the least-significant bit of the number.</param>
            <param name='numberBits'>The number of bits to retrieve, starting
            with the first. Must be from 0 through 64.</param>
            <returns>A 64-bit signed integer containing the bits from this
            integer's two's-complement form. The least significant bit is the
            first bit, and any unused bits are set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.DivRem(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger@)">
            <summary>Divides this arbitrary-precision integer by another
            arbitrary-precision integer and returns a two-item array containing
            the result of the division and the remainder, in that order. The
            result of the division is rounded down (the fractional part is
            discarded). Except if the result of the division is 0, it will be
            negative if this arbitrary-precision integer is positive and the
            other arbitrary-precision integer is negative, or vice versa, and
            will be positive if both are positive or both are negative. The
            remainder is the number that remains when the absolute value of
            this arbitrary-precision integer is divided by the absolute value
            of the other arbitrary-precision integer; the remainder has the
            same sign (positive or negative) as this arbitrary-precision
            integer.</summary>
            <param name='dividend'>The arbitrary-precision integer to be
            divided.</param>
            <param name='divisor'>The arbitrary-precision integer to divide
            by.</param>
            <param name='remainder'>An arbitrary-precision integer.</param>
            <returns>An array of two items: the first is the result of the
            division as an arbitrary-precision integer, and the second is the
            remainder as an arbitrary-precision integer. The result of division
            is the result of the Divide method on the two operands, and the
            remainder is the result of the Remainder method on the two
            operands.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='dividend'/> or <paramref name='divisor'/> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Equals(PeterO.Numbers.EInteger)">
            <summary>Determines whether this object and another object are
            equal.</summary>
            <param name='other'>Another arbitrary-precision integer.</param>
            <returns><c>true</c> if this object and another object are equal;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Not(PeterO.Numbers.EInteger)">
            <summary>Returns an arbitrary-precision integer with every bit
            flipped.</summary>
            <param name='valueA'>The operand as an arbitrary-precision
            integer.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='valueA'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.And(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Does an AND operation between two arbitrary-precision
            integer values.</summary>
            <param name='a'>The first arbitrary-precision integer.</param>
            <param name='b'>The second arbitrary-precision integer.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            the corresponding bits of the two integers are both set.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> or <paramref name='b'/> is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Or(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Does an OR operation between two arbitrary-precision
            integer instances.</summary>
            <param name='first'>The first operand.</param>
            <param name='second'>The second operand.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Xor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Finds the exclusive "or" of two arbitrary-precision
            integer objects.
            <para>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
            the purposes of this operator.</para></summary>
            <param name='a'>The first arbitrary-precision integer.</param>
            <param name='b'>The second arbitrary-precision integer.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            the corresponding bit is set in one input integer but not in the
            other.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='a'/> or <paramref name='b'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Byte">
            <summary>Converts an arbitrary-precision integer to a byte (from 0
            to 255) if it can fit in a byte (from 0 to 255).</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            integer.</param>
            <returns>The value of <paramref name='input'/> as a byte (from 0 to
            255).</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is less than 0 or greater than 255.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(System.Boolean)~PeterO.Numbers.EInteger">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
            integer.</summary>
            <param name='boolValue'>Either <c>true</c> or <c>false</c>.</param>
            <returns>The value of <paramref name='boolValue'/> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.Byte)~PeterO.Numbers.EInteger">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
            integer.</summary>
            <param name='inputByte'>The number to convert as a byte (from 0 to
            255).</param>
            <returns>The value of <paramref name='inputByte'/> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToSByteChecked">
            <summary>Converts this number's value to an 8-bit signed integer if
            it can fit in an 8-bit signed integer.</summary>
            <returns>This number's value as an 8-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>This value is less than -128 or
            greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToSByteUnchecked">
            <summary>Converts this number to an 8-bit signed integer, returning
            the least-significant bits of this number's two's-complement
            form.</summary>
            <returns>This number, converted to an 8-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromSByte(System.SByte)">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision
            integer.</summary>
            <param name='inputSByte'>The number to convert as an 8-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.SByte">
            <summary>Converts an arbitrary-precision integer to an 8-bit signed
            integer if it can fit in an 8-bit signed integer.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            integer.</param>
            <returns>The value of <paramref name='input'/> as an 8-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is less than -128 or greater than 127.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.SByte)~PeterO.Numbers.EInteger">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision
            integer.</summary>
            <param name='inputSByte'>The number to convert as an 8-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputSByte'/> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int16">
            <summary>Converts an arbitrary-precision integer to a 16-bit signed
            integer if it can fit in a 16-bit signed integer.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            integer.</param>
            <returns>The value of <paramref name='input'/> as a 16-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is less than -32768 or greater than
            32767.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int16)~PeterO.Numbers.EInteger">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision
            integer.</summary>
            <param name='inputInt16'>The number to convert as a 16-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt16'/> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt16Checked">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer.</summary>
            <returns>This number's value as a 16-bit unsigned
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is less than 0 or
            greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt16Unchecked">
            <summary>Converts this number to a 16-bit unsigned integer,
            returning the least-significant bits of this number's
            two's-complement form.</summary>
            <returns>This number, converted to a 16-bit unsigned
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromUInt16(System.UInt16)">
            <summary>Converts a 16-bit unsigned integer to an
            arbitrary-precision integer.</summary>
            <param name='inputUInt16'>The number to convert as a 16-bit
            unsigned integer.</param>
            <returns>This number's value as an arbitrary-precision
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt16">
            <summary>Converts an arbitrary-precision integer to a 16-bit
            unsigned integer if it can fit in a 16-bit unsigned
            integer.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            integer.</param>
            <returns>The value of <paramref name='input'/> as a 16-bit unsigned
            integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is less than 0 or greater than 65535.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt16)~PeterO.Numbers.EInteger">
            <summary>Converts a 16-bit unsigned integer to an
            arbitrary-precision integer.</summary>
            <param name='inputUInt16'>The number to convert as a 16-bit
            unsigned integer.</param>
            <returns>The value of <paramref name='inputUInt16'/> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int32">
            <summary>Converts an arbitrary-precision integer to a 32-bit signed
            integer if it can fit in a 32-bit signed integer.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            integer.</param>
            <returns>The value of <paramref name='input'/> as a 32-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is less than -2147483648 or greater than
            2147483647.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int32)~PeterO.Numbers.EInteger">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            integer.</summary>
            <param name='inputInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt32'/> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer.</summary>
            <returns>This number's value as a 32-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>This value is less than 0 or
            greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt32Unchecked">
            <summary>Converts this number to a 32-bit signed integer, returning
            the least-significant bits of this number's two's-complement
            form.</summary>
            <returns>This number, converted to a 32-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromUInt32(System.UInt32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            integer.</summary>
            <param name='inputUInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt32">
            <summary>Converts an arbitrary-precision integer to a 32-bit signed
            integer if it can fit in a 32-bit signed integer.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            integer.</param>
            <returns>The value of <paramref name='input'/> as a 32-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is less than 0 or greater than
            4294967295.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt32)~PeterO.Numbers.EInteger">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            integer.</summary>
            <param name='inputUInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputUInt32'/> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int64">
            <summary>Converts an arbitrary-precision integer to a 64-bit signed
            integer if it can fit in a 64-bit signed integer.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            integer.</param>
            <returns>The value of <paramref name='input'/> as a 64-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is less than -9223372036854775808 or greater than
            9223372036854775807.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int64)~PeterO.Numbers.EInteger">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision
            integer.</summary>
            <param name='inputInt64'>The number to convert as a 64-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt64'/> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt64">
            <summary>Converts an arbitrary-precision integer to a 64-bit
            unsigned integer if it can fit in a 64-bit unsigned
            integer.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            integer.</param>
            <returns>The value of <paramref name='input'/> as a 64-bit unsigned
            integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is less than 0 or greater than
            18446744073709551615.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt64)~PeterO.Numbers.EInteger">
            <summary>Converts a 64-bit unsigned integer to an
            arbitrary-precision integer.</summary>
            <param name='inputUInt64'>The number to convert as a 64-bit
            unsigned integer.</param>
            <returns>The value of <paramref name='inputUInt64'/> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="T:PeterO.Numbers.ERational">
            <summary>Represents an arbitrary-precision rational number. This
            class can't be inherited. (The "E" stands for "extended", meaning
            that instances of this class can be values other than numbers
            proper, such as infinity and not-a-number.) In this class, a
            rational number consists of a numerator and denominator, each an
            arbitrary-precision integer (EInteger), and this class does not
            automatically convert rational numbers to lowest terms.
            <para><b>Thread safety:</b> Instances of this class are immutable,
            so they are inherently safe for use by multiple threads. Multiple
            instances of this object with the same properties are
            interchangeable, so they should not be compared using the "=="
            operator (which might only check if each side of the operator is
            the same instance).</para></summary>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(System.Boolean)~PeterO.Numbers.ERational">
            <summary>Converts a boolean value (true or false) to an
            arbitrary-precision rational number.</summary>
            <param name='boolValue'>Either true or false.</param>
            <returns>1 if <paramref name='boolValue'/> is true; otherwise,
            0.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.ERational">
            <summary>Converts an arbitrary-precision integer to an
            arbitrary-precision rational number.</summary>
            <param name='eint'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.ERational">
            <summary>Converts an arbitrary-precision decimal floating-point
            number to an arbitrary-precision rational number.</summary>
            <param name='eint'>The parameter <paramref name='eint'/> is an
            arbitrary-precision decimal floating-point number.</param>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EFloat)~PeterO.Numbers.ERational">
            <summary>Converts an arbitrary-precision binary floating-point
            number to an arbitrary-precision rational number.</summary>
            <param name='eint'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromDecimal(System.Decimal)">
            <summary>Converts a <c>decimal</c> under the Common Language
            Infrastructure (usually a.NET Framework decimal) to a rational
            number.</summary>
            <param name='eint'>The number to convert as a <c>decimal</c> under
            the Common Language Infrastructure (usually a.NET Framework
            decimal).</param>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Decimal)~PeterO.Numbers.ERational">
            <summary>Converts a <c>decimal</c> under the Common Language
            Infrastructure (usually a.NET Framework decimal). to an
            arbitrary-precision rational number.</summary>
            <param name='eint'>A <c>decimal</c> under the Common Language
            Infrastructure (usually a.NET Framework decimal).</param>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Single)~PeterO.Numbers.ERational">
            <summary>Converts a 32-bit binary floating-point number to a
            rational number.</summary>
            <param name='eint'>The parameter <paramref name='eint'/> is a
            32-bit binary floating-point number.</param>
            <returns>The value of <paramref name='eint'/> as an
            arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Double)~PeterO.Numbers.ERational">
            <summary>Converts a 64-bit floating-point number to an
            arbitrary-precision rational number.</summary>
            <param name='eint'>The parameter <paramref name='eint'/> is a
            64-bit floating-point number.</param>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Addition(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Adds an arbitrary-precision rational number and another
            arbitrary-precision rational number and returns the
            result.</summary>
            <param name='bthis'>The first operand.</param>
            <param name='augend'>The second operand.</param>
            <returns>The sum of the two numbers, that is, an
            arbitrary-precision rational number plus another
            arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter "otherValue"
            is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Subtraction(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Subtracts an arbitrary-precision rational number from this
            instance.</summary>
            <param name='bthis'>The first operand.</param>
            <param name='subtrahend'>The second operand.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter "otherValue"
            is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Increment(PeterO.Numbers.ERational)">
            <summary>Adds one to an arbitrary-precision rational
            number.</summary>
            <param name='bthis'>An arbitrary-precision rational number.</param>
            <returns>The number given in <paramref name='bthis'/> plus
            one.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Decrement(PeterO.Numbers.ERational)">
            <summary>Subtracts one from an arbitrary-precision rational
            number.</summary>
            <param name='bthis'>An arbitrary-precision rational number.</param>
            <returns>The number given in <paramref name='bthis'/> minus
            one.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Multiply(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Multiplies an arbitrary-precision rational number by
            another arbitrary-precision rational number and returns the
            result.</summary>
            <param name='operand1'>The first operand.</param>
            <param name='operand2'>The second operand.</param>
            <returns>The product of the two numbers, that is, an
            arbitrary-precision rational number times another
            arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter "otherValue"
            is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Division(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Divides an arbitrary-precision rational number by the
            value of another arbitrary-precision rational number
            object.</summary>
            <param name='dividend'>An arbitrary-precision rational number
            serving as the dividend.</param>
            <param name='divisor'>An arbitrary-precision rational number
            serving as the divisor.</param>
            <returns>The quotient of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter "otherValue"
            is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Modulus(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Returns the remainder that would result when an
            arbitrary-precision rational number is divided by another
            arbitrary-precision rational number.</summary>
            <param name='dividend'>The dividend.</param>
            <param name='divisor'>The divisor.</param>
            <returns>The remainder that would result when an
            arbitrary-precision rational number is divided by another
            arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter "otherValue"
            is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_UnaryNegation(PeterO.Numbers.ERational)">
            <summary>Returns an arbitrary-precision rational number with the
            same value as the given one but with its sign reversed.</summary>
            <param name='bigValue'>An arbitrary-precision rational number to
            negate.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToDecimal">
            <summary>Converts this value to a <c>decimal</c> under the Common
            Language Infrastructure (usually a.NET Framework decimal).
            Currently, converts this value to the precision and range of a.NET
            Framework decimal.</summary>
            <returns>A <c>decimal</c> under the Common Language Infrastructure
            (usually a.NET Framework decimal).</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Decimal">
            <summary>Converts an arbitrary-precision rational number to a
            <c>decimal</c> under the Common Language Infrastructure (see
            <see cref='T:PeterO.Numbers.EDecimal'>"Forms of numbers"</see>
            ).</summary>
            <param name='extendedNumber'>The number to convert as an
            arbitrary-precision rational number.</param>
            <returns>A <c>decimal</c> under the Common Language Infrastructure
            (usually a.NET Framework decimal).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='extendedNumber'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~PeterO.Numbers.EInteger">
            <summary>Converts an arbitrary-precision rational number to an
            arbitrary-precision integer. Any fractional part in the value will
            be discarded when converting to an arbitrary-precision
            integer.</summary>
            <param name='bigValue'>An arbitrary-precision rational
            number.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Double">
            <summary>Converts an arbitrary-precision rational number to a
            64-bit floating-point number. The half-even rounding mode is
            used.</summary>
            <param name='bigValue'>The number to convert as an
            arbitrary-precision rational number.</param>
            <returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Single">
            <summary>Converts an arbitrary-precision rational number to a
            32-bit binary floating-point number. The half-even rounding mode is
            used.</summary>
            <param name='bigValue'>The number to convert as an
            arbitrary-precision rational number.</param>
            <returns>The closest 32-bit binary floating-point number to this
            value. The return value can be positive infinity or negative
            infinity if this value exceeds the range of a 32-bit floating point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Byte">
            <summary>Converts an arbitrary-precision rational number to a byte
            (from 0 to 255) if it can fit in a byte (from 0 to 255) after
            converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            rational number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            byte (from 0 to 255).</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 255.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Byte)~PeterO.Numbers.ERational">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
            rational number.</summary>
            <param name='inputByte'>The number to convert as a byte (from 0 to
            255).</param>
            <returns>The value of <paramref name='inputByte'/> as an
            arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSByteChecked">
            <summary>Converts this number's value to an 8-bit signed integer if
            it can fit in an 8-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to an 8-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -128 or greater than
            127.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSByteUnchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as an 8-bit signed integer.</summary>
            <returns>This number, converted to an 8-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSByteIfExact">
            <summary>Converts this number's value to an 8-bit signed integer if
            it can fit in an 8-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as an 8-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -128 or
            greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromSByte(System.SByte)">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision
            rational number.</summary>
            <param name='inputSByte'>The number to convert as an 8-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision rational
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.SByte">
            <summary>Converts an arbitrary-precision rational number to an
            8-bit signed integer if it can fit in an 8-bit signed integer after
            converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            rational number.</param>
            <returns>The value of <paramref name='input'/>, truncated to an
            8-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -128 or greater than 127.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.SByte)~PeterO.Numbers.ERational">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision
            rational number.</summary>
            <param name='inputSByte'>The number to convert as an 8-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputSByte'/> as an
            arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int16">
            <summary>Converts an arbitrary-precision rational number to a
            16-bit signed integer if it can fit in a 16-bit signed integer
            after converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            rational number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            16-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -32768 or greater than 32767.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Int16)~PeterO.Numbers.ERational">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision
            rational number.</summary>
            <param name='inputInt16'>The number to convert as a 16-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt16'/> as an
            arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt16Checked">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer after converting it to
            an integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 16-bit unsigned
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt16Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 16-bit unsigned integer.</summary>
            <returns>This number, converted to a 16-bit unsigned integer.
            Returns 0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt16IfExact">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 16-bit unsigned
            integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromUInt16(System.UInt16)">
            <summary>Converts a 16-bit unsigned integer to an
            arbitrary-precision rational number.</summary>
            <param name='inputUInt16'>The number to convert as a 16-bit
            unsigned integer.</param>
            <returns>This number's value as an arbitrary-precision rational
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt16">
            <summary>Converts an arbitrary-precision rational number to a
            16-bit unsigned integer if it can fit in a 16-bit unsigned integer
            after converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            rational number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            16-bit unsigned integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 65535.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt16)~PeterO.Numbers.ERational">
            <summary>Converts a 16-bit unsigned integer to an
            arbitrary-precision rational number.</summary>
            <param name='inputUInt16'>The number to convert as a 16-bit
            unsigned integer.</param>
            <returns>The value of <paramref name='inputUInt16'/> as an
            arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int32">
            <summary>Converts an arbitrary-precision rational number to a
            32-bit signed integer if it can fit in a 32-bit signed integer
            after converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            rational number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            32-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -2147483648 or greater than 2147483647.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Int32)~PeterO.Numbers.ERational">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            rational number.</summary>
            <param name='inputInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt32'/> as an
            arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 32-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt32Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 32-bit signed integer.</summary>
            <returns>This number, converted to a 32-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 32-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromUInt32(System.UInt32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            rational number.</summary>
            <param name='inputUInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision rational
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt32">
            <summary>Converts an arbitrary-precision rational number to a
            32-bit signed integer if it can fit in a 32-bit signed integer
            after converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            rational number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            32-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 4294967295.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt32)~PeterO.Numbers.ERational">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            rational number.</summary>
            <param name='inputUInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputUInt32'/> as an
            arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int64">
            <summary>Converts an arbitrary-precision rational number to a
            64-bit signed integer if it can fit in a 64-bit signed integer
            after converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            rational number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            64-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -9223372036854775808 or greater than
            9223372036854775807.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Int64)~PeterO.Numbers.ERational">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision
            rational number.</summary>
            <param name='inputInt64'>The number to convert as a 64-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt64'/> as an
            arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt64Checked">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer after converting it to
            an integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 64-bit unsigned
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt64Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 64-bit unsigned integer.</summary>
            <returns>This number, converted to a 64-bit unsigned integer.
            Returns 0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt64IfExact">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 64-bit unsigned
            integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromUInt64(System.UInt64)">
            <summary>Converts a 64-bit unsigned integer to an
            arbitrary-precision rational number.</summary>
            <param name='inputUInt64'>The number to convert as a 64-bit
            unsigned integer.</param>
            <returns>This number's value as an arbitrary-precision rational
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt64">
            <summary>Converts an arbitrary-precision rational number to a
            64-bit unsigned integer if it can fit in a 64-bit unsigned integer
            after converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            rational number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            64-bit unsigned integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 18446744073709551615.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt64)~PeterO.Numbers.ERational">
            <summary>Converts a 64-bit unsigned integer to an
            arbitrary-precision rational number.</summary>
            <param name='inputUInt64'>The number to convert as a 64-bit
            unsigned integer.</param>
            <returns>The value of <paramref name='inputUInt64'/> as an
            arbitrary-precision rational number.</returns>
        </member>
        <member name="F:PeterO.Numbers.ERational.NaN">
            <summary>A not-a-number value.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.NegativeInfinity">
            <summary>Negative infinity, less than any other number.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.NegativeZero">
            <summary>A rational number for negative zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.One">
            <summary>The rational number one.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.PositiveInfinity">
            <summary>Positive infinity, greater than any other
            number.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.SignalingNaN">
            <summary>A signaling not-a-number value.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.Ten">
            <summary>The rational number ten.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.Zero">
            <summary>A rational number for zero.</summary>
        </member>
        <member name="M:PeterO.Numbers.ERational.#ctor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Numbers.ERational'/> class.</summary>
            <param name='numerator'>An arbitrary-precision integer serving as
            the numerator.</param>
            <param name='denominator'>An arbitrary-precision integer serving as
            the denominator.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='numerator'/> or <paramref name='denominator'/> is
            null.</exception>
            <exception cref='T:System.ArgumentException'>Denominator is
            zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Copy">
            <summary>Creates a copy of this arbitrary-precision rational
            number.</summary>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="P:PeterO.Numbers.ERational.Denominator">
            <summary>Gets this object's denominator.</summary>
            <value>This object's denominator.</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.IsFinite">
            <summary>Gets a value indicating whether this object is finite (not
            infinity or NaN).</summary>
            <value><c>true</c> if this object is finite (not infinity or NaN);
            otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.IsNegative">
            <summary>Gets a value indicating whether this object's value is
            negative (including negative zero).</summary>
            <value><c>true</c> if this object's value is negative (including
            negative zero); otherwise, <c>false</c>. <c>true</c> if this
            object's value is negative; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.IsZero">
            <summary>Gets a value indicating whether this object's value equals
            0.</summary>
            <value><c>true</c> if this object's value equals 0; otherwise,
            <c>false</c>. <c>true</c> if this object's value equals 0;
            otherwise, <c>false</c>.</value>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsInteger">
            <summary>Returns whether this object's value is an
            integer.</summary>
            <returns><c>true</c> if this object's value is an integer;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="P:PeterO.Numbers.ERational.Numerator">
            <summary>Gets this object's numerator.</summary>
            <value>This object's numerator. If this object is a not-a-number
            value, returns the diagnostic information (which will be negative
            if this object is negative).</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.Sign">
            <summary>Gets the sign of this rational number.</summary>
            <value>The sign of this rational number.</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.UnsignedNumerator">
            <summary>Gets this object's numerator with the sign
            removed.</summary>
            <value>This object's numerator. If this object is a not-a-number
            value, returns the diagnostic information.</value>
        </member>
        <member name="M:PeterO.Numbers.ERational.Create(System.Int32,System.Int32)">
            <summary>Creates a rational number with the given numerator and
            denominator.</summary>
            <param name='numeratorSmall'>The numerator.</param>
            <param name='denominatorSmall'>The denominator.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentException'>The denominator is
            zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Create(System.Int64,System.Int64)">
            <summary>Creates a rational number with the given numerator and
            denominator.</summary>
            <param name='numeratorLong'>The numerator.</param>
            <param name='denominatorLong'>The denominator.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentException'>The denominator is
            zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Creates a rational number with the given numerator and
            denominator.</summary>
            <param name='numerator'>The numerator.</param>
            <param name='denominator'>The denominator.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentException'>The denominator is
            zero.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='numerator'/> or <paramref name='denominator'/> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger)">
            <summary>Creates a not-a-number arbitrary-precision rational
            number.</summary>
            <param name='diag'>An integer, 0 or greater, to use as diagnostic
            information associated with this object. If none is needed, should
            be zero. To get the diagnostic information from another
            arbitrary-precision rational number, use that object's
            <c>UnsignedNumerator</c> property.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='diag'/> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean)">
            <summary>Creates a not-a-number arbitrary-precision rational
            number.</summary>
            <param name='diag'>An integer, 0 or greater, to use as diagnostic
            information associated with this object. If none is needed, should
            be zero. To get the diagnostic information from another
            arbitrary-precision rational number, use that object's
            <c>UnsignedNumerator</c> property.</param>
            <param name='signaling'>Whether the return value will be signaling
            (true) or quiet (false).</param>
            <param name='negative'>Whether the return value is
            negative.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='diag'/> is less than 0.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='diag'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromDouble(System.Double)">
            <summary>Converts a 64-bit floating-point number to a rational
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the number to a string.
            <para>The input value can be a not-a-number (NaN) value (such as
            <c>Double.NaN</c> ); however, NaN values have multiple forms that
            are equivalent for many applications' purposes, and
            <c>Double.NaN</c> is only one of these equivalent forms. In fact,
            <c>ERational.FromDouble(Double.NaN)</c> could produce an object
            that is represented differently between DotNet and Java, because
            <c>Double.NaN</c> may have a different form in DotNet and Java (for
            example, the NaN value's sign may be negative in DotNet, but
            positive in Java). Use `IsNaN()` to determine whether an object
            from this class stores a NaN value of any form.</para></summary>
            <param name='flt'>The parameter <paramref name='flt'/> is a 64-bit
            floating-point number.</param>
            <returns>A rational number with the same value as <paramref
            name='flt'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromExtendedDecimal(PeterO.Numbers.EDecimal)">
            <summary>Converts an arbitrary-precision decimal number to a
            rational number.</summary>
            <param name='ef'>The number to convert as an arbitrary-precision
            decimal number.</param>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromExtendedFloat(PeterO.Numbers.EFloat)">
            <summary>Converts an arbitrary-precision binary floating-point
            number to a rational number.</summary>
            <param name='ef'>The number to convert as an arbitrary-precision
            binary floating-point number.</param>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromEDecimal(PeterO.Numbers.EDecimal)">
            <summary>Converts an arbitrary-precision decimal number to a
            rational number.</summary>
            <param name='ef'>The number to convert as an arbitrary-precision
            decimal number.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ef'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>doesn't satisfy den.Sign
            &amp;gt;= 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromEFloat(PeterO.Numbers.EFloat)">
            <summary>Converts an arbitrary-precision binary floating-point
            number to a rational number.</summary>
            <param name='ef'>The number to convert as an arbitrary-precision
            binary floating-point number.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ef'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromEInteger(PeterO.Numbers.EInteger)">
            <summary>Converts an arbitrary-precision integer to a rational
            number.</summary>
            <param name='bigint'>The number to convert as an
            arbitrary-precision integer.</param>
            <returns>The exact value of the integer as a rational
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromSingle(System.Single)">
            <summary>Converts a 32-bit binary floating-point number to a
            rational number. This method computes the exact value of the
            floating point number, not an approximation, as is often the case
            by converting the number to a string.
            <para>The input value can be a not-a-number (NaN) value (such as
            <c>Single.NaN</c> in DotNet or Float.NaN in Java); however, NaN
            values have multiple forms that are equivalent for many
            applications' purposes, and <c>Single.NaN</c> / <c>Float.NaN</c> is
            only one of these equivalent forms. In fact,
            <c>ERational.FromSingle(Single.NaN)</c> or
            <c>ERational.FromSingle(Float.NaN)</c> could produce an object that
            is represented differently between DotNet and Java, because
            <c>Single.NaN</c> / <c>Float.NaN</c> may have a different form in
            DotNet and Java (for example, the NaN value's sign may be negative
            in DotNet, but positive in Java). Use `IsNaN()` to determine
            whether an object from this class stores a NaN value of any
            form.</para></summary>
            <param name='flt'>The parameter <paramref name='flt'/> is a 32-bit
            binary floating-point number.</param>
            <returns>A rational number with the same value as <paramref
            name='flt'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromSingleBits(System.Int32)">
            <summary>Creates a binary rational number from a 32-bit
            floating-point number encoded in the IEEE 754 binary32 format. This
            method computes the exact value of the floating point number, not
            an approximation, as is often the case by converting the number to
            a string.</summary>
            <param name='value'>A 32-bit integer encoded in the IEEE 754
            binary32 format.</param>
            <returns>A rational number with the same floating-point value as
            <paramref name='value'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromDoubleBits(System.Int64)">
            <summary>Creates a binary rational number from a 64-bit
            floating-point number encoded in the IEEE 754 binary64 format. This
            method computes the exact value of the floating point number, not
            an approximation, as is often the case by converting the number to
            a string.</summary>
            <param name='value'>A 64-bit integer encoded in the IEEE 754
            binary64 format.</param>
            <returns>A rational number with the same floating-point value as
            <paramref name='value'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromString(System.String)">
            <summary>Creates a rational number from a text string that
            represents a number. See <c>FromString(String, int, int)</c> for
            more information.</summary>
            <param name='str'>A string that represents a number.</param>
            <returns>An arbitrary-precision rational number with the same value
            as the given string.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='str'/> is not a correctly formatted number
            string.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromString(System.String,System.Int32,System.Int32)">
            <summary>
            <para>Creates a rational number from a text string that represents
            a number.</para>
            <para>The format of the string generally consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>The numerator in the form of one or more digits (these digits
            may begin with any number of zeros).</item>
            <item>Optionally, "/" followed by the denominator in the form of
            one or more digits (these digits may begin with any number of
            zeros). If a denominator is not given, it's equal to
            1.</item></list>
            <para>The string can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN" /"-NaN") followed by any number of digits,
            or signaling NaN ("sNaN" /"-sNaN") followed by any number of
            digits, all in any combination of upper and lower case.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The string is not
            allowed to contain white space characters, including
            spaces.</para></summary>
            <param name='str'>A text string, a portion of which represents a
            number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref
            name='str'/> 's length).</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='str'/> is not a correctly formatted number
            string.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref
            name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromString(System.Char[])">
            <summary>Creates a rational number from a sequence of <c>char</c> s
            that represents a number. See <c>FromString(String, int, int)</c>
            for more information.</summary>
            <param name='chars'>A sequence of <c>char</c> s that represents a
            number.</param>
            <returns>An arbitrary-precision rational number with the same value
            as the given sequence of <c>char</c> s.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='chars'/> is not a correctly formatted sequence of <c>char</c>
            s.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromString(System.Char[],System.Int32,System.Int32)">
            <summary>
            <para>Creates a rational number from a sequence of <c>char</c> s
            that represents a number.</para>
            <para>The format of the sequence of <c>char</c> s generally
            consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>The numerator in the form of one or more digits (these digits
            may begin with any number of zeros).</item>
            <item>Optionally, "/" followed by the denominator in the form of
            one or more digits (these digits may begin with any number of
            zeros). If a denominator is not given, it's equal to
            1.</item></list>
            <para>The sequence of <c>char</c> s can also be "-INF",
            "-Infinity", "Infinity", "INF", quiet NaN ("NaN" /"-NaN") followed
            by any number of digits, or signaling NaN ("sNaN" /"-sNaN")
            followed by any number of digits, all in any combination of upper
            and lower case.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The sequence of
            <c>char</c> s is not allowed to contain white space characters,
            including spaces.</para></summary>
            <param name='chars'>A sequence of <c>char</c> s, a portion of which
            represents a number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='chars'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='chars'/> (but not more than <paramref
            name='chars'/> 's length).</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='chars'/> is not a correctly formatted sequence of <c>char</c>
            s.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='chars'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='chars'/> 's length, or <paramref
            name='chars'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromString(System.Byte[])">
            <summary>Creates a rational number from a sequence of bytes that
            represents a number. See <c>FromString(String, int, int)</c> for
            more information.</summary>
            <param name='bytes'>A sequence of bytes that represents a
            number.</param>
            <returns>An arbitrary-precision rational number with the same value
            as the given sequence of bytes.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='bytes'/> is not a correctly formatted sequence of
            bytes.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <para>Creates a rational number from a sequence of bytes that
            represents a number.</para>
            <para>The format of the sequence of bytes generally consists
            of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>The numerator in the form of one or more digits (these digits
            may begin with any number of zeros).</item>
            <item>Optionally, "/" followed by the denominator in the form of
            one or more digits (these digits may begin with any number of
            zeros). If a denominator is not given, it's equal to
            1.</item></list>
            <para>The sequence of bytes can also be "-INF", "-Infinity",
            "Infinity", "INF", quiet NaN ("NaN" /"-NaN") followed by any number
            of digits, or signaling NaN ("sNaN" /"-sNaN") followed by any
            number of digits, all in any combination of upper and lower
            case.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The sequence of
            bytes is not allowed to contain white space characters, including
            spaces.</para></summary>
            <param name='bytes'>A sequence of bytes, a portion of which
            represents a number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='bytes'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='bytes'/> (but not more than <paramref
            name='bytes'/> 's length).</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.FormatException'>The parameter <paramref
            name='bytes'/> is not a correctly formatted sequence of
            bytes.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='bytes'/> 's length, or <paramref
            name='bytes'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToTotalMagnitude(PeterO.Numbers.ERational)">
            <summary>Compares the absolute values of this object and another
            object, imposing a total ordering on all possible values (ignoring
            their signs). In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            denominator has a greater "absolute value".</item>
            <item>Negative zero and positive zero are considered equal.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item></list></summary>
            <param name='other'>An arbitrary-precision rational number to
            compare with this one.</param>
            <returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToTotal(PeterO.Numbers.ERational)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            denominator has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary>
            <param name='other'>An arbitrary-precision rational number to
            compare with this one.</param>
            <returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Abs">
            <summary>Returns the absolute value of this rational number, that
            is, a number with the same value as this one but as a nonnegative
            number.</summary>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Add(PeterO.Numbers.ERational)">
            <summary>Adds this arbitrary-precision rational number and another
            arbitrary-precision rational number and returns the
            result.</summary>
            <param name='otherValue'>Another arbitrary-precision rational
            number.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision rational number plus another
            arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='otherValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareTo(PeterO.Numbers.ERational)">
            <summary>Compares the mathematical value of an arbitrary-precision
            rational number with that of this instance. This method currently
            uses the rules given in the CompareToValue method, so that it it is
            not consistent with the Equals method, but it may change in a
            future version to use the rules for the CompareToTotal method
            instead.</summary>
            <param name='other'>An arbitrary-precision rational number.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToValue(PeterO.Numbers.ERational)">
            <summary>Compares the mathematical value of an arbitrary-precision
            rational number with that of this instance. In this method, NaN
            values are greater than any other ERational value, and two NaN
            values (even if their payloads differ) are treated as equal by this
            method. This method is not consistent with the Equals
            method.</summary>
            <param name='other'>An arbitrary-precision rational number.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Max(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Gets the greater value between two rational
            numbers.</summary>
            <param name='first'>An arbitrary-precision rational number.</param>
            <param name='second'>Another arbitrary-precision rational
            number.</param>
            <returns>The larger value of the two numbers. If one is positive
            zero and the other is negative zero, returns the positive zero. If
            the two numbers are positive and have the same value, returns the
            one with the larger denominator. If the two numbers are negative
            and have the same value, returns the one with the smaller
            denominator.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.MaxMagnitude(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The larger value of the two numbers, ignoring their
            signs.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Min(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Gets the lesser value between two rational
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The smaller value of the two numbers. If one is positive
            zero and the other is negative zero, returns the negative zero. If
            the two numbers are positive and have the same value, returns the
            one with the smaller denominator. If the two numbers are negative
            and have the same value, returns the one with the larger
            denominator.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.MinMagnitude(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The smaller value of the two numbers, ignoring their
            signs.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareTo(System.Int32)">
            <summary>Compares the mathematical value of an arbitrary-precision
            rational number with that of this instance. This method currently
            uses the rules given in the CompareToValue method, so that it it is
            not consistent with the Equals method, but it may change in a
            future version to use the rules for the CompareToTotal method
            instead.</summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 32-bit signed integer.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToValue(System.Int32)">
            <summary>Compares the mathematical value of an arbitrary-precision
            rational number with that of this instance. In this method, NaN
            values are greater than any other ERational value, and two NaN
            values (even if their payloads differ) are treated as equal by this
            method. This method is not consistent with the Equals
            method.</summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 32-bit signed integer.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToValue(System.Int64)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object is a quiet NaN or signaling NaN, this method
            will not trigger an error. Instead, NaN will compare greater than
            any other number, including infinity.</para></summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 64-bit signed integer.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value, or 0 if both values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareTo(System.Int64)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values. This method currently uses
            the rules given in the CompareToValue method, so that it it is not
            consistent with the Equals method, but it may change in a future
            version to use the rules for the CompareToTotal method
            instead.</summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 64-bit signed integer.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value, or 0 if both values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToBinary(PeterO.Numbers.EFloat)">
            <summary>Compares an arbitrary-precision binary floating-point
            number with this instance. In this method, NaN values are greater
            than any other ERational or EFloat value, and two NaN values (even
            if their payloads differ) are treated as equal by this
            method.</summary>
            <param name='other'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToDecimal(PeterO.Numbers.EDecimal)">
            <summary>Compares an arbitrary-precision decimal number with this
            instance.</summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CopySign(PeterO.Numbers.ERational)">
            <summary>Returns a number with the same value as this one, but
            copying the sign (positive or negative) of another
            number.</summary>
            <param name='other'>A number whose sign will be copied.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='other'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Divide(PeterO.Numbers.ERational)">
            <summary>Divides this arbitrary-precision rational number by
            another arbitrary-precision rational number and returns the
            result.</summary>
            <param name='otherValue'>An arbitrary-precision rational
            number.</param>
            <returns>The result of dividing this arbitrary-precision rational
            number by another arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='otherValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Equals(System.Object)">
            <summary>Determines whether this object's numerator, denominator,
            and properties are equal to those of another object and that other
            object is an arbitrary-precision rational number. Not-a-number
            values are considered equal if the rest of their properties are
            equal. This is not the same as value equality. Notably, two
            ERationals with the same value, but of which one is in lowest terms
            and the other is not, are compared as unequal by this method
            (example: 1/2 vs. 5/10).</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if the objects are equal; otherwise,
            <c>false</c>. In this method, two objects are not equal if they
            don't have the same type or if one is null and the other
            isn't.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Equals(PeterO.Numbers.ERational)">
            <summary>Determines whether this object's numerator, denominator,
            and properties are equal to those of another object. Not-a-number
            values are considered equal if the rest of their properties are
            equal.</summary>
            <param name='other'>An arbitrary-precision rational number to
            compare to.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.GetHashCode">
            <summary>Returns the hash code for this instance. No application or
            process IDs are used in the hash code calculation.</summary>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsInfinity">
            <summary>Gets a value indicating whether this object's value is
            infinity.</summary>
            <returns><c>true</c> if this object's value is infinity; otherwise,
            <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsNaN">
            <summary>Returns whether this object is a not-a-number
            value.</summary>
            <returns><c>true</c> if this object is a not-a-number value;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsNegativeInfinity">
            <summary>Returns whether this object is negative
            infinity.</summary>
            <returns><c>true</c> if this object is negative infinity;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsPositiveInfinity">
            <summary>Returns whether this object is positive
            infinity.</summary>
            <returns><c>true</c> if this object is positive infinity;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsQuietNaN">
            <summary>Returns whether this object is a quiet not-a-number
            value.</summary>
            <returns><c>true</c> if this object is a quiet not-a-number value;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsSignalingNaN">
            <summary>Returns whether this object is a signaling not-a-number
            value (which causes an error if the value is passed to any
            arithmetic operation in this class).</summary>
            <returns><c>true</c> if this object is a signaling not-a-number
            value (which causes an error if the value is passed to any
            arithmetic operation in this class); otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Multiply(PeterO.Numbers.ERational)">
            <summary>Multiplies this arbitrary-precision rational number by
            another arbitrary-precision rational number and returns the
            result.</summary>
            <param name='otherValue'>An arbitrary-precision rational
            number.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision rational number times another
            arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='otherValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Negate">
            <summary>Returns a rational number with the same value as this one
            but with the sign reversed.</summary>
            <returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Remainder(PeterO.Numbers.ERational)">
            <summary>Returns the remainder that would result when this
            arbitrary-precision rational number is divided by another
            arbitrary-precision rational number.</summary>
            <param name='otherValue'>An arbitrary-precision rational
            number.</param>
            <returns>The remainder that would result when this
            arbitrary-precision rational number is divided by another
            arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='otherValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Subtract(PeterO.Numbers.ERational)">
            <summary>Subtracts an arbitrary-precision rational number from this
            arbitrary-precision rational number and returns the
            result.</summary>
            <param name='otherValue'>An arbitrary-precision rational
            number.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision rational number minus another
            arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='otherValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToDouble">
            <summary>Converts this value to a 64-bit floating-point number. The
            half-even rounding mode is used.</summary>
            <returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToDoubleBits">
            <summary>Converts this value to its closest equivalent as a 64-bit
            floating-point number, expressed as an integer in the IEEE 754
            binary64 format. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 64-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN.</para></summary>
            <returns>The closest 64-bit binary floating-point number to this
            value, expressed as an integer in the IEEE 754 binary64 format. The
            return value can be positive infinity or negative infinity if this
            value exceeds the range of a 64-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSingleBits">
            <summary>Converts this value to its closest equivalent as 32-bit
            floating-point number, expressed as an integer in the IEEE 754
            binary32 format. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN.</para></summary>
            <returns>The closest 32-bit binary floating-point number to this
            value, expressed as an integer in the IEEE 754 binary32 format. The
            return value can be positive infinity or negative infinity if this
            value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToLowestTerms">
            <summary>Converts this value to its form in lowest terms. For
            example, (8/4) becomes (4/1).</summary>
            <returns>An arbitrary-precision rational with the same value as
            this one but in lowest terms. Returns this object if it is infinity
            or NaN. Returns ERational.NegativeZero if this object is a negative
            zero. Returns ERational.Zero if this object is a positive
            zero.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSizedEInteger(System.Int32)">
            <summary>Converts this value to an arbitrary-precision integer by
            dividing the numerator by the denominator, discarding its
            fractional part, and checking whether the resulting integer
            overflows the given signed bit count.</summary>
            <param name='maxBitLength'>The maximum number of signed bits the
            integer can have. The integer's value may not be less than
            -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN), or this number's value, once converted to an
            integer by dividing the numerator by the denominator and discarding
            its fractional part, is less than -(2^maxBitLength) or greater than
            (2^maxBitLength) - 1.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSizedEIntegerIfExact(System.Int32)">
            <summary>Converts this value to an arbitrary-precision integer,
            only if this number's value is an exact integer and that integer
            does not overflow the given signed bit count.</summary>
            <param name='maxBitLength'>The maximum number of signed bits the
            integer can have. The integer's value may not be less than
            -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN), or this number's value as an integer is less
            than -(2^maxBitLength) or greater than (2^maxBitLength) -
            1.</exception>
            <exception cref='T:System.ArithmeticException'>This object's value is not an
            exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEInteger">
            <summary>Converts this value to an arbitrary-precision integer by
            dividing the numerator by the denominator and discarding the
            fractional part of the result.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEIntegerExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the value is an exact integer.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEIntegerIfExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the value is an exact integer.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEDecimal">
            <summary>Converts this rational number to an arbitrary-precision
            decimal number.</summary>
            <returns>The exact value of the rational number, or not-a-number
            (NaN) if the result can't be exact because it has a nonterminating
            decimal expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEDecimal(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to an arbitrary-precision
            decimal number and rounds the result to the given
            precision.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. If HasFlags
            of the context is true, will also store the flags resulting from
            the operation (the flags are in addition to the pre-existing
            flags). Can be null, in which case the precision is unlimited and
            no rounding is needed.</param>
            <returns>The value of the rational number, rounded to the given
            precision. Returns not-a-number (NaN) if the context is null and
            the result can't be exact because it has a nonterminating decimal
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEDecimalExactIfPossible(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to an arbitrary-precision
            decimal number, but if the result would have a nonterminating
            decimal expansion, rounds that result to the given
            precision.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only if the exact result would have a nonterminating
            decimal expansion. If HasFlags of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited and no rounding is needed.</param>
            <returns>The exact value of the rational number if possible;
            otherwise, the rounded version of the result if a context is given.
            Returns not-a-number (NaN) if the context is null and the result
            can't be exact because it has a nonterminating decimal
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedDecimal">
            <summary>Converts this rational number to an arbitrary-precision
            decimal number.</summary>
            <returns>The exact value of the rational number, or not-a-number
            (NaN) if the result can't be exact because it has a nonterminating
            decimal expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedDecimal(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to an arbitrary-precision
            decimal number and rounds the result to the given
            precision.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. If HasFlags
            of the context is true, will also store the flags resulting from
            the operation (the flags are in addition to the pre-existing
            flags). Can be null, in which case the precision is unlimited and
            no rounding is needed.</param>
            <returns>The value of the rational number, rounded to the given
            precision. Returns not-a-number (NaN) if the context is null and
            the result can't be exact because it has a nonterminating decimal
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedDecimalExactIfPossible(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to an arbitrary-precision
            decimal number, but if the result would have a nonterminating
            decimal expansion, rounds that result to the given
            precision.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only if the exact result would have a nonterminating
            decimal expansion. If HasFlags of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited and no rounding is needed.</param>
            <returns>The exact value of the rational number if possible;
            otherwise, the rounded version of the result if a context is given.
            Returns not-a-number (NaN) if the context is null and the result
            can't be exact because it has a nonterminating decimal
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEFloat">
            <summary>Converts this rational number to a binary floating-point
            number.</summary>
            <returns>The exact value of the rational number, or not-a-number
            (NaN) if the result can't be exact because it has a nonterminating
            binary expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEFloat(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a binary floating-point
            number and rounds that result to the given precision.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. If HasFlags
            of the context is true, will also store the flags resulting from
            the operation (the flags are in addition to the pre-existing
            flags). Can be null, in which case the precision is unlimited and
            no rounding is needed.</param>
            <returns>The value of the rational number, rounded to the given
            precision. Returns not-a-number (NaN) if the context is null and
            the result can't be exact because it has a nonterminating binary
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEFloatExactIfPossible(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a binary floating-point
            number, but if the result would have a nonterminating binary
            expansion, rounds that result to the given precision.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only if the exact result would have a nonterminating
            binary expansion. If HasFlags of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited and no rounding is needed.</param>
            <returns>The exact value of the rational number if possible;
            otherwise, the rounded version of the result if a context is given.
            Returns not-a-number (NaN) if the context is null and the result
            can't be exact because it has a nonterminating binary
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedFloat">
            <summary>Converts this rational number to a binary floating-point
            number.</summary>
            <returns>The exact value of the rational number, or not-a-number
            (NaN) if the result can't be exact because it has a nonterminating
            binary expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedFloat(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a binary floating-point
            number and rounds that result to the given precision.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. If HasFlags
            of the context is true, will also store the flags resulting from
            the operation (the flags are in addition to the pre-existing
            flags). Can be null, in which case the precision is unlimited and
            no rounding is needed.</param>
            <returns>The value of the rational number, rounded to the given
            precision. Returns not-a-number (NaN) if the context is null and
            the result can't be exact because it has a nonterminating binary
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedFloatExactIfPossible(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a binary floating-point
            number, but if the result would have a nonterminating binary
            expansion, rounds that result to the given precision.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only if the exact result would have a nonterminating
            binary expansion. If HasFlags of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited and no rounding is needed.</param>
            <returns>The exact value of the rational number if possible;
            otherwise, the rounded version of the result if a context is given.
            Returns not-a-number (NaN) if the context is null and the result
            can't be exact because it has a nonterminating binary
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSingle">
            <summary>Converts this value to a 32-bit binary floating-point
            number. The half-even rounding mode is used.</summary>
            <returns>The closest 32-bit binary floating-point number to this
            value. The return value can be positive infinity or negative
            infinity if this value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToString">
            <summary>Converts this object to a text string.</summary>
            <returns>A string representation of this object. If this object's
            value is infinity or not-a-number, the result is the analogous
            return value of the <c>EDecimal.ToString</c> method. Otherwise, the
            return value has the following form:
            <c>[-]numerator/denominator</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Increment">
            <summary>Adds one to an arbitrary-precision rational
            number.</summary>
            <returns>The given arbitrary-precision rational number plus
            one.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Decrement">
            <summary>Subtracts one from an arbitrary-precision rational
            number.</summary>
            <returns>The given arbitrary-precision rational number minus
            one.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Add(System.Int32)">
            <summary>Adds this arbitrary-precision rational number and a 32-bit
            signed integer and returns the result.</summary>
            <param name='v'>A 32-bit signed integer.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision rational number plus a 32-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Subtract(System.Int32)">
            <summary>Subtracts a 32-bit signed integer from this
            arbitrary-precision rational number and returns the
            result.</summary>
            <param name='v'>The parameter <paramref name='v'/> is a 32-bit
            signed integer.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision rational number minus a 32-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Multiply(System.Int32)">
            <summary>Multiplies this arbitrary-precision rational number by a
            32-bit signed integer and returns the result.</summary>
            <param name='v'>The parameter <paramref name='v'/> is a 32-bit
            signed integer.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision rational number times a 32-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Divide(System.Int32)">
            <summary>Divides this arbitrary-precision rational number by a
            32-bit signed integer and returns the result.</summary>
            <param name='v'>The parameter <paramref name='v'/> is a 32-bit
            signed integer.</param>
            <returns>The result of dividing this arbitrary-precision rational
            number by a 32-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>The parameter <paramref
            name='v'/> is zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Remainder(System.Int32)">
            <summary>Returns the remainder that would result when this
            arbitrary-precision rational number is divided by a 32-bit signed
            integer.</summary>
            <param name='v'>The divisor.</param>
            <returns>The remainder that would result when this
            arbitrary-precision rational number is divided by a 32-bit signed
            integer.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='v'/> is zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Add(System.Int64)">
            <summary>Adds this arbitrary-precision rational number and a 64-bit
            signed integer and returns the result.</summary>
            <param name='v'>A 64-bit signed integer.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision rational number plus a 64-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Subtract(System.Int64)">
            <summary>Subtracts a 64-bit signed integer from this
            arbitrary-precision rational number and returns the
            result.</summary>
            <param name='v'>The parameter <paramref name='v'/> is a 64-bit
            signed integer.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision rational number minus a 64-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Multiply(System.Int64)">
            <summary>Multiplies this arbitrary-precision rational number by a
            64-bit signed integer and returns the result.</summary>
            <param name='v'>The parameter <paramref name='v'/> is a 64-bit
            signed integer.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision rational number times a 64-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Divide(System.Int64)">
            <summary>Divides this arbitrary-precision rational number by a
            64-bit signed integer and returns the result.</summary>
            <param name='v'>The parameter <paramref name='v'/> is a 64-bit
            signed integer.</param>
            <returns>The result of dividing this arbitrary-precision rational
            number by a 64-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>The parameter <paramref
            name='v'/> is zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Remainder(System.Int64)">
            <summary>Returns the remainder that would result when this
            arbitrary-precision rational number is divided by a 64-bit signed
            integer.</summary>
            <param name='v'>The divisor.</param>
            <returns>The remainder that would result when this
            arbitrary-precision rational number is divided by a 64-bit signed
            integer.</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='v'/> is zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToByteChecked">
            <summary>Converts this number's value to a byte (from 0 to 255) if
            it can fit in a byte (from 0 to 255) after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a byte (from 0 to
            255).</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            255.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToByteUnchecked">
            <summary>Converts this number's value to an integer (using
            ToEInteger), and returns the least-significant bits of that
            integer's two's-complement form as a byte (from 0 to
            255).</summary>
            <returns>This number, converted to a byte (from 0 to 255). Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToByteIfExact">
            <summary>Converts this number's value to a byte (from 0 to 255) if
            it can fit in a byte (from 0 to 255) without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a byte (from 0 to 255).</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromByte(System.Byte)">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
            rational number.</summary>
            <param name='inputByte'>The number to convert as a byte (from 0 to
            255).</param>
            <returns>This number's value as an arbitrary-precision rational
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt16Checked">
            <summary>Converts this number's value to a 16-bit signed integer if
            it can fit in a 16-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 16-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -32768 or greater than
            32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt16Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 16-bit signed integer.</summary>
            <returns>This number, converted to a 16-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt16IfExact">
            <summary>Converts this number's value to a 16-bit signed integer if
            it can fit in a 16-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 16-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -32768 or
            greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromInt16(System.Int16)">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision
            rational number.</summary>
            <param name='inputInt16'>The number to convert as a 16-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision rational
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 32-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -2147483648 or greater
            than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt32Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 32-bit signed integer.</summary>
            <returns>This number, converted to a 32-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 32-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -2147483648
            or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromBoolean(System.Boolean)">
            <summary>Converts a boolean value (true or false) to an
            arbitrary-precision rational number.</summary>
            <param name='boolValue'>Either true or false.</param>
            <returns>The number 1 if <paramref name='boolValue'/> is true;
            otherwise, 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromInt32(System.Int32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            rational number.</summary>
            <param name='inputInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision rational
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt64Checked">
            <summary>Converts this number's value to a 64-bit signed integer if
            it can fit in a 64-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 64-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -9223372036854775808
            or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt64Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 64-bit signed integer.</summary>
            <returns>This number, converted to a 64-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt64IfExact">
            <summary>Converts this number's value to a 64-bit signed integer if
            it can fit in a 64-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 64-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than
            -9223372036854775808 or greater than
            9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromInt64AsUnsigned(System.Int64)">
            <summary>Converts an unsigned integer expressed as a 64-bit signed
            integer to an arbitrary-precision rational number.</summary>
            <param name='longerValue'>A 64-bit signed integer. If this value is
            0 or greater, the return value will represent it. If this value is
            less than 0, the return value will store 2^64 plus this value
            instead.</param>
            <returns>An arbitrary-precision rational number. If <paramref
            name='longerValue'/> is 0 or greater, the return value will
            represent it. If <paramref name='longerValue'/> is less than 0, the
            return value will store 2^64 plus this value instead.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromInt64(System.Int64)">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision
            rational number.</summary>
            <param name='inputInt64'>The number to convert as a 64-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision rational
            number.</returns>
        </member>
        <member name="T:PeterO.Numbers.EFloat">
            <summary>Represents an arbitrary-precision binary floating-point
            number. (The "E" stands for "extended", meaning that instances of
            this class can be values other than numbers proper, such as
            infinity and not-a-number.) Each number consists of an integer
            significand and an integer exponent, both arbitrary-precision. The
            value of the number equals significand * 2^exponent. This class
            also supports values for negative zero, not-a-number (NaN) values,
            and infinity.
            <para>Passing a signaling NaN to any arithmetic operation shown
            here will signal the flag FlagInvalid and return a quiet NaN, even
            if another operand to that operation is a quiet NaN, unless the
            operation's documentation expressly states that another result
            happens when a signaling NaN is passed to that operation.</para>
            <para>Passing a quiet NaN to any arithmetic operation shown here
            will return a quiet NaN, unless the operation's documentation
            expressly states that another result happens when a quiet NaN is
            passed to that operation.</para>
            <para>Unless noted otherwise, passing a null arbitrary-precision
            binary floating-point number argument to any method here will throw
            an exception.</para>
            <para>When an arithmetic operation signals the flag FlagInvalid,
            FlagOverflow, or FlagDivideByZero, it will not throw an exception
            too, unless the operation's trap is enabled in the arithmetic
            context (see EContext's Traps property).</para>
            <para>An arbitrary-precision binary floating-point number value can
            be serialized in one of the following ways:</para>
            <list>
            <item>By calling the toString() method. However, not all strings
            can be converted back to an arbitrary-precision binary
            floating-point number without loss, especially if the string has a
            fractional part.</item>
            <item>By calling the UnsignedMantissa, Exponent, and IsNegative
            properties, and calling the IsInfinity, IsQuietNaN, and
            IsSignalingNaN methods. The return values combined will uniquely
            identify a particular arbitrary-precision binary floating-point
            number value.</item></list>
            <para>If an operation requires creating an intermediate value that
            might be too big to fit in memory (or might require more than 2
            gigabytes of memory to store -- due to the current use of a 32-bit
            integer internally as a length), the operation may signal an
            invalid-operation flag and return not-a-number (NaN). In certain
            rare cases, the CompareTo method may throw OutOfMemoryException
            (called OutOfMemoryError in Java) in the same circumstances.</para>
            <para><b>Thread safety</b></para>
            <para>Instances of this class are immutable, so they are inherently
            safe for use by multiple threads. Multiple instances of this object
            with the same properties are interchangeable, so they should not be
            compared using the "==" operator (which might only check if each
            side of the operator is the same instance).</para>
            <para><b>Comparison considerations</b></para>
            <para>This class's natural ordering (under the CompareTo method) is
            not consistent with the Equals method. This means that two values
            that compare as equal under the CompareTo method might not be equal
            under the Equals method. The CompareTo method compares the
            mathematical values of the two instances passed to it (and
            considers two different NaN values as equal), while two instances
            with the same mathematical value, but different exponents, will be
            considered unequal under the Equals method.</para>
            <para><b>Security note</b></para>
            <para>It is not recommended to implement security-sensitive
            algorithms using the methods in this class, for several
            reasons:</para>
            <list>
            <item><c>EFloat</c> objects are immutable, so they can't be
            modified, and the memory they occupy is not guaranteed to be
            cleared in a timely fashion due to garbage collection. This is
            relevant for applications that use many-bit-long numbers as secret
            parameters.</item>
            <item>The methods in this class (especially those that involve
            arithmetic) are not guaranteed to be "constant-time"
            (non-data-dependent) for all relevant inputs. Certain attacks that
            involve encrypted communications have exploited the timing and
            other aspects of such communications to derive keying material or
            cleartext indirectly.</item></list>
            <para>Applications should instead use dedicated security libraries
            to handle big numbers in security-sensitive algorithms.</para>
            <para><b>Reproducibility note</b></para>
            <para>See the reproducibility note in the EDecimal class's
            documentation.</para></summary>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(System.Boolean)~PeterO.Numbers.EFloat">
            <summary>Converts a boolean value (true or false) to an
            arbitrary-precision binary floating-point number.</summary>
            <param name='boolValue'>Either true or false.</param>
            <returns>The number 1 if <paramref name='boolValue'/> is true;
            otherwise, 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Single)~PeterO.Numbers.EFloat">
            <summary>Creates a binary floating-point number from a 32-bit
            floating-point number. This method computes the exact value of the
            floating point number, not an approximation, as is often the case
            by converting the floating point number to a string
            first.</summary>
            <param name='flt'>The parameter <paramref name='flt'/> is a 32-bit
            binary floating-point number.</param>
            <returns>A binary floating-point number with the same value as
            <paramref name='flt'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Double)~PeterO.Numbers.EFloat">
            <summary>Creates a binary floating-point number from a 64-bit
            floating-point number. This method computes the exact value of the
            floating point number, not an approximation, as is often the case
            by converting the floating point number to a string
            first.</summary>
            <param name='dbl'>The parameter <paramref name='dbl'/> is a 64-bit
            floating-point number.</param>
            <returns>A binary floating-point number with the same value as
            <paramref name='dbl'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.EFloat">
            <summary>Converts an arbitrary-precision integer to an arbitrary
            precision binary.</summary>
            <param name='eint'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision binary floating-point number with
            the exponent set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Addition(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Adds an arbitrary-precision binary floating-point number
            and another arbitrary-precision binary floating-point number and
            returns the result.</summary>
            <param name='bthis'>The first arbitrary-precision binary
            floating-point number.</param>
            <param name='otherValue'>The second arbitrary-precision binary
            floating-point number.</param>
            <returns>The sum of the two numbers, that is, an
            arbitrary-precision binary floating-point number plus another
            arbitrary-precision binary floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> or <paramref name='otherValue'/> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Subtraction(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Subtracts one arbitrary-precision binary floating-point
            number from another.</summary>
            <param name='bthis'>The first operand.</param>
            <param name='subtrahend'>The second operand.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Increment(PeterO.Numbers.EFloat)">
            <summary>Adds one to an arbitrary-precision binary floating-point
            number.</summary>
            <param name='bthis'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>The number given in <paramref name='bthis'/> plus
            one.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Decrement(PeterO.Numbers.EFloat)">
            <summary>Subtracts one from an arbitrary-precision binary
            floating-point number.</summary>
            <param name='bthis'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>The number given in <paramref name='bthis'/> minus
            one.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bthis'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Multiply(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Multiplies an arbitrary-precision binary floating-point
            number by another arbitrary-precision binary floating-point number
            and returns the result.</summary>
            <param name='operand1'>The first operand.</param>
            <param name='operand2'>The second operand.</param>
            <returns>The product of the two numbers, that is, an
            arbitrary-precision binary floating-point number times another
            arbitrary-precision binary floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='operand1'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Division(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Divides one binary floating-point number by another and
            returns the result. When possible, the result will be
            exact.</summary>
            <param name='dividend'>The number that will be divided by the
            divisor.</param>
            <param name='divisor'>The number to divide by.</param>
            <returns>The quotient of the two numbers. Returns infinity if the
            divisor is 0 and the dividend is nonzero. Returns not-a-number
            (NaN) if the divisor and the dividend are 0. Returns NaN if the
            result can't be exact because it would have a nonterminating binary
            expansion. If this is not desired, use DivideToExponent instead, or
            use the Divide overload that takes an EContext instead.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='dividend'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Modulus(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Returns the remainder that would result when an
            arbitrary-precision binary floating-point number is divided by
            another arbitrary-precision binary floating-point number. The
            remainder is the number that remains when the absolute value of an
            arbitrary-precision binary floating-point number is divided (as
            though by DivideToIntegerZeroScale) by the absolute value of the
            other arbitrary-precision binary floating-point number; the
            remainder has the same sign (positive or negative) as this
            arbitrary-precision binary floating-point number.</summary>
            <param name='dividend'>The number that will be divided by the
            divisor.</param>
            <param name='divisor'>The number to divide by.</param>
            <returns>The remainder that would result when an
            arbitrary-precision binary floating-point number is divided by
            another arbitrary-precision binary floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='dividend'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_UnaryNegation(PeterO.Numbers.EFloat)">
            <summary>Gets an object with the same value as this one, but with
            the sign reversed.</summary>
            <param name='bigValue'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>The negated form of the given number. If the given number
            is positive zero, returns negative zero. Returns signaling NaN if
            this value is signaling NaN.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~PeterO.Numbers.EInteger">
            <summary>Converts an arbitrary-precision binary floating-point
            number to a value to an arbitrary-precision integer. Any fractional
            part in this value will be discarded when converting to an
            arbitrary-precision integer.</summary>
            <param name='bigValue'>The number to convert as an
            arbitrary-precision binary floating-point number.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Double">
            <summary>Converts this value to its closest equivalent as a 64-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 64-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN. Unfortunately, in the.NET implementation, the return value of
            this method may be a quiet NaN even if a signaling NaN would
            otherwise be generated.</para></summary>
            <param name='bigValue'>The value to convert to a 64-bit
            floating-point number.</param>
            <returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Single">
            <summary>Converts an arbitrary-precision binary floating-point
            number to its closest equivalent as a 32-bit floating-point number.
            The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN. Unfortunately, in the.NET implementation, the return value of
            this method may be a quiet NaN even if a signaling NaN would
            otherwise be generated.</para></summary>
            <param name='bigValue'>The number to convert as an
            arbitrary-precision binary floating-point number.</param>
            <returns>The closest 32-bit binary floating-point number to this
            value. The return value can be positive infinity or negative
            infinity if this value exceeds the range of a 32-bit floating point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Byte">
            <summary>Converts an arbitrary-precision binary floating-point
            number to a byte (from 0 to 255) if it can fit in a byte (from 0 to
            255) after converting it to an integer by discarding its fractional
            part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            binary floating-point number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            byte (from 0 to 255).</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 255.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Byte)~PeterO.Numbers.EFloat">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputByte'>The number to convert as a byte (from 0 to
            255).</param>
            <returns>The value of <paramref name='inputByte'/> as an
            arbitrary-precision binary floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSByteChecked">
            <summary>Converts this number's value to an 8-bit signed integer if
            it can fit in an 8-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to an 8-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -128 or greater than
            127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSByteUnchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as an 8-bit signed integer.</summary>
            <returns>This number, converted to an 8-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSByteIfExact">
            <summary>Converts this number's value to an 8-bit signed integer if
            it can fit in an 8-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as an 8-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -128 or
            greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromSByte(System.SByte)">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputSByte'>The number to convert as an 8-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision binary
            floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.SByte">
            <summary>Converts an arbitrary-precision binary floating-point
            number to an 8-bit signed integer if it can fit in an 8-bit signed
            integer after converting it to an integer by discarding its
            fractional part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            binary floating-point number.</param>
            <returns>The value of <paramref name='input'/>, truncated to an
            8-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -128 or greater than 127.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.SByte)~PeterO.Numbers.EFloat">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputSByte'>The number to convert as an 8-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputSByte'/> as an
            arbitrary-precision binary floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int16">
            <summary>Converts an arbitrary-precision binary floating-point
            number to a 16-bit signed integer if it can fit in a 16-bit signed
            integer after converting it to an integer by discarding its
            fractional part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            binary floating-point number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            16-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -32768 or greater than 32767.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int16)~PeterO.Numbers.EFloat">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputInt16'>The number to convert as a 16-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt16'/> as an
            arbitrary-precision binary floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt16Checked">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer after converting it to
            an integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 16-bit unsigned
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt16Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 16-bit unsigned integer.</summary>
            <returns>This number, converted to a 16-bit unsigned integer.
            Returns 0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt16IfExact">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 16-bit unsigned
            integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromUInt16(System.UInt16)">
            <summary>Converts a 16-bit unsigned integer to an
            arbitrary-precision binary floating-point number.</summary>
            <param name='inputUInt16'>The number to convert as a 16-bit
            unsigned integer.</param>
            <returns>This number's value as an arbitrary-precision binary
            floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt16">
            <summary>Converts an arbitrary-precision binary floating-point
            number to a 16-bit unsigned integer if it can fit in a 16-bit
            unsigned integer after converting it to an integer by discarding
            its fractional part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            binary floating-point number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            16-bit unsigned integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 65535.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt16)~PeterO.Numbers.EFloat">
            <summary>Converts a 16-bit unsigned integer to an
            arbitrary-precision binary floating-point number.</summary>
            <param name='inputUInt16'>The number to convert as a 16-bit
            unsigned integer.</param>
            <returns>The value of <paramref name='inputUInt16'/> as an
            arbitrary-precision binary floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int32">
            <summary>Converts an arbitrary-precision binary floating-point
            number to a 32-bit signed integer if it can fit in a 32-bit signed
            integer after converting it to an integer by discarding its
            fractional part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            binary floating-point number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            32-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -2147483648 or greater than 2147483647.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int32)~PeterO.Numbers.EFloat">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt32'/> as an
            arbitrary-precision binary floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 32-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt32Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 32-bit signed integer.</summary>
            <returns>This number, converted to a 32-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 32-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromUInt32(System.UInt32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputUInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision binary
            floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt32">
            <summary>Converts an arbitrary-precision binary floating-point
            number to a 32-bit signed integer if it can fit in a 32-bit signed
            integer after converting it to an integer by discarding its
            fractional part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            binary floating-point number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            32-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 4294967295.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt32)~PeterO.Numbers.EFloat">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputUInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputUInt32'/> as an
            arbitrary-precision binary floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int64">
            <summary>Converts an arbitrary-precision binary floating-point
            number to a 64-bit signed integer if it can fit in a 64-bit signed
            integer after converting it to an integer by discarding its
            fractional part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            binary floating-point number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            64-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than -9223372036854775808 or greater than
            9223372036854775807.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int64)~PeterO.Numbers.EFloat">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputInt64'>The number to convert as a 64-bit signed
            integer.</param>
            <returns>The value of <paramref name='inputInt64'/> as an
            arbitrary-precision binary floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt64Checked">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer after converting it to
            an integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 64-bit unsigned
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt64Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 64-bit unsigned integer.</summary>
            <returns>This number, converted to a 64-bit unsigned integer.
            Returns 0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt64IfExact">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 64-bit unsigned
            integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromUInt64(System.UInt64)">
            <summary>Converts a 64-bit unsigned integer to an
            arbitrary-precision binary floating-point number.</summary>
            <param name='inputUInt64'>The number to convert as a 64-bit
            unsigned integer.</param>
            <returns>This number's value as an arbitrary-precision binary
            floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt64">
            <summary>Converts an arbitrary-precision binary floating-point
            number to a 64-bit unsigned integer if it can fit in a 64-bit
            unsigned integer after converting it to an integer by discarding
            its fractional part.</summary>
            <param name='input'>The number to convert as an arbitrary-precision
            binary floating-point number.</param>
            <returns>The value of <paramref name='input'/>, truncated to a
            64-bit unsigned integer.</returns>
            <exception cref='T:System.OverflowException'>The parameter <paramref
            name='input'/> is infinity or not-a-number, or the number, once
            converted to an integer by discarding its fractional part, is less
            than 0 or greater than 18446744073709551615.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='input'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt64)~PeterO.Numbers.EFloat">
            <summary>Converts a 64-bit unsigned integer to an
            arbitrary-precision binary floating-point number.</summary>
            <param name='inputUInt64'>The number to convert as a 64-bit
            unsigned integer.</param>
            <returns>The value of <paramref name='inputUInt64'/> as an
            arbitrary-precision binary floating-point number.</returns>
        </member>
        <member name="F:PeterO.Numbers.EFloat.NaN">
            <summary>A not-a-number value.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.NegativeInfinity">
            <summary>Negative infinity, less than any other number.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.NegativeZero">
            <summary>Represents the number negative zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.One">
            <summary>Represents the number 1.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.PositiveInfinity">
            <summary>Positive infinity, greater than any other
            number.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.SignalingNaN">
            <summary>A not-a-number value that signals an invalid operation
            flag when it's passed as an argument to any arithmetic operation in
            arbitrary-precision binary floating-point number.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.Ten">
            <summary>Represents the number 10.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.Zero">
            <summary>Represents the number 0.</summary>
        </member>
        <member name="P:PeterO.Numbers.EFloat.Exponent">
            <summary>Gets this object's exponent. This object's value will be
            an integer if the exponent is positive or zero.</summary>
            <value>This object's exponent. This object's value will be an
            integer if the exponent is positive or zero.</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.IsFinite">
            <summary>Gets a value indicating whether this object is finite (not
            infinity or not-a-number, NaN).</summary>
            <value><c>true</c> if this object is finite (not infinity or
            not-a-number, NaN); otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.IsNegative">
            <summary>Gets a value indicating whether this object is negative,
            including negative zero.</summary>
            <value><c>true</c> if this object is negative, including negative
            zero; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.IsZero">
            <summary>Gets a value indicating whether this object's value equals
            0.</summary>
            <value><c>true</c> if this object's value equals 0; otherwise,
            <c>false</c>. <c>true</c> if this object's value equals 0;
            otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.Mantissa">
            <summary>Gets this object's unscaled value, or significand, and
            makes it negative if this object is negative. If this value is
            not-a-number (NaN), that value's absolute value is the NaN's
            "payload" (diagnostic information).</summary>
            <value>This object's unscaled value. Will be negative if this
            object's value is negative (including a negative NaN).</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.Sign">
            <summary>Gets this value's sign: -1 if negative; 1 if positive; 0
            if zero.</summary>
            <value>This value's sign: -1 if negative; 1 if positive; 0 if
            zero.</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.UnsignedMantissa">
            <summary>Gets the absolute value of this object's unscaled value,
            or significand. If this value is not-a-number (NaN), that value is
            the NaN's "payload" (diagnostic information).</summary>
            <value>The absolute value of this object's unscaled value.</value>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Copy">
            <summary>Creates a copy of this arbitrary-precision binary
            number.</summary>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Create(System.Int32,System.Int32)">
            <summary>Returns an arbitrary-precision number with the value
            <c>exponent*2^significand</c>.</summary>
            <param name='mantissaSmall'>Desired value for the
            significand.</param>
            <param name='exponentSmall'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision binary number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Create(PeterO.Numbers.EInteger,System.Int32)">
            <summary>Returns an arbitrary-precision number with the value
            <c>exponent*2^significand</c>.</summary>
            <param name='mantissa'>Desired value for the significand.</param>
            <param name='exponentSmall'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision binary number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='mantissa'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Create(PeterO.Numbers.EInteger,System.Int64)">
            <summary>Returns an arbitrary-precision number with the value
            <c>exponent*2^significand</c>.</summary>
            <param name='mantissa'>Desired value for the significand.</param>
            <param name='exponentLong'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision binary number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='mantissa'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Returns an arbitrary-precision number with the value
            <c>exponent*2^significand</c>.</summary>
            <param name='mantissa'>Desired value for the significand.</param>
            <param name='exponent'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision binary number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='mantissa'/> or <paramref name='exponent'/> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Create(System.Int64,System.Int32)">
            <summary>Returns an arbitrary-precision number with the value
            <c>exponent*2^significand</c>.</summary>
            <param name='mantissaLong'>Desired value for the
            significand.</param>
            <param name='exponentSmall'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision binary number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Create(System.Int64,System.Int64)">
            <summary>Returns an arbitrary-precision number with the value
            <c>exponent*2^significand</c>.</summary>
            <param name='mantissaLong'>Desired value for the
            significand.</param>
            <param name='exponentLong'>Desired value for the exponent.</param>
            <returns>An arbitrary-precision binary number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CreateNaN(PeterO.Numbers.EInteger)">
            <summary>Creates a not-a-number arbitrary-precision binary
            number.</summary>
            <param name='diag'>An integer, 0 or greater, to use as diagnostic
            information associated with this object. If none is needed, should
            be zero. To get the diagnostic information from another
            arbitrary-precision binary floating-point number, use that object's
            <c>UnsignedMantissa</c> property.</param>
            <returns>A quiet not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean,PeterO.Numbers.EContext)">
            <summary>Creates a not-a-number arbitrary-precision binary
            number.</summary>
            <param name='diag'>An integer, 0 or greater, to use as diagnostic
            information associated with this object. If none is needed, should
            be zero. To get the diagnostic information from another
            arbitrary-precision binary floating-point number, use that object's
            <c>UnsignedMantissa</c> property.</param>
            <param name='signaling'>Whether the return value will be signaling
            (true) or quiet (false).</param>
            <param name='negative'>Whether the return value is
            negative.</param>
            <param name='ctx'>An arithmetic context to control the precision
            (in binary digits) of the diagnostic information. The rounding and
            exponent range of this context will be ignored. Can be null. The
            only flag that can be signaled in this context is FlagInvalid,
            which happens if diagnostic information needs to be truncated and
            too much memory is required to do so.</param>
            <returns>An arbitrary-precision binary number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='diag'/> is null or is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromDoubleBits(System.Int64)">
            <summary>Creates a binary floating-point number from a 64-bit
            floating-point number encoded in the IEEE 754 binary64 format. This
            method computes the exact value of the floating point number, not
            an approximation, as is often the case by converting the floating
            point number to a string first.</summary>
            <param name='dblBits'>The parameter <paramref name='dblBits'/> is a
            64-bit signed integer.</param>
            <returns>A binary floating-point number with the same value as the
            floating-point number encoded in <paramref
            name='dblBits'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromSingle(System.Single)">
            <summary>Creates a binary floating-point number from a 32-bit
            floating-point number. This method computes the exact value of the
            floating point number, not an approximation, as is often the case
            by converting the floating point number to a string
            first.</summary>
            <param name='flt'>The parameter <paramref name='flt'/> is a 64-bit
            floating-point number.</param>
            <returns>A binary floating-point number with the same value as
            <paramref name='flt'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromDouble(System.Double)">
            <summary>Creates a binary floating-point number from a 64-bit
            floating-point number. This method computes the exact value of the
            floating point number, not an approximation, as is often the case
            by converting the floating point number to a string
            first.</summary>
            <param name='dbl'>The parameter <paramref name='dbl'/> is a 64-bit
            floating-point number.</param>
            <returns>A binary floating-point number with the same value as
            <paramref name='dbl'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromEInteger(PeterO.Numbers.EInteger)">
            <summary>Converts an arbitrary-precision integer to the same value
            as a binary floating-point number.</summary>
            <param name='bigint'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromSingleBits(System.Int32)">
            <summary>Creates a binary floating-point number from a 32-bit
            floating-point number encoded in the IEEE 754 binary32 format. This
            method computes the exact value of the floating point number, not
            an approximation, as is often the case by converting the floating
            point number to a string first.</summary>
            <param name='value'>A 32-bit binary floating-point number encoded
            in the IEEE 754 binary32 format.</param>
            <returns>A binary floating-point number with the same
            floating-point value as <paramref name='value'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.String,System.Int32,System.Int32,PeterO.Numbers.EContext)">
            <summary>Creates a binary floating-point number from a text string
            that represents a number. Note that if the string contains a
            negative exponent, the resulting value might not be exact, in which
            case the resulting binary floating-point number will be an
            approximation of this decimal number's value.
            <para>The format of the string generally consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            (".", U+002E) before or after those digits or between two of them.
            These digits may begin with any number of zeros.</item>
            <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-"
            (negative exponent) plus one or more digits specifying the exponent
            (these digits may begin with any number of zeros).</item></list>
            <para>The string can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN") followed by any number of digits (these
            digits may begin with any number of zeros), or signaling NaN
            ("sNaN") followed by any number of digits (these digits may begin
            with any number of zeros), all where the letters can be any
            combination of basic upper-case and/or basic lower-case
            letters.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The string is not
            allowed to contain white space characters, including
            spaces.</para></summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref
            name='str'/> 's length).</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited. Note that
            providing a context is often much faster than creating an EDecimal
            without a context then calling ToEFloat on that EDecimal,
            especially if the context specifies a precision limit and exponent
            range.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:System.FormatException'>The portion given of <paramref
            name='str'/> is not a correctly formatted number string; or either
            <paramref name='offset'/> or <paramref name='length'/> is less than
            0 or greater than <paramref name='str'/> 's length, or <paramref
            name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.String)">
            <summary>Creates a binary floating-point number from a text string
            that represents a number, using an unlimited precision context. For
            more information, see the <c>FromString(String, int, int,
            EContext)</c> method.</summary>
            <param name='str'>A text string to convert to a binary
            floating-point number.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:System.FormatException'>The portion given of <paramref
            name='str'/> is not a correctly formatted number
            string.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.String,PeterO.Numbers.EContext)">
            <summary>Creates a binary floating-point number from a text string
            that represents a number. For more information, see the
            <c>FromString(String, int, int, EContext)</c> method.</summary>
            <param name='str'>A text string to convert to a binary
            floating-point number.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited. Note that
            providing a context is often much faster than creating an EDecimal
            without a context then calling ToEFloat on that EDecimal,
            especially if the context specifies a precision limit and exponent
            range.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.String,System.Int32,System.Int32)">
            <summary>Creates a binary floating-point number from a text string
            that represents a number. For more information, see the
            <c>FromString(String, int, int, EContext)</c> method.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref
            name='str'/> 's length).</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
            <exception cref=' T:System.ArgumentException'>Either <paramref
            name=' offset'/> or <paramref name=' length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref name='
            str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref
            name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.Char[],System.Int32,System.Int32,PeterO.Numbers.EContext)">
            <summary>Creates a binary floating-point number from a sequence of
            <c>char</c> s that represents a number. Note that if the sequence
            contains a negative exponent, the resulting value might not be
            exact, in which case the resulting binary floating-point number
            will be an approximation of this decimal number's value.
            <para>The format of the sequence generally consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            (".", U+002E) before or after those digits or between two of them.
            These digits may begin with any number of zeros.</item>
            <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-"
            (negative exponent) plus one or more digits specifying the exponent
            (these digits may begin with any number of zeros).</item></list>
            <para>The sequence can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN") followed by any number of digits (these
            digits may begin with any number of zeros), or signaling NaN
            ("sNaN") followed by any number of digits (these digits may begin
            with any number of zeros), all where the letters can be any
            combination of basic upper-case and/or basic lower-case
            letters.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The sequence is not
            allowed to contain white space characters, including
            spaces.</para></summary>
            <param name='chars'>A sequence of <c>char</c> s to convert to a
            binary floating-point number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='chars'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='chars'/> (but not more than <paramref
            name='chars'/> 's length).</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited. Note that
            providing a context is often much faster than creating an EDecimal
            without a context then calling ToEFloat on that EDecimal,
            especially if the context specifies a precision limit and exponent
            range.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='chars'/> is null.</exception>
            <exception cref='T:System.FormatException'>The portion given of <paramref
            name='chars'/> is not a correctly formatted number sequence; or
            either <paramref name='offset'/> or <paramref name='length'/> is
            less than 0 or greater than <paramref name='chars'/> 's length, or
            <paramref name='chars'/> 's length minus <paramref name='offset'/>
            is less than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.Char[])">
            <summary>Creates a binary floating-point number from a sequence of
            <c>char</c> s that represents a number, using an unlimited
            precision context. For more information, see the
            <c>FromString(String, int, int, EContext)</c> method.</summary>
            <param name='chars'>A sequence of <c>char</c> s to convert to a
            binary floating-point number.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='chars'/> is null.</exception>
            <exception cref='T:System.FormatException'>The portion given of <paramref
            name='chars'/> is not a correctly formatted number
            sequence.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.Char[],PeterO.Numbers.EContext)">
            <summary>Creates a binary floating-point number from a sequence of
            <c>char</c> s that represents a number. For more information, see
            the <c>FromString(String, int, int, EContext)</c> method.</summary>
            <param name='chars'>A sequence of <c>char</c> s to convert to a
            binary floating-point number.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited. Note that
            providing a context is often much faster than creating an EDecimal
            without a context then calling ToEFloat on that EDecimal,
            especially if the context specifies a precision limit and exponent
            range.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='chars'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.Char[],System.Int32,System.Int32)">
            <summary>Creates a binary floating-point number from a sequence of
            <c>char</c> s that represents a number. For more information, see
            the <c>FromString(String, int, int, EContext)</c> method.</summary>
            <param name='chars'>A sequence of <c>char</c> s to convert to a
            binary floating-point number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='chars'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='chars'/> (but not more than <paramref
            name='chars'/> 's length).</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='chars'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='chars'/> 's length, or <paramref
            name='chars'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.Byte[],System.Int32,System.Int32,PeterO.Numbers.EContext)">
            <summary>Creates a binary floating-point number from a sequence of
            bytes that represents a number. Note that if the sequence contains
            a negative exponent, the resulting value might not be exact, in
            which case the resulting binary floating-point number will be an
            approximation of this decimal number's value.
            <para>The format of the sequence generally consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            (".", U+002E) before or after those digits or between two of them.
            These digits may begin with any number of zeros.</item>
            <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-"
            (negative exponent) plus one or more digits specifying the exponent
            (these digits may begin with any number of zeros).</item></list>
            <para>The sequence can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN") followed by any number of digits (these
            digits may begin with any number of zeros), or signaling NaN
            ("sNaN") followed by any number of digits (these digits may begin
            with any number of zeros), all where the letters can be any
            combination of basic upper-case and/or basic lower-case
            letters.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The sequence is not
            allowed to contain white space characters, including
            spaces.</para></summary>
            <param name='bytes'>A sequence of bytes to convert to a binary
            floating-point number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='bytes'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='bytes'/> (but not more than <paramref
            name='bytes'/> 's length).</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited. Note that
            providing a context is often much faster than creating an EDecimal
            without a context then calling ToEFloat on that EDecimal,
            especially if the context specifies a precision limit and exponent
            range.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.FormatException'>The portion given of <paramref
            name='bytes'/> is not a correctly formatted number sequence; or
            either <paramref name='offset'/> or <paramref name='length'/> is
            less than 0 or greater than <paramref name='bytes'/> 's length, or
            <paramref name='bytes'/> 's length minus <paramref name='offset'/>
            is less than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.Byte[])">
            <summary>Creates a binary floating-point number from a sequence of
            bytes that represents a number, using an unlimited precision
            context. For more information, see the <c>FromString(String, int,
            int, EContext)</c> method.</summary>
            <param name='bytes'>A sequence of bytes to convert to a binary
            floating-point number.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.FormatException'>The portion given of <paramref
            name='bytes'/> is not a correctly formatted number
            sequence.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.Byte[],PeterO.Numbers.EContext)">
            <summary>Creates a binary floating-point number from a sequence of
            bytes that represents a number. For more information, see the
            <c>FromString(String, int, int, EContext)</c> method.</summary>
            <param name='bytes'>A sequence of bytes to convert to a binary
            floating-point number.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited. Note that
            providing a context is often much faster than creating an EDecimal
            without a context then calling ToEFloat on that EDecimal,
            especially if the context specifies a precision limit and exponent
            range.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.Byte[],System.Int32,System.Int32)">
            <summary>Creates a binary floating-point number from a sequence of
            bytes that represents a number. For more information, see the
            <c>FromString(String, int, int, EContext)</c> method.</summary>
            <param name='bytes'>A sequence of bytes to convert to a binary
            floating-point number.</param>
            <param name='offset'>An index starting at 0 showing where the
            desired portion of <paramref name='bytes'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='bytes'/> (but not more than <paramref
            name='bytes'/> 's length).</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bytes'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref
            name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='bytes'/> 's length, or <paramref
            name='bytes'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Max(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Gets the greater value between two binary floating-point
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>The larger value of the two numbers. If one is positive
            zero and the other is negative zero, returns the positive zero. If
            the two numbers are positive and have the same value, returns the
            one with the larger exponent. If the two numbers are negative and
            have the same value, returns the one with the smaller
            exponent.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Max(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Gets the greater value between two binary floating-point
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The larger value of the two numbers. If one is positive
            zero and the other is negative zero, returns the positive zero. If
            the two numbers are positive and have the same value, returns the
            one with the larger exponent. If the two numbers are negative and
            have the same value, returns the one with the smaller
            exponent.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MaxMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>The larger value of the two numbers, ignoring their
            signs.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MaxMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The larger value of the two numbers, ignoring their
            signs.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Min(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Gets the lesser value between two binary floating-point
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>The smaller value of the two numbers. If one is positive
            zero and the other is negative zero, returns the negative zero. If
            the two numbers are positive and have the same value, returns the
            one with the smaller exponent. If the two numbers are negative and
            have the same value, returns the one with the larger
            exponent.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Min(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Gets the lesser value between two binary floating-point
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The smaller value of the two numbers. If one is positive
            zero and the other is negative zero, returns the negative zero. If
            the two numbers are positive and have the same value, returns the
            one with the smaller exponent. If the two numbers are negative and
            have the same value, returns the one with the larger
            exponent.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MinMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>The smaller value of the two numbers, ignoring their
            signs.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MinMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The smaller value of the two numbers, ignoring their
            signs.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='first'/> or <paramref name='second'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.PI(PeterO.Numbers.EContext)">
            <summary>Finds the constant , the circumference of a circle
            divided by its diameter.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as  can never be represented
            exactly.</i>.</param>
            <returns>The constant  rounded to the given precision. Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Abs">
            <summary>Finds the absolute value of this object (if it's negative,
            it becomes positive).</summary>
            <returns>An arbitrary-precision binary floating-point number.
            Returns signaling NaN if this value is signaling NaN. (In this
            sense, this method is similar to the "copy-abs" operation in the
            General Decimal Arithmetic Specification, except this method does
            not necessarily return a copy of this object.).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Abs(PeterO.Numbers.EContext)">
            <summary>Finds the absolute value of this object (if it's negative,
            it becomes positive).</summary>
            <param name='context'>An arithmetic context to control the
            precision, rounding, and exponent range of the result. If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the precision is
            unlimited and no rounding is needed.</param>
            <returns>The absolute value of this object. Signals FlagInvalid and
            returns quiet NaN if this value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Add(System.Int32)">
            <summary>Adds this arbitrary-precision binary floating-point number
            and a 32-bit signed integer and returns the result. The exponent
            for the result is the lower of this arbitrary-precision binary
            floating-point number's exponent and the other 32-bit signed
            integer's exponent.</summary>
            <param name='intValue'>The parameter <paramref name='intValue'/> is
            a 32-bit signed integer.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision binary floating-point number plus a 32-bit
            signed integer. If this arbitrary-precision binary floating-point
            number is not-a-number (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Subtract(System.Int32)">
            <summary>Subtracts a 32-bit signed integer from this
            arbitrary-precision binary floating-point number and returns the
            result. The exponent for the result is the lower of this
            arbitrary-precision binary floating-point number's exponent and the
            other 32-bit signed integer's exponent.</summary>
            <param name='intValue'>The parameter <paramref name='intValue'/> is
            a 32-bit signed integer.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision binary floating-point number minus a 32-bit
            signed integer. If this arbitrary-precision binary floating-point
            number is not-a-number (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Multiply(System.Int32)">
            <summary>Multiplies this arbitrary-precision binary floating-point
            number by a 32-bit signed integer and returns the result. The
            exponent for the result is this arbitrary-precision binary
            floating-point number's exponent plus the other 32-bit signed
            integer's exponent.</summary>
            <param name='intValue'>The parameter <paramref name='intValue'/> is
            a 32-bit signed integer.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision binary floating-point number times a 32-bit
            signed integer.</returns>
            <example>
            <code>EInteger result = EInteger.FromString("5").Multiply(200);</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Divide(System.Int32)">
            <summary>Divides this arbitrary-precision binary floating-point
            number by a 32-bit signed integer and returns the result; returns
            NaN instead if the result would have a nonterminating binary
            expansion (including 1/3, 1/12, 1/7, 2/3, and so on); if this is
            not desired, use DivideToExponent, or use the Divide overload that
            takes an EContext.</summary>
            <param name='intValue'>The divisor.</param>
            <returns>The result of dividing this arbitrary-precision binary
            floating-point number by a 32-bit signed integer. Returns infinity
            if the divisor (this arbitrary-precision binary floating-point
            number) is 0 and the dividend (the other 32-bit signed integer) is
            nonzero. Returns not-a-number (NaN) if the divisor and the dividend
            are 0. Returns NaN if the result can't be exact because it would
            have a nonterminating binary expansion (examples include 1 divided
            by any multiple of 3, such as 1/3 or 1/12). If this is not desired,
            use DivideToExponent instead, or use the Divide overload that takes
            an <c>EContext</c> (such as <c>EContext.Binary64</c> )
            instead.</returns>
            <exception cref='T:System.DivideByZeroException'>Attempted to divide by
            zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Add(System.Int64)">
            <summary>Adds this arbitrary-precision binary floating-point number
            and a 64-bit signed integer and returns the result. The exponent
            for the result is the lower of this arbitrary-precision binary
            floating-point number's exponent and the other 64-bit signed
            integer's exponent.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision binary floating-point number plus a 64-bit
            signed integer. If this arbitrary-precision binary floating-point
            number is not-a-number (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Subtract(System.Int64)">
            <summary>Subtracts a 64-bit signed integer from this
            arbitrary-precision binary floating-point number and returns the
            result. The exponent for the result is the lower of this
            arbitrary-precision binary floating-point number's exponent and the
            other 64-bit signed integer's exponent.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision binary floating-point number minus a 64-bit
            signed integer. If this arbitrary-precision binary floating-point
            number is not-a-number (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Multiply(System.Int64)">
            <summary>Multiplies this arbitrary-precision binary floating-point
            number by a 64-bit signed integer and returns the result. The
            exponent for the result is this arbitrary-precision binary
            floating-point number's exponent plus the other 64-bit signed
            integer's exponent.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision binary floating-point number times a 64-bit
            signed integer.</returns>
            <example>
            <code>EInteger result = EInteger.FromString("5").Multiply(200L);</code>
             .
            </example>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Divide(System.Int64)">
            <summary>Divides this arbitrary-precision binary floating-point
            number by a 64-bit signed integer and returns the result; returns
            NaN instead if the result would have a nonterminating binary
            expansion (including 1/3, 1/12, 1/7, 2/3, and so on); if this is
            not desired, use DivideToExponent, or use the Divide overload that
            takes an EContext.</summary>
            <param name='longValue'>The parameter <paramref name='longValue'/>
            is a 64-bit signed integer.</param>
            <returns>The result of dividing this arbitrary-precision binary
            floating-point number by a 64-bit signed integer. Returns infinity
            if the divisor (this arbitrary-precision binary floating-point
            number) is 0 and the dividend (the other 64-bit signed integer) is
            nonzero. Returns not-a-number (NaN) if the divisor and the dividend
            are 0. Returns NaN if the result can't be exact because it would
            have a nonterminating binary expansion (examples include 1 divided
            by any multiple of 3, such as 1/3 or 1/12). If this is not desired,
            use DivideToExponent instead, or use the Divide overload that takes
            an <c>EContext</c> (such as <c>EContext.Binary64</c> )
            instead.</returns>
            <exception cref='T:System.DivideByZeroException'>Attempted to divide by
            zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Add(PeterO.Numbers.EFloat)">
            <summary>Adds this arbitrary-precision binary floating-point number
            and another arbitrary-precision binary floating-point number and
            returns the result. The exponent for the result is the lower of
            this arbitrary-precision binary floating-point number's exponent
            and the other arbitrary-precision binary floating-point number's
            exponent.</summary>
            <param name='otherValue'>An arbitrary-precision binary
            floating-point number.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision binary floating-point number plus another
            arbitrary-precision binary floating-point number. If this
            arbitrary-precision binary floating-point number is not-a-number
            (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Add(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Adds this arbitrary-precision binary floating-point number
            and another arbitrary-precision binary floating-point number and
            returns the result.</summary>
            <param name='otherValue'>The number to add to.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param>
            <returns>The sum of the two numbers, that is, this
            arbitrary-precision binary floating-point number plus another
            arbitrary-precision binary floating-point number. If this
            arbitrary-precision binary floating-point number is not-a-number
            (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareTo(PeterO.Numbers.EFloat)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values. This method currently uses
            the rules given in the CompareToValue method, so that it it is not
            consistent with the Equals method, but it may change in a future
            version to use the rules for the CompareToTotal method
            instead.</summary>
            <param name='other'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value or if <paramref name='other'/> is null, or 0 if both
            values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToValue(PeterO.Numbers.EFloat)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will not trigger an error. Instead, NaN
            will compare greater than any other number, including infinity. Two
            different NaN values will be considered equal.</para></summary>
            <param name='other'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value or if <paramref name='other'/> is null, or 0 if both
            values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareTo(System.Int32)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values. This method currently uses
            the rules given in the CompareToValue method, so that it it is not
            consistent with the Equals method, but it may change in a future
            version to use the rules for the CompareToTotal method
            instead.</summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 32-bit signed integer.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value, or 0 if both values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToValue(System.Int32)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object is a quiet NaN or signaling NaN, this method
            will not trigger an error. Instead, NaN will compare greater than
            any other number.</para></summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 32-bit signed integer.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value, or 0 if both values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToValue(System.Int64)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object is a quiet NaN or signaling NaN, this method
            will not trigger an error. Instead, NaN will compare greater than
            any other number, including infinity.</para></summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 64-bit signed integer.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value, or 0 if both values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareTo(System.Int64)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values. This method currently uses
            the rules given in the CompareToValue method, so that it it is not
            consistent with the Equals method, but it may change in a future
            version to use the rules for the CompareToTotal method
            instead.</summary>
            <param name='intOther'>The parameter <paramref name='intOther'/> is
            a 64-bit signed integer.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value, or 0 if both values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToSignal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Compares the mathematical values of this object and
            another object, treating quiet NaN as signaling.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will return a quiet NaN and will signal
            a FlagInvalid flag.</para></summary>
            <param name='other'>An arbitrary-precision binary floating-point
            number.</param>
            <param name='ctx'>An arithmetic context. The precision, rounding,
            and exponent range are ignored. If <c>HasFlags</c> of the context
            is true, will store the flags resulting from the operation (the
            flags are in addition to the pre-existing flags). Can be
            null.</param>
            <returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToTotal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary>
            <param name='other'>An arbitrary-precision binary floating-point
            number to compare with this one.</param>
            <param name='ctx'>An arithmetic context. Flags will be set in this
            context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
            context are true and only if an operand needed to be rounded before
            carrying out the operation. Can be null.</param>
            <returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater. Does not signal flags if either value is signaling NaN.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToTotalMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values (ignoring their
            signs). In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary>
            <param name='other'>An arbitrary-precision binary floating-point
            number to compare with this one.</param>
            <param name='ctx'>An arithmetic context. Flags will be set in this
            context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
            context are true and only if an operand needed to be rounded before
            carrying out the operation. Can be null.</param>
            <returns>The number 0 if both objects have the same value (ignoring
            their signs), or -1 if this object is less than the other value
            (ignoring their signs), or 1 if this object is greater (ignoring
            their signs). Does not signal flags if either value is signaling
            NaN.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToTotal(PeterO.Numbers.EFloat)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary>
            <param name='other'>An arbitrary-precision binary floating-point
            number to compare with this one.</param>
            <returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToTotalMagnitude(PeterO.Numbers.EFloat)">
            <summary>Compares the absolute values of this object and another
            object, imposing a total ordering on all possible values (ignoring
            their signs). In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero and positive zero are considered equal.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item></list></summary>
            <param name='other'>An arbitrary-precision binary floating-point
            number to compare with this one.</param>
            <returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToWithContext(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Compares the mathematical values of this object and
            another object.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method returns a quiet NaN, and will signal a
            FlagInvalid flag if either is a signaling NaN.</para></summary>
            <param name='other'>An arbitrary-precision binary floating-point
            number.</param>
            <param name='ctx'>An arithmetic context. The precision, rounding,
            and exponent range are ignored. If <c>HasFlags</c> of the context
            is true, will store the flags resulting from the operation (the
            flags are in addition to the pre-existing flags). Can be
            null.</param>
            <returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.
            <para>This implementation returns a positive number if <paramref
            name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CopySign(PeterO.Numbers.EFloat)">
            <summary>Returns a number with the same value as this one, but
            copying the sign (positive or negative) of another number. (This
            method is similar to the "copy-sign" operation in the General
            Decimal Arithmetic Specification, except this method does not
            necessarily return a copy of this object.).</summary>
            <param name='other'>A number whose sign will be copied.</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='other'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Divide(PeterO.Numbers.EFloat)">
            <summary>Divides this arbitrary-precision binary floating-point
            number by another arbitrary-precision binary floating-point number
            and returns the result; returns NaN instead if the result would
            have a nonterminating binary expansion (including 1/3, 1/12, 1/7,
            2/3, and so on); if this is not desired, use DivideToExponent, or
            use the Divide overload that takes an EContext.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>The result of dividing this arbitrary-precision binary
            floating-point number by another arbitrary-precision binary
            floating-point number. Returns infinity if the divisor (this
            arbitrary-precision binary floating-point number) is 0 and the
            dividend (the other arbitrary-precision binary floating-point
            number) is nonzero. Returns not-a-number (NaN) if the divisor and
            the dividend are 0. Returns NaN if the result can't be exact
            because it would have a nonterminating binary expansion (examples
            include 1 divided by any multiple of 3, such as 1/3 or 1/12). If
            this is not desired, use DivideToExponent instead, or use the
            Divide overload that takes an <c>EContext</c> (such as
            <c>EContext.Binary64</c> ) instead.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Divide(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Divides this arbitrary-precision binary floating-point
            number by another arbitrary-precision binary floating-point number
            and returns the result.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param>
            <returns>The result of dividing this arbitrary-precision binary
            floating-point number by another arbitrary-precision binary
            floating-point number. Signals FlagDivideByZero and returns
            infinity if the divisor (this arbitrary-precision binary
            floating-point number) is 0 and the dividend (the other
            arbitrary-precision binary floating-point number) is nonzero.
            Signals FlagInvalid and returns not-a-number (NaN) if the divisor
            and the dividend are 0; or, either <paramref name='ctx'/> is null
            or <paramref name='ctx'/> 's precision is 0, and the result would
            have a nonterminating decimal expansion (examples include 1 divided
            by any multiple of 3, such as 1/3 or 1/12); or, the rounding mode
            is ERounding.None and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the remainder to have a
            higher precision than given in this context. Flags will be set on
            the given context only if the context's <c>HasFlags</c> is true and
            the integer part of the division result doesn't fit the precision
            and exponent range without rounding. Can be null, in which the
            precision is unlimited and no additional rounding, other than the
            rounding down to an integer after division, is needed.</param>
            <returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,System.Int64,PeterO.Numbers.EContext)">
            <summary>Divides two arbitrary-precision binary floating-point
            numbers, and gives a particular exponent to the result.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='desiredExponentSmall'>The desired exponent. A negative
            number places the cutoff point to the right of the usual radix
            point (so a negative number means the number of binary digit places
            to round to). A positive number places the cutoff point to the left
            of the usual radix point.</param>
            <param name='ctx'>An arithmetic context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is ERounding.None
            and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,System.Int64,PeterO.Numbers.ERounding)">
            <summary>Divides two arbitrary-precision binary floating-point
            numbers, and gives a particular exponent to the result.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='desiredExponentSmall'>The desired exponent. A negative
            number places the cutoff point to the right of the usual radix
            point (so a negative number means the number of binary digit places
            to round to). A positive number places the cutoff point to the left
            of the usual radix point.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Divides two arbitrary-precision binary floating-point
            numbers, and gives a particular exponent to the result.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='exponent'>The desired exponent. A negative number
            places the cutoff point to the right of the usual radix point (so a
            negative number means the number of binary digit places to round
            to). A positive number places the cutoff point to the left of the
            usual radix point.</param>
            <param name='ctx'>An arithmetic context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is ERounding.None
            and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">
            <summary>Divides two arbitrary-precision binary floating-point
            numbers, and gives a particular exponent to the result.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='desiredExponent'>The desired exponent. A negative
            number places the cutoff point to the right of the usual radix
            point (so a negative number means the number of binary digit places
            to round to). A positive number places the cutoff point to the left
            of the usual radix point.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Returns not-a-number (NaN) if the divisor and the dividend
            are 0. Returns NaN if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToIntegerNaturalScale(PeterO.Numbers.EFloat)">
            <summary>Divides two arbitrary-precision binary floating-point
            numbers, and returns the integer part of the result, rounded down,
            with the preferred exponent set to this value's exponent minus the
            divisor's exponent.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>The integer part of the quotient of the two objects.
            Signals FlagDivideByZero and returns infinity if the divisor is 0
            and the dividend is nonzero. Signals FlagInvalid and returns
            not-a-number (NaN) if the divisor and the dividend are 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToIntegerNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Divides this object by another object, and returns the
            integer part of the result (which is initially rounded down), with
            the preferred exponent set to this value's exponent minus the
            divisor's exponent.</summary>
            <param name='divisor'>An arbitrary-precision binary floating-point
            number.</param>
            <param name='ctx'>The parameter <paramref name='ctx'/> is an
            EContext object.</param>
            <returns>The integer part of the quotient of the two objects.
            Signals FlagInvalid and returns not-a-number (NaN) if the return
            value would overflow the exponent range. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToIntegerZeroScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Divides this object by another object, and returns the
            integer part of the result, with the exponent set to 0.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored. If <c>HasFlags</c> of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited.</param>
            <returns>The integer part of the quotient of the two objects. The
            exponent will be set to 0. Signals FlagDivideByZero and returns
            infinity if the divisor is 0 and the dividend is nonzero. Signals
            FlagInvalid and returns not-a-number (NaN) if the divisor and the
            dividend are 0, or if the result doesn't fit the given
            precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToSameExponent(PeterO.Numbers.EFloat,PeterO.Numbers.ERounding)">
            <summary>Divides this object by another binary floating-point
            number and returns a result with the same exponent as this object
            (the dividend).</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two numbers. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivRemNaturalScale(PeterO.Numbers.EFloat)">
            <summary>Divides this arbitrary-precision binary floating-point
            number by another arbitrary-precision binary floating-point number
            and returns a two-item array containing the result of the division
            and the remainder, in that order. The result of division is
            calculated as though by <c>DivideToIntegerNaturalScale</c>, and
            the remainder is calculated as though by
            <c>RemainderNaturalScale</c>.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>An array of two items: the first is the result of the
            division as an arbitrary-precision binary floating-point number,
            and the second is the remainder as an arbitrary-precision binary
            floating-point number. The result of division is the result of the
            method on the two operands, and the remainder is the result of the
            Remainder method on the two operands.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivRemNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Divides this arbitrary-precision binary floating-point
            number by another arbitrary-precision binary floating-point number
            and returns a two-item array containing the result of the division
            and the remainder, in that order. The result of division is
            calculated as though by <c>DivideToIntegerNaturalScale</c>, and
            the remainder is calculated as though by
            <c>RemainderNaturalScale</c>.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the remainder to have a
            higher precision than given in this context. Flags will be set on
            the given context only if the context's <c>HasFlags</c> is true and
            the integer part of the division result doesn't fit the precision
            and exponent range without rounding. Can be null, in which the
            precision is unlimited and no additional rounding, other than the
            rounding down to an integer after division, is needed.</param>
            <returns>An array of two items: the first is the result of the
            division as an arbitrary-precision binary floating-point number,
            and the second is the remainder as an arbitrary-precision binary
            floating-point number. The result of division is the result of the
            method on the two operands, and the remainder is the result of the
            Remainder method on the two operands.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Equals(PeterO.Numbers.EFloat)">
            <summary>Determines whether this object's significand, exponent,
            and properties are equal to those of another object. Not-a-number
            values are considered equal if the rest of their properties are
            equal.</summary>
            <param name='other'>An arbitrary-precision binary floating-point
            number.</param>
            <returns><c>true</c> if this object's significand and exponent are
            equal to those of another object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Equals(System.Object)">
            <summary>Determines whether this object's significand, exponent,
            and properties are equal to those of another object and that other
            object is an arbitrary-precision binary floating-point number.
            Not-a-number values are considered equal if the rest of their
            properties are equal.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if the objects are equal; otherwise,
            <c>false</c>. In this method, two objects are not equal if they
            don't have the same type or if one is null and the other
            isn't.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.EqualsInternal(PeterO.Numbers.EFloat)">
            <summary>Determines whether this object's significand and exponent
            are equal to those of another object.</summary>
            <param name='otherValue'>An arbitrary-precision binary
            floating-point number.</param>
            <returns><c>true</c> if this object's significand and exponent are
            equal to those of another object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Exp(PeterO.Numbers.EContext)">
            <summary>Finds e (the base of natural logarithms) raised to the
            power of this object's value.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the exponential function's
            results are generally not exact.</i> (Unlike in the General Binary
            Arithmetic Specification, any rounding mode is allowed.).</param>
            <returns>Exponential of this object. If this object's value is 1,
            returns an approximation to " e" within the given precision.
            Signals FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ExpM1(PeterO.Numbers.EContext)">
            <summary>Finds e (the base of natural logarithms) raised to the
            power of this object's value, and subtracts the result by 1 and
            returns the final result, in a way that avoids loss of precision if
            the true result is very close to 0.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the exponential function's
            results are generally not exact.</i> (Unlike in the General Binary
            Arithmetic Specification, any rounding mode is allowed.).</param>
            <returns>Exponential of this object, minus 1. Signals FlagInvalid
            and returns not-a-number (NaN) if the parameter <paramref
            name='ctx'/> is null or the precision is unlimited (the context's
            Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.GetHashCode">
            <summary>Calculates this object's hash code. No application or
            process IDs are used in the hash code calculation.</summary>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsInfinity">
            <summary>Gets a value indicating whether this object is positive or
            negative infinity.</summary>
            <returns><c>true</c> if this object is positive or negative
            infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsNaN">
            <summary>Gets a value indicating whether this object is not a
            number (NaN).</summary>
            <returns><c>true</c> if this object is not a number (NaN);
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsNegativeInfinity">
            <summary>Returns whether this object is negative
            infinity.</summary>
            <returns><c>true</c> if this object is negative infinity;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsPositiveInfinity">
            <summary>Returns whether this object is positive
            infinity.</summary>
            <returns><c>true</c> if this object is positive infinity;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsQuietNaN">
            <summary>Gets a value indicating whether this object is a quiet
            not-a-number value.</summary>
            <returns><c>true</c> if this object is a quiet not-a-number value;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsSignalingNaN">
            <summary>Gets a value indicating whether this object is a signaling
            not-a-number value.</summary>
            <returns><c>true</c> if this object is a signaling not-a-number
            value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Log(PeterO.Numbers.EContext)">
            <summary>Finds the natural logarithm of this object, that is, the
            power (exponent) that e (the base of natural logarithms) must be
            raised to in order to equal this object's value.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the ln function's results are
            generally not exact.</i> (Unlike in the General Binary Arithmetic
            Specification, any rounding mode is allowed.).</param>
            <returns>Ln(this object). Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the result would be a complex
            number with a real part equal to Ln of this object's absolute value
            and an imaginary part equal to pi, but the return value is still
            NaN.). Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null or the precision is
            unlimited (the context's Precision property is 0). Signals no flags
            and returns negative infinity if this object's value is
            0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Log10(PeterO.Numbers.EContext)">
            <summary>Finds the base-10 logarithm of this object, that is, the
            power (exponent) that the number 10 must be raised to in order to
            equal this object's value.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the ln function's results are
            generally not exact.</i> (Unlike in the General Binary Arithmetic
            Specification, any rounding mode is allowed.).</param>
            <returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and
            returns not-a-number (NaN) if this object is less than 0. Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Log1P(PeterO.Numbers.EContext)">
            <summary>Adds 1 to this object's value and finds the natural
            logarithm of the result, in a way that avoids loss of precision
            when this object's value is between 0 and 1.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the ln function's results are
            generally not exact.</i> (Unlike in the General Binary Arithmetic
            Specification, any rounding mode is allowed.).</param>
            <returns>Ln(1+(this object)). Signals the flag FlagInvalid and
            returns NaN if this object is less than -1 (the result would be a
            complex number with a real part equal to Ln of 1 plus this object's
            absolute value and an imaginary part equal to pi, but the return
            value is still NaN.). Signals FlagInvalid and returns not-a-number
            (NaN) if the parameter <paramref name='ctx'/> is null or the
            precision is unlimited (the context's Precision property is 0).
            Signals no flags and returns negative infinity if this object's
            value is 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.LogN(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Finds the base-N logarithm of this object, that is, the
            power (exponent) that the number N must be raised to in order to
            equal this object's value.</summary>
            <param name='baseValue'>The parameter <paramref name='baseValue'/>
            is a Numbers.EFloat object.</param>
            <param name='ctx'>The parameter <paramref name='ctx'/> is a
            Numbers.EContext object.</param>
            <returns>Ln(this object)/Ln(baseValue). Signals the flag
            FlagInvalid and returns not-a-number (NaN) if this object is less
            than 0. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null or the precision is
            unlimited (the context's Precision property is 0).</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='baseValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointLeft(System.Int32)">
            <summary>Returns a number similar to this number but with the radix
            point moved to the left.</summary>
            <param name='places'>The number of binary digit places to move the
            radix point to the left. If this number is negative, instead moves
            the radix point to the right by this number's absolute
            value.</param>
            <returns>A number whose exponent is decreased by <paramref
            name='places'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointLeft(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the radix
            point moved to the left.</summary>
            <param name='places'>The number of binary digit places to move the
            radix point to the left. If this number is negative, instead moves
            the radix point to the right by this number's absolute
            value.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>A number whose exponent is decreased by <paramref
            name='places'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointLeft(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the radix
            point moved to the left.</summary>
            <param name='bigPlaces'>The number of binary digit places to move
            the radix point to the left. If this number is negative, instead
            moves the radix point to the right by this number's absolute
            value.</param>
            <returns>A number whose exponent is decreased by <paramref
            name='bigPlaces'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointLeft(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the radix
            point moved to the left.</summary>
            <param name='bigPlaces'>The number of binary digit places to move
            the radix point to the left. If this number is negative, instead
            moves the radix point to the right by this number's absolute
            value.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>A number whose exponent is decreased by <paramref
            name='bigPlaces'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointRight(System.Int32)">
            <summary>Returns a number similar to this number but with the radix
            point moved to the right.</summary>
            <param name='places'>The number of binary digit places to move the
            radix point to the right. If this number is negative, instead moves
            the radix point to the left by this number's absolute
            value.</param>
            <returns>A number whose exponent is increased by <paramref
            name='places'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointRight(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the radix
            point moved to the right.</summary>
            <param name='places'>The number of binary digit places to move the
            radix point to the right. If this number is negative, instead moves
            the radix point to the left by this number's absolute
            value.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>A number whose exponent is increased by <paramref
            name='places'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointRight(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the radix
            point moved to the right.</summary>
            <param name='bigPlaces'>The number of binary digit places to move
            the radix point to the right. If this number is negative, instead
            moves the radix point to the left by this number's absolute
            value.</param>
            <returns>A number whose exponent is increased by <paramref
            name='bigPlaces'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointRight(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the radix
            point moved to the right.</summary>
            <param name='bigPlaces'>The number of binary digit places to move
            the radix point to the right. If this number is negative, instead
            moves the radix point to the left by this number's absolute
            value.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>A number whose exponent is increased by <paramref
            name='bigPlaces'/>, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Multiply(PeterO.Numbers.EFloat)">
            <summary>Multiplies this arbitrary-precision binary floating-point
            number by another arbitrary-precision binary floating-point number
            and returns the result. The exponent for the result is this
            arbitrary-precision binary floating-point number's exponent plus
            the other arbitrary-precision binary floating-point number's
            exponent.</summary>
            <param name='otherValue'>Another binary floating-point
            number.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision binary floating-point number times another
            arbitrary-precision binary floating-point number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='otherValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Multiply(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Multiplies this arbitrary-precision binary floating-point
            number by another arbitrary-precision binary floating-point number
            and returns the result.</summary>
            <param name='op'>Another binary floating-point number.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>The product of the two numbers, that is, this
            arbitrary-precision binary floating-point number times another
            arbitrary-precision binary floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MultiplyAndAdd(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Multiplies by one binary floating-point number, and then
            adds another binary floating-point number.</summary>
            <param name='multiplicand'>The value to multiply.</param>
            <param name='augend'>The value to add.</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MultiplyAndAdd(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Multiplies by one value, and then adds another
            value.</summary>
            <param name='op'>The value to multiply.</param>
            <param name='augend'>The value to add.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. If the precision doesn't indicate a simplified
            arithmetic, rounding and precision/exponent adjustment is done only
            once, namely, after multiplying and adding.</param>
            <returns>The result thisValue * multiplicand + augend.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MultiplyAndSubtract(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Multiplies by one value, and then subtracts another
            value.</summary>
            <param name='op'>The value to multiply.</param>
            <param name='subtrahend'>The value to subtract.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. If the precision doesn't indicate a simplified
            arithmetic, rounding and precision/exponent adjustment is done only
            once, namely, after multiplying and subtracting.</param>
            <returns>The result thisValue * multiplicand -
            subtrahend.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='op'/> or <paramref name='subtrahend'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Negate">
            <summary>Gets an object with the same value as this one, but with
            the sign reversed.</summary>
            <returns>An arbitrary-precision binary floating-point number. If
            this value is positive zero, returns negative zero. Returns
            signaling NaN if this value is signaling NaN. (In this sense, this
            method is similar to the "copy-negate" operation in the General
            Decimal Arithmetic Specification, except this method does not
            necessarily return a copy of this object.).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Negate(PeterO.Numbers.EContext)">
            <summary>Returns a binary floating-point number with the same value
            as this object but with the sign reversed.</summary>
            <param name='context'>An arithmetic context to control the
            precision, rounding, and exponent range of the result. If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the precision is
            unlimited and rounding isn't needed.</param>
            <returns>An arbitrary-precision binary floating-point number. If
            this value is positive zero, returns positive zero. Signals
            FlagInvalid and returns quiet NaN if this value is signaling
            NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.NextMinus(PeterO.Numbers.EContext)">
            <summary>Finds the largest value that's smaller than the given
            value.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param>
            <returns>Returns the largest value that's less than the given
            value. Returns negative infinity if the result is negative
            infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null, the precision is 0, or
            <paramref name='ctx'/> has an unlimited exponent range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.NextPlus(PeterO.Numbers.EContext)">
            <summary>Finds the smallest value that's greater than the given
            value.</summary>
            <param name='ctx'>An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param>
            <returns>Returns the smallest value that's greater than the given
            value.Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null, the precision is 0, or
            <paramref name='ctx'/> has an unlimited exponent range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.NextToward(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Finds the next value that is closer to the other object's
            value than this object's value. Returns a copy of this value with
            the same sign as the other value if both values are
            equal.</summary>
            <param name='otherValue'>An arbitrary-precision binary
            floating-point number that the return value will approach.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param>
            <returns>Returns the next value that is closer to the other object'
            s value than this object's value. Signals FlagInvalid and returns
            NaN if the parameter <paramref name='ctx'/> is null, the precision
            is 0, or <paramref name='ctx'/> has an unlimited exponent
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Plus(PeterO.Numbers.EContext)">
            <summary>Rounds this object's value to a given precision, using the
            given rounding mode and range of exponent, and also converts
            negative zero to positive zero. The idiom
            <c>EDecimal.SignalingNaN.Plus(ctx)</c> is useful for triggering an
            invalid operation and returning not-a-number (NaN) for custom
            arithmetic operations.</summary>
            <param name='ctx'>A context for controlling the precision, rounding
            mode, and exponent range. Can be null, in which case the precision
            is unlimited and rounding isn't needed.</param>
            <returns>The closest value to this object's value, rounded to the
            specified precision. If <paramref name='ctx'/> is null or the
            precision and exponent range are unlimited, returns the same value
            as this object (or a quiet NaN if this object is a signaling
            NaN).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Pow(PeterO.Numbers.EFloat)">
            <summary>Raises this object's value to the given exponent, using
            unlimited precision.</summary>
            <param name='exponent'>An arbitrary-precision binary floating-point
            number expressing the exponent to raise this object's value
            to.</param>
            <returns>This^exponent. Returns not-a-number (NaN) if the exponent
            has a fractional part.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Pow(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Raises this object's value to the given
            exponent.</summary>
            <param name='exponent'>An arbitrary-precision binary floating-point
            number expressing the exponent to raise this object's value
            to.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0; or if this value is
            less than 0 and the exponent either has a fractional part or is
            infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null or the precision is
            unlimited (the context's Precision property is 0), and the exponent
            has a fractional part.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Pow(System.Int32,PeterO.Numbers.EContext)">
            <summary>Raises this object's value to the given
            exponent.</summary>
            <param name='exponentSmall'>The exponent to raise this object's
            value to.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Pow(System.Int32)">
            <summary>Raises this object's value to the given
            exponent.</summary>
            <param name='exponentSmall'>The exponent to raise this object's
            value to.</param>
            <returns>This^exponent. Returns not-a-number (NaN) if this object
            and exponent are both 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Precision">
            <summary>Finds the number of digits in this number's significand.
            Returns 1 if this value is 0, and 0 if this value is infinity or
            not-a-number (NaN).</summary>
            <returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsInteger">
            <summary>Returns whether this object's value is an
            integer.</summary>
            <returns><c>true</c> if this object's value is an integer;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Quantize(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>
             Returns a binary floating-point number with the same
            value but a new exponent.
            <para>Note that this is not always the same as rounding to a given
            number of binary digit places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            binary digit places is desired, it's better to use the
            RoundToExponent and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b>
             This method can be used to implement
            fixed-point binary arithmetic, in which each binary floating-point
            number has a fixed number of digits after the radix point. The
            following code example returns a fixed-point number with up to 20
            digits before and exactly 5 digits after the radix point:</para>
            <code> &#x2f;&#x2a; After performing arithmetic operations, adjust
            &#x2f;&#x2a; the number to 5 &#x2f;&#x2a;
            &#x2a;&#x2f;&#x2a;&#x2f;&#x2a;&#x2f;
            digits after the radix point number = number.Quantize(
            EInteger.FromInt32(-5), &#x2f;&#x2a; five digits after the radix
            point&#x2a;&#x2f;
            EContext.ForPrecision(25) &#x2f;&#x2a; 25-digit
            precision);&#x2a;&#x2f;</code>
            <para>A fixed-point binary arithmetic in which no digits come after
            the radix point (a desired exponent of 0) is considered an "integer
            arithmetic".</para>
            </summary>
            <param name='desiredExponent'>The desired exponent for the result.
            The exponent is the number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c>
             of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param>
            <returns>A binary floating-point number with the same value as this
            object but with the exponent changed. Signals FlagInvalid and
            returns not-a-number (NaN) if this object is infinity, if the
            rounded result can't fit the given precision, or if the context
            defines an exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Quantize(System.Int32,PeterO.Numbers.EContext)">
            <summary>
             Returns a binary floating-point number with the same
            value but a new exponent.
            <para>Note that this is not always the same as rounding to a given
            number of binary digit places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            binary digit places is desired, it's better to use the
            RoundToExponent and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b>
             This method can be used to implement
            fixed-point binary arithmetic, in which each binary floating-point
            number has a fixed number of digits after the radix point. The
            following code example returns a fixed-point number with up to 20
            digits before and exactly 5 digits after the radix point:</para>
            <code> &#x2f;&#x2a; After performing arithmetic operations, adjust
            &#x2f;&#x2a; the number to 5&#x2a;&#x2f;&#x2a;&#x2f;
            digits after the radix point number = number.Quantize(-5, &#x2f;&#x2a; five
            digits&#x2a;&#x2f;
            after the radix point EContext.ForPrecision(25) &#x2f;&#x2a; 25-digit
            precision);&#x2a;&#x2f;</code>
            <para>A fixed-point binary arithmetic in which no digits come after
            the radix point (a desired exponent of 0) is considered an "integer
            arithmetic".</para>
            </summary>
            <param name='desiredExponentInt'>The desired exponent for the
            result. The exponent is the number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c>
             of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param>
            <returns>A binary floating-point number with the same value as this
            object but with the exponent changed. Signals FlagInvalid and
            returns not-a-number (NaN) if this object is infinity, if the
            rounded result can't fit the given precision, or if the context
            defines an exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Quantize(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Returns a binary floating-point number with the same value
            as this object but with the same exponent as another binary
            floating-point number.
            <para>Note that this is not always the same as rounding to a given
            number of binary digit places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            binary digit places is desired, it's better to use the
            RoundToExponent and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b> This method can be used to implement
            fixed-point binary arithmetic, in which a fixed number of digits
            come after the radix point. A fixed-point binary arithmetic in
            which no digits come after the radix point (a desired exponent of
            0) is considered an "integer arithmetic" .</para></summary>
            <param name='otherValue'>A binary floating-point number containing
            the desired exponent of the result. The significand is ignored. The
            exponent is the number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the sixteenth (10b^-3, 0.0001b), and 3 means round
            to the sixteen-place (10b^3, 1000b). A value of 0 rounds the number
            to an integer.</param>
            <param name='ctx'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param>
            <returns>A binary floating-point number with the same value as this
            object but with the exponent changed. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding, or if the arithmetic context defines an
            exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Reduce(PeterO.Numbers.EContext)">
            <summary>Returns an object with the same numerical value as this
            one but with trailing zeros removed from its significand. For
            example, 1.00 becomes 1.
            <para>If this object's value is 0, changes the exponent to
            0.</para></summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param>
            <returns>This value with trailing zeros removed. Note that if the
            result has a very high exponent and the context says to clamp high
            exponents, there may still be some trailing zeros in the
            significand.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Remainder(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Returns the remainder that would result when this
            arbitrary-precision binary floating-point number is divided by
            another arbitrary-precision binary floating-point number. The
            remainder is the number that remains when the absolute value of
            this arbitrary-precision binary floating-point number is divided
            (as though by DivideToIntegerZeroScale) by the absolute value of
            the other arbitrary-precision binary floating-point number; the
            remainder has the same sign (positive or negative) as this
            arbitrary-precision binary floating-point number.</summary>
            <param name='divisor'>An arbitrary-precision binary floating-point
            number.</param>
            <param name='ctx'>The parameter <paramref name='ctx'/> is an
            EContext object.</param>
            <returns>The remainder that would result when this
            arbitrary-precision binary floating-point number is divided by
            another arbitrary-precision binary floating-point number. Signals
            FlagDivideByZero and returns infinity if the divisor (this
            arbitrary-precision binary floating-point number) is 0 and the
            dividend (the other arbitrary-precision binary floating-point
            number) is nonzero. Signals FlagInvalid and returns not-a-number
            (NaN) if the divisor and the dividend are 0, or if the result of
            the division doesn't fit the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RemainderNoRoundAfterDivide(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Finds the remainder that results when dividing two
            arbitrary-precision binary floating-point numbers. The remainder is
            the value that remains when the absolute value of this object is
            divided by the absolute value of the other object; the remainder
            has the same sign (positive or negative) as this object's
            value.</summary>
            <param name='divisor'>An arbitrary-precision binary floating-point
            number.</param>
            <param name='ctx'>The parameter <paramref name='ctx'/> is an
            EContext object.</param>
            <returns>The remainder of the two numbers. Signals FlagInvalid and
            returns not-a-number (NaN) if the divisor is 0, or if the result
            doesn't fit the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RemainderNaturalScale(PeterO.Numbers.EFloat)">
            <summary>Calculates the remainder of a number by the formula
            <c>"this" - (("this" / "divisor") * "divisor")</c>.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RemainderNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Calculates the remainder of a number by the formula "this"
            - (("this" / "divisor") * "divisor").</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the return value to
            have a higher precision than given in this context. Flags will be
            set on the given context only if the context's <c>HasFlags</c> is
            true and the integer part of the division result doesn't fit the
            precision and exponent range without rounding. Can be null, in
            which the precision is unlimited and no additional rounding, other
            than the rounding down to an integer after division, is
            needed.</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RemainderNear(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Finds the distance to the closest multiple of the given
            divisor, based on the result of dividing this object's value by
            another object's value.
            <list type=''>
            <item>If this and the other object divide evenly, the result is
            0.</item>
            <item>If the remainder's absolute value is less than half of the
            divisor's absolute value, the result has the same sign as this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is more than half of the
            divisor's absolute value, the result has the opposite sign of this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is exactly half of the
            divisor's absolute value, the result has the opposite sign of this
            object if the quotient, rounded down, is odd, and has the same sign
            as this object if the quotient, rounded down, is even, and the
            result's absolute value is half of the divisor's absolute
            value.</item></list> This function is also known as the "IEEE
            Remainder" function.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>An arithmetic context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored (the rounding mode is always treated as HalfEven). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which the precision is
            unlimited.</param>
            <returns>The distance of the closest multiple. Signals FlagInvalid
            and returns not-a-number (NaN) if the divisor is 0, or either the
            result of integer division (the quotient) or the remainder wouldn't
            fit the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a binary floating-point number with the same value
            as this object but rounded to a new exponent if necessary. The
            resulting number's Exponent property will not necessarily be the
            given exponent; use the Quantize method instead to give the result
            a particular exponent.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>A binary floating-point number rounded to the closest
            value representable in the given precision. If the result can't fit
            the precision, additional digits are discarded to make it fit.
            Signals FlagInvalid and returns not-a-number (NaN) if the
            arithmetic context defines an exponent range, the new exponent must
            be changed to the given exponent when rounding, and the given
            exponent is outside of the valid range of the arithmetic
            context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToExponent(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a binary floating-point number with the same value
            as this object but rounded to a new exponent if necessary. The
            resulting number's Exponent property will not necessarily be the
            given exponent; use the Quantize method instead to give the result
            a particular exponent.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>A binary floating-point number rounded to the closest
            value representable in the given precision. If the result can't fit
            the precision, additional digits are discarded to make it fit.
            Signals FlagInvalid and returns not-a-number (NaN) if the
            arithmetic context defines an exponent range, the new exponent must
            be changed to the given exponent when rounding, and the given
            exponent is outside of the valid range of the arithmetic
            context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a binary floating-point number with the same value
            as this object but rounded to the given exponent, and signals an
            inexact flag if the result would be inexact. The resulting number's
            Exponent property will not necessarily be the given exponent; use
            the Quantize method instead to give the result a particular
            exponent.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>A binary floating-point number rounded to the closest
            value representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to the given exponent when
            rounding, and the given exponent is outside of the valid range of
            the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">
            <summary>Returns a binary number with the same value as this object
            but rounded to the given exponent. The resulting number's Exponent
            property will not necessarily be the given exponent; use the
            Quantize method instead to give the result a particular
            exponent.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the eighth (10^-1, 1/8), and 3 means round to the
            eight (2^3, 8). A value of 0 rounds the number to an
            integer.</param>
            <param name='rounding'>Desired mode for rounding this object's
            value.</param>
            <returns>A binary number rounded to the closest value representable
            in the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToExponentExact(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a binary floating-point number with the same value
            as this object but rounded to the given exponent represented as a
            32-bit signed integer, and signals an inexact flag if the result
            would be inexact. The resulting number's Exponent property will not
            necessarily be the given exponent; use the Quantize method instead
            to give the result a particular exponent.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>A binary floating-point number rounded to the closest
            value representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to the given exponent when
            rounding, and the given exponent is outside of the valid range of
            the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToIntegerExact(PeterO.Numbers.EContext)">
            <summary>Returns a binary floating-point number with the same value
            as this object but rounded to an integer, and signals an inexact
            flag if the result would be inexact. The resulting number's
            Exponent property will not necessarily be 0; use the Quantize
            method instead to give the result an exponent of 0.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>A binary floating-point number rounded to the closest
            integer representable in the given precision. Signals FlagInvalid
            and returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to 0 when rounding, and 0
            is outside of the valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)">
            <summary>Returns a binary floating-point number with the same value
            as this object but rounded to an integer, without adding the
            <c>FlagInexact</c> or <c>FlagRounded</c> flags. The resulting
            number's Exponent property will not necessarily be 0; use the
            Quantize method instead to give the result an exponent of
            0.</summary>
            <param name='ctx'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags), except that this
            function will never add the <c>FlagRounded</c> and
            <c>FlagInexact</c> flags (the only difference between this and
            RoundToExponentExact). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>A binary floating-point number rounded to the closest
            integer representable in the given precision. If the result can't
            fit the precision, additional digits are discarded to make it fit.
            Signals FlagInvalid and returns not-a-number (NaN) if the
            arithmetic context defines an exponent range, the new exponent must
            be changed to 0 when rounding, and 0 is outside of the valid range
            of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToIntegralExact(PeterO.Numbers.EContext)">
            <summary>Returns a binary floating-point number with the same value
            as this object but rounded to an integer, and signals an inexact
            flag if the result would be inexact.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>A binary floating-point number rounded to the closest
            integer representable in the given precision. Signals FlagInvalid
            and returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to 0 when rounding, and 0
            is outside of the valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)">
            <summary>Returns a binary floating-point number with the same value
            as this object but rounded to an integer, without adding the
            <c>FlagInexact</c> or <c>FlagRounded</c> flags.</summary>
            <param name='ctx'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags), except that this
            function will never add the <c>FlagRounded</c> and
            <c>FlagInexact</c> flags (the only difference between this and
            RoundToExponentExact). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>A binary floating-point number rounded to the closest
            integer representable in the given precision. If the result can't
            fit the precision, additional digits are discarded to make it fit.
            Signals FlagInvalid and returns not-a-number (NaN) if the
            arithmetic context defines an exponent range, the new exponent must
            be changed to 0 when rounding, and 0 is outside of the valid range
            of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToPrecision(PeterO.Numbers.EContext)">
            <summary>Rounds this object's value to a given precision, using the
            given rounding mode and range of exponent.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param>
            <returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name='ctx'/> is null or the precision and exponent range
            are unlimited.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.PreRound(PeterO.Numbers.EContext)">
            <summary>Returns a number in which the value of this object is
            rounded to fit the maximum precision allowed if it has more
            significant digits than the maximum precision. The maximum
            precision allowed is given in an arithmetic context. This method is
            designed for preparing operands to a custom arithmetic operation in
            accordance with the "simplified" arithmetic given in Appendix A of
            the General Decimal Arithmetic Specification.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited. Signals the
            flag LostDigits if the input number has greater precision than
            allowed and was rounded to a different numerical value in order to
            fit the precision.</param>
            <returns>This object rounded to the given precision. Returns this
            object and signals no flags if <paramref name='ctx'/> is null or
            specifies an unlimited precision, if this object is infinity or
            not-a-number (including signaling NaN), or if the number's value
            has no more significant digits than the maximum precision given in
            <paramref name='ctx'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(System.Int32)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='places'>The parameter <paramref name='places'/> is a
            32-bit signed integer.</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='places'>The parameter <paramref name='places'/> is a
            32-bit signed integer.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <returns>A number whose exponent is increased by <paramref
            name='bigPlaces'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with its scale
            adjusted.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='bigPlaces'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Sqrt(PeterO.Numbers.EContext)">
            <summary>Finds the square root of this object's value.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the square root function's
            results are generally not exact for many inputs.</i> (Unlike in the
            General Binary Arithmetic Specification, any rounding mode is
            allowed.).</param>
            <returns>The square root. Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the square root would be a
            complex number, but the return value is still NaN). Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.SquareRoot(PeterO.Numbers.EContext)">
            <summary>Finds the square root of this object's value.</summary>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the square root function's
            results are generally not exact for many inputs.</i> (Unlike in the
            General Binary Arithmetic Specification, any rounding mode is
            allowed.).</param>
            <returns>The square root. Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the square root would be a
            complex number, but the return value is still NaN). Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Subtract(PeterO.Numbers.EFloat)">
            <summary>Subtracts an arbitrary-precision binary floating-point
            number from this arbitrary-precision binary floating-point number
            and returns the result. The exponent for the result is the lower of
            this arbitrary-precision binary floating-point number's exponent
            and the other arbitrary-precision binary floating-point number's
            exponent.</summary>
            <param name='otherValue'>The number to subtract from this
            instance's value.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision binary floating-point number minus another
            arbitrary-precision binary floating-point number. If this
            arbitrary-precision binary floating-point number is not-a-number
            (NaN), returns NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Subtract(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Subtracts an arbitrary-precision binary floating-point
            number from this arbitrary-precision binary floating-point number
            and returns the result.</summary>
            <param name='otherValue'>The number to subtract from this
            instance's value.</param>
            <param name='ctx'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param>
            <returns>The difference between the two numbers, that is, this
            arbitrary-precision binary floating-point number minus another
            arbitrary-precision binary floating-point number. If this
            arbitrary-precision binary floating-point number is not-a-number
            (NaN), returns NaN.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='otherValue'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToDouble">
            <summary>Converts this value to a 64-bit floating-point number
            encoded in the IEEE 754 binary64 format.</summary>
            <returns>This number, converted to a 64-bit floating-point number
            encoded in the IEEE 754 binary64 format. The return value can be
            positive infinity or negative infinity if this value exceeds the
            range of a 64-bit floating point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSingleBits">
            <summary>Converts this value to its closest equivalent as 32-bit
            floating-point number, expressed as an integer in the IEEE 754
            binary32 format. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN.</para></summary>
            <returns>The closest 32-bit binary floating-point number to this
            value, expressed as an integer in the IEEE 754 binary32 format. The
            return value can be positive infinity or negative infinity if this
            value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToDoubleBits">
            <summary>Converts this value to its closest equivalent as a 64-bit
            floating-point number, expressed as an integer in the IEEE 754
            binary64 format. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 64-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN.</para></summary>
            <returns>The closest 64-bit binary floating-point number to this
            value, expressed as an integer in the IEEE 754 binary64 format. The
            return value can be positive infinity or negative infinity if this
            value exceeds the range of a 64-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToEDecimal">
            <summary>Converts this value to an arbitrary-precision decimal
            number.</summary>
            <returns>This number, converted to an arbitrary-precision decimal
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToEInteger">
            <summary>Converts this value to an arbitrary-precision integer. Any
            fractional part of this value will be discarded when converting to
            an arbitrary-precision integer. Note that depending on the value,
            especially the exponent, generating the arbitrary-precision integer
            may require a huge amount of memory. Use the ToSizedEInteger method
            to convert a number to an EInteger only if the integer fits in a
            bounded bit range; that method will throw an exception on
            overflow.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToEIntegerExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the value contains a fractional part. Note that
            depending on the value, especially the exponent, generating the
            arbitrary-precision integer may require a huge amount of memory.
            Use the ToSizedEIntegerIfExact method to convert a number to an
            EInteger only if the integer fits in a bounded bit range; that
            method will throw an exception on overflow.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
            <exception cref='T:System.ArithmeticException'>This object's value is not an
            exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToEIntegerIfExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the value contains a fractional part. Note that
            depending on the value, especially the exponent, generating the
            arbitrary-precision integer may require a huge amount of memory.
            Use the ToSizedEIntegerIfExact method to convert a number to an
            EInteger only if the integer fits in a bounded bit range; that
            method will throw an exception on overflow.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>
            <exception cref='T:System.ArithmeticException'>This object's value is not an
            exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToEngineeringString">
            <summary>Converts this value to an arbitrary-precision decimal
            number, then returns the value of that decimal's
            ToEngineeringString method.</summary>
            <returns>A text string.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToExtendedDecimal">
            <summary>Converts this value to an arbitrary-precision decimal
            number.</summary>
            <returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToPlainString">
            <summary>Converts this value to a string, but without exponential
            notation.</summary>
            <returns>A text string.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToShortestString(PeterO.Numbers.EContext)">
            <summary>Returns a string representation of this number's value
            after rounding that value to the given precision (using the given
            arithmetic context, such as <c>EContext.Binary64</c>
             ). If the
            number after rounding is neither infinity nor not-a-number (NaN),
            returns the shortest decimal form of this number's value (in terms
            of decimal digits starting with the first nonzero digit and ending
            with the last nonzero digit) that results in the rounded number
            after the decimal form is converted to binary floating-point format
            (using the given arithmetic context).</summary>
            <param name='ctx'>An arithmetic context to control precision (in
            bits), rounding, and exponent range of the rounded number. If
            <c>HasFlags</c>
             of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null. If this parameter is null or
            defines no maximum precision, returns the same value as the
            ToString() method.</param>
            <returns>Shortest decimal form of this number's value for the given
            arithmetic context. The text string will be in exponential notation
            (expressed as a number 1 or greater, but less than 10, times a
            power of 10) if the number's first nonzero decimal digit is more
            than five digits after the decimal point, or if the number's
            exponent is greater than 0 and its value is 10, 000, 000 or
            greater.</returns>
            <example>
            <para>The following example converts an EFloat number to its
            shortest round-tripping decimal form using the same precision as
            the <c>double</c>
             type in Java and.NET:</para>
            <code> String str = efloat.ToShortestString(EContext.Binary64); </code>
            </example>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSingle">
            <summary>Converts this value to its closest equivalent as a 32-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's
            unsigned significand, and the next-highest bit of the significand
            area is set if those bits are all zeros and this is a signaling
            NaN. Unfortunately, in the.NET implementation, the return value of
            this method may be a quiet NaN even if a signaling NaN would
            otherwise be generated.</para></summary>
            <returns>The closest 32-bit binary floating-point number to this
            value. The return value can be positive infinity or negative
            infinity if this value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToString">
            <summary>Converts this number's value to a text string.</summary>
            <returns>A string representation of this object. The value is
            converted to a decimal number (using the EDecimal.FromEFloat
            method) and the decimal form of this number's value is returned.
            The text string will be in exponential notation (expressed as a
            number 1 or greater, but less than 10, times a power of 10) if the
            converted decimal number's exponent (EDecimal's Exponent property)
            is greater than 0 or if the number's first nonzero decimal digit is
            more than five digits after the decimal point.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Ulp">
            <summary>Returns the unit in the last place. The significand will
            be 1 and the exponent will be this number's exponent. Returns 1
            with an exponent of 0 if this number is infinity or not-a-number
            (NaN).</summary>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSizedEInteger(System.Int32)">
            <summary>Converts this value to an arbitrary-precision integer by
            discarding its fractional part and checking whether the resulting
            integer overflows the given signed bit count.</summary>
            <param name='maxBitLength'>The maximum number of signed bits the
            integer can have. The integer's value may not be less than
            -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN), or this number's value, once converted to an
            integer by discarding its fractional part, is less than
            -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSizedEIntegerIfExact(System.Int32)">
            <summary>Converts this value to an arbitrary-precision integer,
            only if this number's value is an exact integer and that integer
            does not overflow the given signed bit count.</summary>
            <param name='maxBitLength'>The maximum number of signed bits the
            integer can have. The integer's value may not be less than
            -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is infinity
            or not-a-number (NaN), or this number's value, once converted to an
            integer by discarding its fractional part, is less than
            -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</exception>
            <exception cref='T:System.ArithmeticException'>This object's value is not an
            exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetRadix">
            <summary>This is an internal method.</summary>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetSign(PeterO.Numbers.EFloat)">
            <summary>This is an internal method.</summary>
            <param name='value'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetMantissa(PeterO.Numbers.EFloat)">
            <summary>This is an internal method.</summary>
            <param name='value'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetExponent(PeterO.Numbers.EFloat)">
            <summary>This is an internal method.</summary>
            <param name='value'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateShiftAccumulatorWithDigits(PeterO.Numbers.EInteger,System.Int32,System.Int32)">
            <summary>This is an internal method.</summary>
            <param name='bigint'>An arbitrary-precision integer.</param>
            <param name='lastDigit'>The parameter <paramref name='lastDigit'/>
            is a 32-bit signed integer.</param>
            <param name='olderDigits'>The parameter <paramref
            name='olderDigits'/> is a 32-bit signed integer.</param>
            <returns>An IShiftAccumulator object.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.DivisionShift(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>This is an internal method.</summary>
            <param name='num'>An arbitrary-precision integer.</param>
            <param name='den'>Another arbitrary-precision integer.</param>
            <returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.MultiplyByRadixPower(PeterO.Numbers.EInteger,PeterO.Numbers.FastInteger)">
            <summary>This is an internal method.</summary>
            <param name='bigint'>Another arbitrary-precision integer.</param>
            <param name='power'>A fast integer.</param>
            <returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetFlags(PeterO.Numbers.EFloat)">
            <summary>This is an internal method.</summary>
            <param name='value'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateNewWithFlags(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Int32)">
            <summary>This is an internal method.</summary>
            <param name='mantissa'>The parameter <paramref name='mantissa'/> is
            a Numbers.EInteger object.</param>
            <param name='exponent'>The parameter <paramref name='exponent'/> is
            an internal parameter.</param>
            <param name='flags'>The parameter <paramref name='flags'/> is an
            internal parameter.</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetArithmeticSupport">
            <summary>This is an internal method.</summary>
            <returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.ValueOf(System.Int32)">
            <summary>This is an internal method.</summary>
            <param name='val'>The parameter <paramref name='val'/> is a 32-bit
            signed integer.</param>
            <returns>An arbitrary-precision binary floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Increment">
            <summary>Returns one added to this arbitrary-precision binary
            floating-point number.</summary>
            <returns>The given arbitrary-precision binary floating-point number
            plus one.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Decrement">
            <summary>Returns one subtracted from this arbitrary-precision
            binary floating-point number.</summary>
            <returns>The given arbitrary-precision binary floating-point number
            minus one.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToByteChecked">
            <summary>Converts this number's value to a byte (from 0 to 255) if
            it can fit in a byte (from 0 to 255) after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a byte (from 0 to
            255).</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToByteUnchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a byte (from 0 to 255).</summary>
            <returns>This number, converted to a byte (from 0 to 255). Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToByteIfExact">
            <summary>Converts this number's value to a byte (from 0 to 255) if
            it can fit in a byte (from 0 to 255) without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a byte (from 0 to 255).</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromByte(System.Byte)">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputByte'>The number to convert as a byte (from 0 to
            255).</param>
            <returns>This number's value as an arbitrary-precision binary
            floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt16Checked">
            <summary>Converts this number's value to a 16-bit signed integer if
            it can fit in a 16-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 16-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -32768 or greater than
            32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt16Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 16-bit signed integer.</summary>
            <returns>This number, converted to a 16-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt16IfExact">
            <summary>Converts this number's value to a 16-bit signed integer if
            it can fit in a 16-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 16-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -32768 or
            greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromInt16(System.Int16)">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputInt16'>The number to convert as a 16-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision binary
            floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 32-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -2147483648 or greater
            than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt32Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 32-bit signed integer.</summary>
            <returns>This number, converted to a 32-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 32-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -2147483648
            or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromBoolean(System.Boolean)">
            <summary>Converts a boolean value (either true or false) to an
            arbitrary-precision binary floating-point number.</summary>
            <param name='boolValue'>Either true or false.</param>
            <returns>The number 1 if <paramref name='boolValue'/> is true,
            otherwise, 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromInt32(System.Int32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputInt32'>The number to convert as a 32-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision binary
            floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt64Checked">
            <summary>Converts this number's value to a 64-bit signed integer if
            it can fit in a 64-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 64-bit signed
            integer.</returns>
            <exception cref='T:System.OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -9223372036854775808
            or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt64Unchecked">
            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 64-bit signed integer.</summary>
            <returns>This number, converted to a 64-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt64IfExact">
            <summary>Converts this number's value to a 64-bit signed integer if
            it can fit in a 64-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 64-bit signed integer.</returns>
            <exception cref='T:System.ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than
            -9223372036854775808 or greater than
            9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromInt64AsUnsigned(System.Int64)">
            <summary>Converts an unsigned integer expressed as a 64-bit signed
            integer to an arbitrary-precision binary number.</summary>
            <param name='longerValue'>A 64-bit signed integer. If this value is
            0 or greater, the return value will represent it. If this value is
            less than 0, the return value will store 2^64 plus this value
            instead.</param>
            <returns>An arbitrary-precision binary number with the exponent set
            to 0. If <paramref name='longerValue'/> is 0 or greater, the return
            value will represent it. If <paramref name='longerValue'/> is less
            than 0, the return value will store 2^64 plus this value
            instead.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromInt64(System.Int64)">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision
            binary floating-point number.</summary>
            <param name='inputInt64'>The number to convert as a 64-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision binary
            floating-point number with the exponent set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.Multiply(System.Int32)">
            <summary>This is an internal API.</summary>
            <param name='val'>The parameter <paramref name='val'/> is an
            internal value.</param>
            <returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.Negate">
            <summary>This is an internal API.</summary>
            <returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.Subtract(PeterO.Numbers.FastInteger)">
            <summary>This is an internal API.</summary>
            <param name='val'>The parameter <paramref name='val'/> is an
            internal value.</param>
            <returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.SubtractInt(System.Int32)">
            <summary>This is an internal API.</summary>
            <param name='val'>The parameter <paramref name='val'/> is an
            internal value.</param>
            <returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.AddBig(PeterO.Numbers.EInteger)">
            <summary>This is an internal API.</summary>
            <param name='bigintVal'>The parameter <paramref name='bigintVal'/>
            is an internal value.</param>
            <returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.SubtractBig(PeterO.Numbers.EInteger)">
            <summary>This is an internal API.</summary>
            <param name='bigintVal'>The parameter <paramref name='bigintVal'/>
            is an internal value.</param>
            <returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.ToString">
            <summary>This is an internal API.</summary>
            <returns>A text string.</returns>
        </member>
        <member name="P:PeterO.Numbers.FastInteger.Sign">
            <summary>Gets an internal value.</summary>
            <value>An internal value.</value>
        </member>
        <member name="T:PeterO.Numbers.IShiftAccumulator">
            <summary>Common interface for classes that shift a number of digits
            and record information on whether a non-zero digit was discarded
            this way.</summary>
        </member>
        <member name="T:PeterO.Numbers.EFloats">
            <summary>A class that implements additional operations on
            arbitrary-precision binary floating-point numbers.</summary>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Radix(PeterO.Numbers.EContext)">
            <summary>Returns the number 2, the binary radix.</summary>
            <param name='ec'>Specifies an arithmetic context for rounding the
            number 2. Can be null.</param>
            <returns>The number 2, or the closest representable number to 2 in
            the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Int32ToEFloat(System.Int32,PeterO.Numbers.EContext)">
            <summary>Creates a binary floating-point number from a 32-bit
            signed integer.</summary>
            <param name='i32'>The parameter <paramref name='i32'/> is a 32-bit
            signed integer.</param>
            <param name='ec'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. Can be null.</param>
            <returns>An arbitrary-precision binary floating-point number with
            the closest representable value to the given integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.BooleanToEFloat(System.Boolean,PeterO.Numbers.EContext)">
            <summary>Converts a boolean value (either true or false) to an
            arbitrary-precision binary floating-point number.</summary>
            <param name='b'>Either true or false.</param>
            <param name='ec'>A context used for rounding the result. Can be
            null.</param>
            <returns>Either 1 if <paramref name='b'/> is true, or 0 if
            <paramref name='b'/> is false.. The result will be rounded as
            specified by the given context, if any.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.IsCanonical(PeterO.Numbers.EFloat)">
            <summary>Returns whether the given arbitrary-precision number
            object is in a canonical form. For the current version of EFloat,
            all EFloat objects are in a canonical form.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Always <c>true</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.IsFinite(PeterO.Numbers.EFloat)">
            <summary>Returns whether the given arbitrary-precision number
            object is neither null nor infinity nor not-a-number
            (NaN).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> if the given arbitrary-precision number
            object is neither null nor infinity nor not-a-number (NaN), or
            <c>false</c> otherwise.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.IsInfinite(PeterO.Numbers.EFloat)">
            <summary>Returns whether the given arbitrary-precision number
            object is positive or negative infinity.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> if the given arbitrary-precision number
            object is positive or negative infinity, or <c>false</c>
            otherwise.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.IsNaN(PeterO.Numbers.EFloat)">
            <summary>Returns whether the given arbitrary-precision number
            object is a not-a-number (NaN).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.IsNormal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Returns whether the given number is a
            <i>normal</i> number. A
            <i>subnormal number</i> is a nonzero finite number whose Exponent
            property (or the number's exponent when that number is expressed in
            scientific notation with one digit before the radix point) is less
            than the minimum possible exponent for that number. A
            <i>normal number</i> is nonzero and finite, but not
            subnormal.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <param name='ec'>A context specifying the exponent range of
            arbitrary-precision numbers. Can be null. If AdjustExponent of the
            given context is <c>true</c>, a nonzero number is normal if the
            number's exponent (when that number is expressed in scientific
            notation with one nonzero digit before the radix point) is at least
            the given context's EMax property (e.g., if EMax is -100, 2.3456 *
            10
            <sup>-99</sup> is normal, but 2.3456 * 10
            <sup>-102</sup> is not). If AdjustExponent of the given context is
            <c>false</c>, a nonzero number is subnormal if the number's
            Exponent property is at least given context's EMax property (e.g.,
            if EMax is -100, 23456 * 10
            <sup>-99</sup> is normal, but 23456 * 10
            <sup>-102</sup> is not).</param>
            <returns>Either <c>true</c> if the given number is subnormal, or
            <c>false</c> otherwise. Returns <c>true</c> if the given context is
            null or HasExponentRange of the given context is <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.IsQuietNaN(PeterO.Numbers.EFloat)">
            <summary>Returns whether the given arbitrary-precision number
            object is a quiet not-a-number (NaN).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.IsSigned(PeterO.Numbers.EFloat)">
            <summary>Returns whether the given arbitrary-precision number
            object is negative (including negative infinity, negative
            not-a-number [NaN], or negative zero).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.IsSignalingNaN(PeterO.Numbers.EFloat)">
            <summary>Returns whether the given arbitrary-precision number
            object is a signaling not-a-number (NaN).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.NumberClassString(System.Int32)">
            <summary>Converts a number class identifier (ranging from 0 through
            9) to a text string. An arbitrary-precision number object can
            belong in one of ten number classes.</summary>
            <param name='nc'>An integer identifying a number class.</param>
            <returns>A text string identifying the given number class as
            follows: 0 = "+Normal"; 1 = "-Normal", 2 = "+Subnormal", 3 =
            "-Subnormal", 4 = "+Zero", 5 = "-Zero", 6 = "+Infinity", 7 =
            "-Infinity", 8 = "NaN", 9 = "sNaN".</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='nc'/> is less than 0 or greater than 9.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.NumberClass(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Finds the number class for an arbitrary-precision binary
            number object.</summary>
            <param name='ed'>An arbitrary-precision binary number
            object.</param>
            <param name='ec'>A context object that specifies the precision and
            exponent range of arbitrary-precision numbers. This is used only to
            distinguish between normal and subnormal numbers. Can be
            null.</param>
            <returns>A 32-bit signed integer identifying the given number
            object, number class as follows: 0 = positive normal; 1 = negative
            normal, 2 = positive subnormal, 3 = negative subnormal, 4 =
            positive zero, 5 = negative zero, 6 = positive infinity, 7 =
            negative infinity, 8 = quiet not-a-number (NaN), 9 = signaling
            NaN.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.IsSubnormal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Returns whether the given number is a
            <i>subnormal</i> number. A
            <i>subnormal number</i> is a nonzero finite number whose Exponent
            property (or the number's exponent when that number is expressed in
            scientific notation with one digit before the radix point) is less
            than the minimum possible exponent for that number.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <param name='ec'>A context specifying the exponent range of
            arbitrary-precision numbers. Can be null. If AdjustExponent of the
            given context is <c>true</c>, a nonzero number is subnormal if the
            number's exponent (when that number is expressed in scientific
            notation with one nonzero digit before the radix point) is less
            than the given context's EMax property (e.g., if EMax is -100,
            2.3456 * 10
            <sup>-102</sup> is subnormal, but 2.3456 * 10
            <sup>-99</sup> is not). If AdjustExponent of the given context is
            <c>false</c>, a nonzero number is subnormal if the number's
            Exponent property is less than the given context's EMax property
            (e.g., if EMax is -100, 23456 * 10
            <sup>-102</sup> is subnormal, but 23456 * 10
            <sup>-99</sup> is not).</param>
            <returns>Either <c>true</c> if the given number is subnormal, or
            <c>false</c> otherwise. Returns <c>false</c> if the given context
            is null or HasExponentRange of the given context is <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.IsZero(PeterO.Numbers.EFloat)">
            <summary>Returns whether the given arbitrary-precision number
            object is zero (positive zero or negative zero).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns><c>true</c> if the given number has a value of zero
            (positive zero or negative zero); otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.LogB(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Returns the base-2 exponent of an arbitrary-precision
            binary number (when that number is expressed in scientific notation
            with one nonzero digit before the radix point). For example,
            returns 3 for the numbers <c>1.11b * 2^3</c> and <c>111 * 2^1</c>.</summary>
            <param name='ed'>An arbitrary-precision binary number.</param>
            <param name='ec'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. Can be null.</param>
            <returns>The base-2 exponent of the given number (when that number
            is expressed in scientific notation with one nonzero digit before
            the radix point). Signals DivideByZero and returns negative
            infinity if <paramref name='ed'/> is zero. Returns positive
            infinity if <paramref name='ed'/> is positive infinity or negative
            infinity.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.ScaleB(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Finds an arbitrary-precision binary number whose binary
            point is moved a given number of places.</summary>
            <param name='ed'>An arbitrary-precision binary number.</param>
            <param name='ed2'>The number of binary places to move the binary
            point of "ed". This must be an integer with an exponent of
            0.</param>
            <param name='ec'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. Can be null.</param>
            <returns>The given arbitrary-precision binary number whose binary
            point is moved the given number of places. Signals an invalid
            operation and returns not-a-number (NaN) if <paramref name='ed2'/>
            is infinity or NaN, has an Exponent property other than 0. Signals
            an invalid operation and returns not-a-number (NaN) if <paramref
            name='ec'/> defines a limited precision and exponent range and if
            <paramref name='ed2'/> 's absolute value is greater than twice the
            sum of the context's EMax property and its Precision
            property.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> or <paramref name='ed2'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Shift(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Shifts the bits of an arbitrary-precision binary floating
            point number's significand.</summary>
            <param name='ed'>An arbitrary-precision binary floating point
            number containing the significand to shift.</param>
            <param name='ed2'>An arbitrary-precision number indicating the
            number of bits to shift the first operand's significand. Must be an
            integer with an exponent of 0. If this parameter is positive, the
            significand is shifted to the left by the given number of bits. If
            this parameter is negative, the significand is shifted to the right
            by the given number of bits.</param>
            <param name='ec'>An arithmetic context to control the precision of
            arbitrary-precision numbers. Can be null.</param>
            <returns>An arbitrary-precision binary number whose significand is
            shifted the given number of bits. Signals an invalid operation and
            returns NaN (not-a-number) if <paramref name='ed2'/> is a signaling
            NaN or if <paramref name='ed2'/> is not an integer, is negative,
            has an exponent other than 0, or has an absolute value that exceeds
            the maximum precision specified in the context.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> or <paramref name='ed2'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Rotate(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Rotates the bits of an arbitrary-precision binary number's
            significand.</summary>
            <param name='ed'>An arbitrary-precision number containing the
            significand to rotate. If this significand contains more bits than
            the precision, the most-significant bits are chopped off the
            significand.</param>
            <param name='ed2'>An arbitrary-precision number indicating the
            number of bits to rotate the first operand's significand. Must be
            an integer with an exponent of 0. If this parameter is positive,
            the significand is shifted to the left by the given number of bits
            and the most-significant bits shifted out of the significand become
            the least-significant bits instead. If this parameter is negative,
            the number is shifted by the given number of bits and the
            least-significant bits shifted out of the significand become the
            most-significant bits instead.</param>
            <param name='ec'>An arithmetic context to control the precision of
            arbitrary-precision numbers. If this parameter is null or specifies
            an unlimited precision, this method has the same behavior as
            <c>Shift</c>.</param>
            <returns>An arbitrary-precision binary number whose significand is
            rotated the given number of bits. Signals an invalid operation and
            returns NaN (not-a-number) if <paramref name='ed2'/> is a signaling
            NaN or if <paramref name='ed2'/> is not an integer, is negative,
            has an exponent other than 0, or has an absolute value that exceeds
            the maximum precision specified in the context.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed2'/> or <paramref name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.CompareTotal(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Compares the values of one arbitrary-precision number
            object and another object, imposing a total ordering on all
            possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary>
            <param name='ed'>The first arbitrary-precision number to
            compare.</param>
            <param name='other'>The second arbitrary-precision number to
            compare.</param>
            <param name='ec'>An arithmetic context. Flags will be set in this
            context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
            context are true and only if an operand needed to be rounded before
            carrying out the operation. Can be null.</param>
            <returns>The number 0 if both objects are null or equal, or -1 if
            the first object is null or less than the other object, or 1 if the
            first object is greater or the other object is null. Does not
            signal flags if either value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.CompareTotalMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Compares the absolute values of two arbitrary-precision
            number objects, imposing a total ordering on all possible values
            (ignoring their signs). In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero and positive zero are considered equal.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item></list></summary>
            <param name='ed'>The first arbitrary-precision number to
            compare.</param>
            <param name='other'>The second arbitrary-precision number to
            compare.</param>
            <param name='ec'>An arithmetic context. Flags will be set in this
            context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
            context are true and only if an operand needed to be rounded before
            carrying out the operation. Can be null.</param>
            <returns>The number 0 if both objects are null or equal (ignoring
            their signs), or -1 if the first object is null or less than the
            other object (ignoring their signs), or 1 if the first object is
            greater (ignoring their signs) or the other object is null. Does
            not signal flags if either value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Copy(PeterO.Numbers.EFloat)">
            <summary>Creates a copy of the given arbitrary-precision number
            object.</summary>
            <param name='ed'>An arbitrary-precision number object to
            copy.</param>
            <returns>A copy of the given arbitrary-precision number
            object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Canonical(PeterO.Numbers.EFloat)">
            <summary>Returns a canonical version of the given
            arbitrary-precision number object. In this method, this method
            behaves like the Copy method.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>A copy of the parameter <paramref name='ed'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.CopyAbs(PeterO.Numbers.EFloat)">
            <summary>Returns an arbitrary-precision number object with the same
            value as the given number object but with a nonnegative sign (that
            is, the given number object's absolute value).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>An arbitrary-precision number object with the same value
            as the given number object but with a nonnegative sign.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.CopyNegate(PeterO.Numbers.EFloat)">
            <summary>Returns an arbitrary-precision number object with the sign
            reversed from the given number object.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>An arbitrary-precision number object with the sign
            reversed from the given number object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.CopySign(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Returns an arbitrary-precision number object with the same
            value as the first given number object but with a the same sign
            (positive or negative) as the second given number object.</summary>
            <param name='ed'>An arbitrary-precision number object with the
            value the result will have.</param>
            <param name='other'>The parameter <paramref name='other'/> is an
            arbitrary-precision binary floating-point number.</param>
            <returns>An arbitrary-precision number object with the same value
            as the first given number object but with a the same sign (positive
            or negative) as the second given number object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> or <paramref name='other'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloats.SameQuantum(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Returns whether two arbitrary-precision numbers have the
            same exponent, they both are not-a-number (NaN), or they both are
            infinity (positive and/or negative).</summary>
            <param name='ed1'>The first arbitrary-precision number.</param>
            <param name='ed2'>The second arbitrary-precision number.</param>
            <returns>Either <c>true</c> if the given arbitrary-precision
            numbers have the same exponent, they both are not-a-number (NaN),
            or they both are infinity (positive and/or negative); otherwise,
            <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Trim(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision number with the same value
            as this one but with certain trailing zeros removed from its
            significand. If the number's exponent is 0, it is returned
            unchanged (but may be rounded depending on the arithmetic context);
            if that exponent is greater 0, its trailing zeros are removed from
            the significand (then rounded if necessary); if that exponent is
            less than 0, its trailing zeros are removed from the significand
            until the exponent reaches 0 (then the number is rounded if
            necessary).</summary>
            <param name='ed1'>An arbitrary-precision number.</param>
            <param name='ec'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. Can be null.</param>
            <returns>An arbitrary-precision number with the same value as this
            one but with certain trailing zeros removed from its significand.
            If <paramref name='ed1'/> is not-a-number (NaN) or infinity, it is
            generally returned unchanged.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Rescale(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision binary number with the same
            value as this object but with the given exponent, expressed as an
            arbitrary-precision binary number.
            <para>Note that this is not always the same as rounding to a given
            number of binary places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            binary places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b> This method can be used to implement
            fixed-point binary arithmetic, in which a fixed number of digits
            come after the binary point. A fixed-point binary arithmetic in
            which no digits come after the binary point (a desired exponent of
            0) is considered an "integer arithmetic" .</para></summary>
            <param name='ed'>An arbitrary-precision binary number whose
            exponent is to be changed.</param>
            <param name='scale'>The desired exponent of the result, expressed
            as an arbitrary-precision binary number. The exponent is the number
            of fractional digits in the result, expressed as a negative number.
            Can also be positive, which eliminates lower-order places from the
            number. For example, -3 means round to the sixteenth (10b^-3,
            0.0001b), and 3 means round to the sixteens-place (10b^3, 1000b). A
            value of 0 rounds the number to an integer.</param>
            <param name='ec'>An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param>
            <returns>An arbitrary-precision binary number with the same value
            as this object but with the exponent changed. Signals FlagInvalid
            and returns not-a-number (NaN) if the result can't fit the given
            precision without rounding, or if the arithmetic context defines an
            exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.And(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Performs a logical AND operation on two binary numbers in
            the form of
            <i>logical operands</i>. A <c>logical operand</c> is a
            non-negative base-2 number with an Exponent property of 0 (examples
            include the base-2 numbers <c>01001</c> and <c>111001</c> ). The
            logical AND operation sets each bit of the result to 1 if the
            corresponding bits of each logical operand are both 1, and to 0
            otherwise. For example, <c>01001 AND 111010=01000</c>.</summary>
            <param name='ed1'>The first logical operand to the logical AND
            operation.</param>
            <param name='ed2'>The second logical operand to the logical AND
            operation.</param>
            <param name='ec'>An arithmetic context to control the maximum
            precision of arbitrary-precision numbers. If a logical operand
            passed to this method has more bits than the maximum precision
            specified in this context, the operand's most significant bits that
            exceed that precision are discarded. This parameter can be
            null.</param>
            <returns>The result of the logical AND operation as a logical
            operand. Signals an invalid operation and returns not-a-number
            (NaN) if <paramref name='ed1'/>, <paramref name='ed2'/>, or both
            are not logical operands.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Invert(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Performs a logical NOT operation on a binary number in the
            form of a
            <i>logical operand</i>. A <c>logical operand</c> is a non-negative
            base-2 number with an Exponent property of 0 (examples include
            <c>01001</c> and <c>111001</c> ). The logical NOT operation sets
            each bit of the result to 1 if the corresponding bit is 0, and to 0
            otherwise; it can set no more bits than the maximum precision,
            however. For example, if the maximum precision is 8 bits, then
            <c>NOT 111010=11000101</c>.</summary>
            <param name='ed1'>The operand to the logical NOT operation.</param>
            <param name='ec'>An arithmetic context to control the maximum
            precision of arbitrary-precision numbers. If a logical operand
            passed to this method has more bits than the maximum precision
            specified in this context, the operand's most significant bits that
            exceed that precision are discarded. This parameter cannot be null
            and must specify a maximum precision (unlimited precision contexts
            are not allowed).</param>
            <returns>The result of the logical NOT operation as a logical
            operand. Signals an invalid operation and returns not-a-number
            (NaN) if <paramref name='ed1'/> is not a logical operand.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Xor(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Performs a logical exclusive-OR (XOR) operation on two
            binary numbers in the form of
            <i>logical operands</i>. A <c>logical operand</c> is a
            non-negative base-2 number with an Exponent property of 0 (examples
            include the base-2 numbers <c>01001</c> and <c>111001</c> ). The
            logical exclusive-OR operation sets each digit of the result to 1
            if either corresponding digit of the logical operands, but not
            both, is 1, and to 0 otherwise. For example, <c>01001 XOR 111010 =
            101010</c>.</summary>
            <param name='ed1'>The first logical operand to the logical
            exclusive-OR operation.</param>
            <param name='ed2'>The second logical operand to the logical
            exclusive-OR operation.</param>
            <param name='ec'>An arithmetic context to control the maximum
            precision of arbitrary-precision numbers. If a logical operand
            passed to this method has more bits than the maximum precision
            specified in this context, the operand's most significant bits that
            exceed that precision are discarded. This parameter can be
            null.</param>
            <returns>The result of the logical exclusive-OR operation as a
            logical operand. Signals an invalid operation and returns
            not-a-number (NaN) if <paramref name='ed1'/>, <paramref
            name='ed2'/>, or both are not logical operands.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloats.Or(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Performs a logical OR operation on two binary numbers in
            the form of
            <i>logical operands</i>. A <c>logical operand</c> is a
            non-negative base-2 number with an Exponent property of 0 (examples
            include the base-2 numbers <c>01001</c> and <c>111001</c> ). The
            logical OR operation sets each bit of the result to 1 if either or
            both of the corresponding bits of each logical operand are 1, and
            to 0 otherwise. For example, <c>01001 OR 111010=111011</c>.</summary>
            <param name='ed1'>The first logical operand to the logical OR
            operation.</param>
            <param name='ed2'>The second logical operand to the logical OR
            operation.</param>
            <param name='ec'>An arithmetic context to control the maximum
            precision of arbitrary-precision numbers. If a logical operand
            passed to this method has more bits than the maximum precision
            specified in this context, the operand's most significant bits that
            exceed that precision are discarded. This parameter can be
            null.</param>
            <returns>The result of the logical OR operation as a logical
            operand. Signals an invalid operation and returns not-a-number
            (NaN) if <paramref name='ed1'/>, <paramref name='ed2'/>, or both
            are not logical operands.</returns>
        </member>
        <member name="T:PeterO.Numbers.EDecimals">
            <summary>A class that implements additional operations on
            arbitrary-precision decimal numbers. Many of them are listed as
            miscellaneous operations in the General Decimal Arithmetic
            Specification version 1.70.</summary>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Radix(PeterO.Numbers.EContext)">
            <summary>Returns the number 10, the decimal radix.</summary>
            <param name='ec'>Specifies an arithmetic context for rounding the
            number 10. Can be null.</param>
            <returns>The number 10, or the closest representable number to 10
            in the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Int32ToEDecimal(System.Int32,PeterO.Numbers.EContext)">
            <summary>Creates an arbitrary-precision decimal number from a
            32-bit signed integer.</summary>
            <param name='i32'>The parameter <paramref name='i32'/> is a 32-bit
            signed integer.</param>
            <param name='ec'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. Can be null.</param>
            <returns>An arbitrary-precision decimal number with the closest
            representable value to the given integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.BooleanToEDecimal(System.Boolean,PeterO.Numbers.EContext)">
            <summary>Converts a boolean value (either true or false) to an
            arbitrary-precision decimal number.</summary>
            <param name='b'>Either true or false.</param>
            <param name='ec'>A context used for rounding the result. Can be
            null.</param>
            <returns>Either 1 if <paramref name='b'/> is true, or 0 if
            <paramref name='b'/> is false.. The result will be rounded as
            specified by the given context, if any.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.IsCanonical(PeterO.Numbers.EDecimal)">
            <summary>Returns whether the given arbitrary-precision number
            object is in a canonical form. For the current version of EDecimal,
            all EDecimal objects are in a canonical form.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Always <c>true</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.IsFinite(PeterO.Numbers.EDecimal)">
            <summary>Returns whether the given arbitrary-precision number
            object is neither null nor infinity nor not-a-number
            (NaN).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> if the given arbitrary-precision number
            object is neither null nor infinity nor not-a-number (NaN), or
            <c>false</c> otherwise.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.IsInfinite(PeterO.Numbers.EDecimal)">
            <summary>Returns whether the given arbitrary-precision number
            object is positive or negative infinity.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> if the given arbitrary-precision number
            object is positive or negative infinity, or <c>false</c>
            otherwise.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.IsNaN(PeterO.Numbers.EDecimal)">
            <summary>Returns whether the given arbitrary-precision number
            object is a not-a-number (NaN).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.IsNormal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Returns whether the given number is a
            <i>normal</i> number. A
            <i>subnormal number</i> is a nonzero finite number whose Exponent
            property (or the number's exponent when that number is expressed in
            scientific notation with one digit before the radix point) is less
            than the minimum possible exponent for that number. A
            <i>normal number</i> is nonzero and finite, but not
            subnormal.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <param name='ec'>A context specifying the exponent range of
            arbitrary-precision numbers. Can be null. If AdjustExponent of the
            given context is <c>true</c>, a nonzero number is normal if the
            number's exponent (when that number is expressed in scientific
            notation with one nonzero digit before the radix point) is at least
            the given context's EMax property (e.g., if EMax is -100, 2.3456 *
            10
            <sup>-99</sup> is normal, but 2.3456 * 10
            <sup>-102</sup> is not). If AdjustExponent of the given context is
            <c>false</c>, a nonzero number is subnormal if the number's
            Exponent property is at least given context's EMax property (e.g.,
            if EMax is -100, 23456 * 10
            <sup>-99</sup> is normal, but 23456 * 10
            <sup>-102</sup> is not).</param>
            <returns>Either <c>true</c> if the given number is subnormal, or
            <c>false</c> otherwise. Returns <c>true</c> if the given context is
            null or HasExponentRange of the given context is <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.IsQuietNaN(PeterO.Numbers.EDecimal)">
            <summary>Returns whether the given arbitrary-precision number
            object is a quiet not-a-number (NaN).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.IsSigned(PeterO.Numbers.EDecimal)">
            <summary>Returns whether the given arbitrary-precision number
            object is negative (including negative infinity, negative
            not-a-number [NaN], or negative zero).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.IsSignalingNaN(PeterO.Numbers.EDecimal)">
            <summary>Returns whether the given arbitrary-precision number
            object is a signaling not-a-number (NaN).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.NumberClassString(System.Int32)">
            <summary>Converts a number class identifier (ranging from 0 through
            9) to a text string. An arbitrary-precision number object can
            belong in one of ten number classes.</summary>
            <param name='nc'>An integer identifying a number class.</param>
            <returns>A text string identifying the given number class as
            follows: 0 = "+Normal"; 1 = "-Normal", 2 = "+Subnormal", 3 =
            "-Subnormal", 4 = "+Zero", 5 = "-Zero", 6 = "+Infinity", 7 =
            "-Infinity", 8 = "NaN", 9 = "sNaN".</returns>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='nc'/> is less than 0 or greater than 9.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.NumberClass(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Finds the number class for an arbitrary-precision decimal
            number object.</summary>
            <param name='ed'>An arbitrary-precision decimal number
            object.</param>
            <param name='ec'>A context object that specifies the precision and
            exponent range of arbitrary-precision numbers. This is used only to
            distinguish between normal and subnormal numbers. Can be
            null.</param>
            <returns>A 32-bit signed integer identifying the given number
            object, number class as follows: 0 = positive normal; 1 = negative
            normal, 2 = positive subnormal, 3 = negative subnormal, 4 =
            positive zero, 5 = negative zero, 6 = positive infinity, 7 =
            negative infinity, 8 = quiet not-a-number (NaN), 9 = signaling
            NaN.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.IsSubnormal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Returns whether the given number is a
            <i>subnormal</i> number. A
            <i>subnormal number</i> is a nonzero finite number whose Exponent
            property (or the number's exponent when that number is expressed in
            scientific notation with one digit before the radix point) is less
            than the minimum possible exponent for that number.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <param name='ec'>A context specifying the exponent range of
            arbitrary-precision numbers. Can be null. If AdjustExponent of the
            given context is <c>true</c>, a nonzero number is subnormal if the
            number's exponent (when that number is expressed in scientific
            notation with one nonzero digit before the radix point) is less
            than the given context's EMax property (e.g., if EMax is -100,
            2.3456 * 10
            <sup>-102</sup> is subnormal, but 2.3456 * 10
            <sup>-99</sup> is not). If AdjustExponent of the given context is
            <c>false</c>, a nonzero number is subnormal if the number's
            Exponent property is less than the given context's EMax property
            (e.g., if EMax is -100, 23456 * 10
            <sup>-102</sup> is subnormal, but 23456 * 10
            <sup>-99</sup> is not).</param>
            <returns>Either <c>true</c> if the given number is subnormal, or
            <c>false</c> otherwise. Returns <c>false</c> if the given context
            is null or HasExponentRange of the given context is <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.IsZero(PeterO.Numbers.EDecimal)">
            <summary>Returns whether the given arbitrary-precision number
            object is zero (positive zero or negative zero).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns><c>true</c> if the given number has a value of zero
            (positive zero or negative zero); otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.LogB(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Returns the base-10 exponent of an arbitrary-precision
            decimal number (when that number is expressed in scientific
            notation with one digit before the radix point). For example,
            returns 3 for the numbers <c>6.66E + 3</c> and <c>666E + 1</c>.</summary>
            <param name='ed'>An arbitrary-precision decimal number.</param>
            <param name='ec'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. Can be null.</param>
            <returns>The base-10 exponent of the given number (when that number
            is expressed in scientific notation with one nonzero digit before
            the radix point). Signals DivideByZero and returns negative
            infinity if <paramref name='ed'/> is zero. Returns positive
            infinity if <paramref name='ed'/> is positive infinity or negative
            infinity.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.ScaleB(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Finds an arbitrary-precision decimal number whose decimal
            point is moved a given number of places.</summary>
            <param name='ed'>An arbitrary-precision decimal number.</param>
            <param name='ed2'>The number of decimal places to move the decimal
            point of "ed". This must be an integer with an exponent of
            0.</param>
            <param name='ec'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. Can be null.</param>
            <returns>The given arbitrary-precision decimal number whose decimal
            point is moved the given number of places. Signals an invalid
            operation and returns not-a-number (NaN) if <paramref name='ed2'/>
            is infinity or NaN, has an Exponent property other than 0. Signals
            an invalid operation and returns not-a-number (NaN) if <paramref
            name='ec'/> defines a limited precision and exponent range and if
            <paramref name='ed2'/> 's absolute value is greater than twice the
            sum of the context's EMax property and its Precision
            property.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> or <paramref name='ed2'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Shift(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Shifts the digits of an arbitrary-precision decimal
            number's significand.</summary>
            <param name='ed'>An arbitrary-precision number containing the
            significand to shift.</param>
            <param name='ed2'>An arbitrary-precision number indicating the
            number of digits to shift the first operand's significand. Must be
            an integer with an exponent of 0. If this parameter is positive,
            the significand is shifted to the left by the given number of
            digits. If this parameter is negative, the significand is shifted
            to the right by the given number of digits.</param>
            <param name='ec'>An arithmetic context to control the precision of
            arbitrary-precision numbers. Can be null.</param>
            <returns>An arbitrary-precision decimal number whose significand is
            shifted the given number of digits. Signals an invalid operation
            and returns NaN (not-a-number) if <paramref name='ed2'/> is a
            signaling NaN or if <paramref name='ed2'/> is not an integer, is
            negative, has an exponent other than 0, or has an absolute value
            that exceeds the maximum precision specified in the
            context.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> or <paramref name='ed2'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Rotate(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Rotates the digits of an arbitrary-precision decimal
            number's significand.</summary>
            <param name='ed'>An arbitrary-precision number containing the
            significand to rotate. If this significand contains more digits
            than the precision, the most-significant digits are chopped off the
            significand before the rotation begins.</param>
            <param name='ed2'>An arbitrary-precision number indicating the
            number of digits to rotate the first operand's significand. Must be
            an integer with an exponent of 0. If this parameter is positive,
            the significand is shifted to the left by the given number of
            digits and the most-significant digits shifted out of the
            significand become the least-significant digits instead. If this
            parameter is negative, the significand is shifted to the right by
            the given number of digits and the least-significant digits shifted
            out of the significand become the most-significant digits
            instead.</param>
            <param name='ec'>An arithmetic context to control the precision of
            arbitrary-precision numbers. If this parameter is null or specifies
            an unlimited precision, this method has the same behavior as
            <c>Shift</c>.</param>
            <returns>An arbitrary-precision decimal number whose significand is
            rotated the given number of digits. Signals an invalid operation
            and returns NaN (not-a-number) if <paramref name='ed2'/> is a
            signaling NaN or if <paramref name='ed2'/> is not an integer, is
            negative, has an exponent other than 0, or has an absolute value
            that exceeds the maximum precision specified in the
            context.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed2'/> or <paramref name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.CompareTotal(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Compares the values of one arbitrary-precision number
            object and another object, imposing a total ordering on all
            possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary>
            <param name='ed'>The first arbitrary-precision number to
            compare.</param>
            <param name='other'>The second arbitrary-precision number to
            compare.</param>
            <param name='ec'>An arithmetic context. Flags will be set in this
            context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
            context are true and only if an operand needed to be rounded before
            carrying out the operation. Can be null.</param>
            <returns>The number 0 if both objects are null or equal, or -1 if
            the first object is null or less than the other object, or 1 if the
            first object is greater or the other object is null. Does not
            signal flags if either value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.CompareTotalMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Compares the absolute values of two arbitrary-precision
            number objects, imposing a total ordering on all possible values
            (ignoring their signs). In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero and positive zero are considered equal.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item></list></summary>
            <param name='ed'>The first arbitrary-precision number to
            compare.</param>
            <param name='other'>The second arbitrary-precision number to
            compare.</param>
            <param name='ec'>An arithmetic context. Flags will be set in this
            context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
            context are true and only if an operand needed to be rounded before
            carrying out the operation. Can be null.</param>
            <returns>The number 0 if both objects are null or equal (ignoring
            their signs), or -1 if the first object is null or less than the
            other value (ignoring their signs), or 1 if the first object is
            greater (ignoring their signs) or the other object is null. Does
            not signal flags if either value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Copy(PeterO.Numbers.EDecimal)">
            <summary>Creates a copy of the given arbitrary-precision number
            object.</summary>
            <param name='ed'>An arbitrary-precision number object to
            copy.</param>
            <returns>A copy of the given arbitrary-precision number
            object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Canonical(PeterO.Numbers.EDecimal)">
            <summary>Returns a canonical version of the given
            arbitrary-precision number object. In this method, this method
            behaves like the Copy method.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>A copy of the parameter <paramref name='ed'/>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.CopyAbs(PeterO.Numbers.EDecimal)">
            <summary>Returns an arbitrary-precision number object with the same
            value as the given number object but with a nonnegative sign (that
            is, the given number object's absolute value).</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>An arbitrary-precision number object with the same value
            as the given number object but with a nonnegative sign.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.CopyNegate(PeterO.Numbers.EDecimal)">
            <summary>Returns an arbitrary-precision number object with the sign
            reversed from the given number object.</summary>
            <param name='ed'>An arbitrary-precision number object.</param>
            <returns>An arbitrary-precision number object with the sign
            reversed from the given number object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.CopySign(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Returns an arbitrary-precision number object with the same
            value as the first given number object but with a the same sign
            (positive or negative) as the second given number object.</summary>
            <param name='ed'>An arbitrary-precision number object with the
            value the result will have.</param>
            <param name='other'>The parameter <paramref name='other'/> is an
            arbitrary-precision decimal floating-point number.</param>
            <returns>An arbitrary-precision number object with the same value
            as the first given number object but with a the same sign (positive
            or negative) as the second given number object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter <paramref
            name='ed'/> or <paramref name='other'/> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.SameQuantum(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Returns whether two arbitrary-precision numbers have the
            same exponent, they both are not-a-number (NaN), or they both are
            infinity (positive and/or negative).</summary>
            <param name='ed1'>The first arbitrary-precision number.</param>
            <param name='ed2'>The second arbitrary-precision number.</param>
            <returns>Either <c>true</c> if the given arbitrary-precision
            numbers have the same exponent, they both are not-a-number (NaN),
            or they both are infinity (positive and/or negative); otherwise,
            <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Trim(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision number with the same value
            as this one but with certain trailing zeros removed from its
            significand. If the number's exponent is 0, it is returned
            unchanged (but may be rounded depending on the arithmetic context);
            if that exponent is greater 0, its trailing zeros are removed from
            the significand (then rounded if necessary); if that exponent is
            less than 0, its trailing zeros are removed from the significand
            until the exponent reaches 0 (then the number is rounded if
            necessary).</summary>
            <param name='ed1'>An arbitrary-precision number.</param>
            <param name='ec'>An arithmetic context to control the precision,
            rounding, and exponent range of the result. Can be null.</param>
            <returns>An arbitrary-precision number with the same value as this
            one but with certain trailing zeros removed from its significand.
            If <paramref name='ed1'/> is not-a-number (NaN) or infinity, it is
            generally returned unchanged.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Rescale(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Returns an arbitrary-precision decimal number with the
            same value as this object but with the given exponent, expressed as
            an arbitrary-precision decimal number.
            <para>Note that this is not always the same as rounding to a given
            number of decimal places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            decimal places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b> This method can be used to implement
            fixed-point decimal arithmetic, in which a fixed number of digits
            come after the decimal point. A fixed-point decimal arithmetic in
            which no digits come after the decimal point (a desired exponent of
            0) is considered an "integer arithmetic" .</para></summary>
            <param name='ed'>An arbitrary-precision decimal number whose
            exponent is to be changed.</param>
            <param name='scale'>The desired exponent of the result, expressed
            as an arbitrary-precision decimal number. The exponent is the
            number of fractional digits in the result, expressed as a negative
            number. Can also be positive, which eliminates lower-order places
            from the number. For example, -3 means round to the thousandth
            (10^-3, 0.0001), and 3 means round to the thousands-place (10^3,
            1000). A value of 0 rounds the number to an integer.</param>
            <param name='ec'>The parameter <paramref name='ec'/> is an EContext
            object.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as this object but with the exponent changed. Signals FlagInvalid
            and returns not-a-number (NaN) if the result can't fit the given
            precision without rounding, or if the arithmetic context defines an
            exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.And(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Performs a logical AND operation on two decimal numbers in
            the form of
            <i>logical operands</i>. A <c>logical operand</c> is a
            non-negative base-10 number with an Exponent property of 0 and no
            other base-10 digits than 0 or 1 (examples include <c>01001</c> and
            <c>111001</c>, but not <c>02001</c> or <c>99999</c> ). The logical
            AND operation sets each digit of the result to 1 if the
            corresponding digits of each logical operand are both 1, and to 0
            otherwise. For example, <c>01001 AND 111010=01000</c>.</summary>
            <param name='ed1'>The first logical operand to the logical AND
            operation.</param>
            <param name='ed2'>The second logical operand to the logical AND
            operation.</param>
            <param name='ec'>An arithmetic context to control the maximum
            precision of arbitrary-precision numbers. If a logical operand
            passed to this method has more digits than the maximum precision
            specified in this context, the operand's most significant digits
            that exceed that precision are discarded. This parameter can be
            null.</param>
            <returns>The result of the logical AND operation as a logical
            operand. Signals an invalid operation and returns not-a-number
            (NaN) if <paramref name='ed1'/>, <paramref name='ed2'/>, or both
            are not logical operands.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Invert(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Performs a logical NOT operation on an arbitrary-precision
            decimal number in the form of a
            <i>logical operand</i>. A <c>logical operand</c> is a non-negative
            base-10 number with an Exponent property of 0 and no other base-10
            digits than 0 or 1 (examples include <c>01001</c> and <c>111001</c>
            , but not <c>02001</c> or <c>99999</c> ). The logical NOT operation
            sets each digit of the result to 1 if the corresponding digit is 0,
            and to 0 otherwise; it can set no more digits than the maximum
            precision, however. For example, if the maximum precision is 8
            digits, then <c>NOT 111010=11000101</c>.</summary>
            <param name='ed1'>The logical operand to the logical NOT
            operation.</param>
            <param name='ec'>An arithmetic context to control the maximum
            precision of arbitrary-precision numbers. If a logical operand
            passed to this method has more digits than the maximum precision
            specified in this context, the operand's most significant digits
            that exceed that precision are discarded. This parameter cannot be
            null and must specify a maximum precision (unlimited precision
            contexts are not allowed).</param>
            <returns>The result of the logical NOT operation as a logical
            operand. Signals an invalid operation and returns not-a-number
            (NaN) if <paramref name='ed1'/> is not a logical operand.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Xor(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Performs a logical exclusive-OR (XOR) operation on two
            decimal numbers in the form of
            <i>logical operands</i>. A <c>logical operand</c> is a
            non-negative base-10 number with an exponent of 0 and no other
            base-10 digits than 0 or 1 (examples include <c>01001</c> and
            <c>111001</c>, but not <c>02001</c> or <c>99999</c> ). The logical
            exclusive-OR operation sets each digit of the result to 1 if either
            corresponding digit of the logical operands, but not both, is 1,
            and to 0 otherwise. For example, <c>01001 XOR 111010=101010</c>.</summary>
            <param name='ed1'>The first logical operand to the logical
            exclusive-OR operation.</param>
            <param name='ed2'>The second logical operand to the logical
            exclusive-OR operation.</param>
            <param name='ec'>An arithmetic context to control the maximum
            precision of arbitrary-precision numbers. If a logical operand
            passed to this method has more digits than the maximum precision
            specified in this context, the operand's most significant digits
            that exceed that precision are discarded. This parameter can be
            null.</param>
            <returns>An arbitrary-precision decimal floating-point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimals.Or(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Performs a logical OR operation on two decimal numbers in
            the form of
            <i>logical operands</i>. A <c>logical operand</c> is a
            non-negative base-10 number with an Exponent property of 0 and no
            other base-10 digits than 0 or 1 (examples include <c>01001</c> and
            <c>111001</c>, but not <c>02001</c> or <c>99999</c> ). The logical
            OR operation sets each digit of the result to 1 if either or both
            of the corresponding digits of the logical operands are 1, and to 0
            otherwise. For example, <c>01001 OR 111010=111011</c>.</summary>
            <param name='ed1'>The first logical operand to the logical OR
            operation.</param>
            <param name='ed2'>The second logical operand to the logical OR
            operation.</param>
            <param name='ec'>An arithmetic context to control the maximum
            precision of arbitrary-precision numbers. If a logical operand
            passed to this method has more digits than the maximum precision
            specified in this context, the operand's most significant digits
            that exceed that precision are discarded. This parameter can be
            null.</param>
            <returns>The result of the logical OR operation as a logical
            operand. Signals an invalid operation and returns not-a-number
            (NaN) if <paramref name='ed1'/>, <paramref name='ed2'/>, or both
            are not logical operands.</returns>
        </member>
        <member name="T:PeterO.Numbers.ETrapException">
            <summary>Exception thrown for arithmetic trap errors. (The "E"
            stands for "extended", and has this prefix to group it with the
            other classes common to this library, particularly EDecimal,
            EFloat, and ERational.).
            <para>This library may throw exceptions of this type in certain
            cases, notably when errors occur, and may supply messages to those
            exceptions (the message can be accessed through the <c>Message</c>
            property in.NET or the <c>getMessage()</c> method in Java). These
            messages are intended to be read by humans to help diagnose the
            error (or other cause of the exception); they are not intended to
            be parsed by computer programs, and the exact text of the messages
            may change at any time between versions of this
            library.</para></summary>
        </member>
        <member name="P:PeterO.Numbers.ETrapException.Context">
            <summary>Gets the arithmetic context used during the operation that
            triggered the trap. May be null.</summary>
            <value>The arithmetic context used during the operation that
            triggered the trap. May be null.</value>
        </member>
        <member name="M:PeterO.Numbers.ETrapException.#ctor">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Numbers.ETrapException'/> class.</summary>
        </member>
        <member name="M:PeterO.Numbers.ETrapException.#ctor(System.String)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Numbers.ETrapException'/> class.</summary>
            <param name='message'>The parameter <paramref name='message'/> is a
            text string.</param>
        </member>
        <member name="M:PeterO.Numbers.ETrapException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Numbers.ETrapException'/> class.</summary>
            <param name='message'>The parameter <paramref name='message'/> is a
            text string.</param>
            <param name='innerException'>The parameter <paramref
            name='innerException'/> is an Exception object.</param>
        </member>
        <member name="P:PeterO.Numbers.ETrapException.Result">
            <summary>Gets the defined result of the operation that caused the
            trap.</summary>
            <value>The defined result of the operation that caused the
            trap.</value>
        </member>
        <member name="P:PeterO.Numbers.ETrapException.Error">
            <summary>Gets the flag that specifies the primary kind of error in
            one or more operations (EContext.FlagXXX). This will only be one
            flag, such as <c>FlagInexact</c> or FlagSubnormal.</summary>
            <value>The flag that specifies the primary kind of error in one or
            more operations.</value>
        </member>
        <member name="P:PeterO.Numbers.ETrapException.Errors">
            <summary>Gets the flags that were signaled as the result of one or
            more operations. This includes the flag specified in the "flag"
            parameter, but can include other flags. For instance, if "flag" is
            <c>EContext.FlagInexact</c>, this parameter might be
            <c>EContext.FlagInexact | EContext.FlagRounded</c>.</summary>
            <value>The flags that specify the errors in one or more
            operations.</value>
        </member>
        <member name="M:PeterO.Numbers.ETrapException.HasError(System.Int32)">
            <summary>Returns whether this trap exception specifies all the
            flags given. (Flags are signaled in a trap exception as the result
            of one or more operations involving arbitrary-precision numbers,
            such as multiplication of two EDecimals.).</summary>
            <param name='flag'>A combination of one or more flags, such as
            <c>EContext.FlagInexact | EContext.FlagRounded</c>.</param>
            <returns>True if this exception pertains to all of the flags given
            in <paramref name='flag'/> ; otherwise, false.</returns>
        </member>
        <member name="M:PeterO.Numbers.ETrapException.#ctor(System.Int32,PeterO.Numbers.EContext,System.Object)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Numbers.ETrapException'/> class.</summary>
            <param name='flag'>The flag that specifies the kind of error from
            one or more operations (EContext.FlagXXX). This will only be one
            flag, such as <c>FlagInexact</c> or FlagSubnormal.</param>
            <param name='ctx'>The arithmetic context used during the operation
            that triggered the trap. Can be null.</param>
            <param name='result'>The defined result of the operation that
            caused the trap.</param>
        </member>
        <member name="M:PeterO.Numbers.ETrapException.#ctor(System.Int32,System.Int32,PeterO.Numbers.EContext,System.Object)">
            <summary>Initializes a new instance of the
            <see cref='T:PeterO.Numbers.ETrapException'/> class.</summary>
            <param name='flags'>Specifies the flags that were signaled as the
            result of one or more operations. This includes the flag specified
            in the "flag" parameter, but can include other flags. For instance,
            if "flag" is <c>EContext.FlagInexact</c>, this parameter might be
            <c>EContext.FlagInexact | EContext.FlagRounded</c>.</param>
            <param name='flag'>Specifies the flag that specifies the primary
            kind of error from one or more operations (EContext.FlagXXX). This
            will only be one flag, such as <c>FlagInexact</c> or
            FlagSubnormal.</param>
            <param name='ctx'>The arithmetic context used during the operation
            that triggered the trap. Can be null.</param>
            <param name='result'>The defined result of the operation that
            caused the trap.</param>
            <exception cref='T:System.ArgumentException'>The parameter <paramref
            name='flags'/> doesn't include all the flags in the <paramref
            name='flag'/> parameter.</exception>
        </member>
    </members>
</doc>
